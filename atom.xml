<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>印象煜寒</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yuhanle.com/"/>
  <updated>2018-07-05T01:20:43.887Z</updated>
  <id>https://blog.yuhanle.com/</id>
  
  <author>
    <name>煜寒了</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue 知识点总结</title>
    <link href="https://blog.yuhanle.com/2018/07/04/vue-tips/"/>
    <id>https://blog.yuhanle.com/2018/07/04/vue-tips/</id>
    <published>2018-07-04T01:00:00.000Z</published>
    <updated>2018-07-05T01:20:43.887Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇枯燥的知识总结，希望在有需要的时候能够找到它！</p><a id="more"></a><h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h2><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p><h3 id="通过对路由route的判断来设置-active-name，open-names"><a href="#通过对路由route的判断来设置-active-name，open-names" class="headerlink" title="通过对路由route的判断来设置 active-name，open-names"></a>通过对路由route的判断来设置 active-name，open-names</h3><p>在使用 <code>menu</code> 组件时，我们需要根据路由的 path 来默认选中某一个 tab，下面给出的就是根据 fullpath 来设置默认 tab 的好方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Menu ref=&quot;left_menu&quot; :theme=&quot;theme2&quot; width=&quot;auto&quot; active-name=&quot;currentPage&quot; :open-names=&quot;openedSubmenuArr&quot; accordion @on-select=&quot;changeMenu&quot;&gt;</span><br><span class="line">……(省略代码)</span><br><span class="line">&lt;/Menu&gt;</span><br><span class="line">……(省略代码)</span><br><span class="line">created() &#123;</span><br><span class="line">    console.log(&quot;router detect:&quot;, this.$route);</span><br><span class="line">    let path = this.$route.fullPath.match(/^\/(.*)\//);</span><br><span class="line">    this.currentPage = this.$route.name;</span><br><span class="line">    this.openedSubmenuArr = [].concat(path);</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.$refs.left_menu.updateOpened();</span><br><span class="line">        this.$refs.left_menu.updateActiveName()</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要有默认子路由，那父路由的名字-name-得去掉"><a href="#要有默认子路由，那父路由的名字-name-得去掉" class="headerlink" title="要有默认子路由，那父路由的名字 name 得去掉"></a>要有默认子路由，那父路由的名字 name 得去掉</h3><p>开发过程中，在配置路由阶段，可能会遇到一下警告提示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vue-router] Named Route <span class="string">'my'</span> has a <span class="keyword">default</span> child route.</span><br><span class="line"><span class="function">When navigating to <span class="keyword">this</span> named <span class="title">route</span> <span class="params">(:to=<span class="string">"&#123;name: 'my'"</span>)</span>, the <span class="keyword">default</span> child route will not be rendered.</span></span><br><span class="line"><span class="function">Remove the name from <span class="keyword">this</span> route and use the name of the <span class="keyword">default</span> child route <span class="keyword">for</span> named links instead.</span></span><br></pre></td></tr></table></figure><p>虽然仅仅是警告，不影响功能和显示，但是依然要解决它，避免新的问题产生。警告提示的大概意思是 <strong><code>要有默认子路由，那父路由的名字name得去掉</code></strong>，也就是说在 子路由 里如有有默认路由的话，父路由不需要设置 <code>name</code> 字段。具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/admin'</span>, <span class="comment">// =&gt; 注意父路由此处不设置 name 字段</span></span><br><span class="line">      component: Admin,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/'</span>,  <span class="comment">// =&gt; 默认路由</span></span><br><span class="line">          redirect: <span class="string">'/admin/index'</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>很多情况下，我们需要在访问某个页面之前，先做一次关于 session 的检查，如果不存在 session 的话，跳转至认证页面，就需要使用如下这个钩子函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (store.getters.token.length === <span class="number">0</span> &amp;&amp; to.path !== <span class="string">'/login'</span>) &#123;</span><br><span class="line">    next(<span class="string">'/login'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也有很多情况下，比如在加载页面过程中，顶部加载进度条，我们可以根据钩子，在开始加载时加入进度显示，路由结束时隐藏就行。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>在很多人看来，前端开发的痛点，就是状态管理，页面之间传值会导致代码的高度耦合，在接触 Vue 的过程中，自然是要了解 Vuex 的使用。类似于 redux 和 Mobx 以及 Flux 的概念，具体使用细节只要按照官方文档和教程操作就行。以下记录中间需要注意和了解的知识点：</p><h3 id="一个小示例"><a href="#一个小示例" class="headerlink" title="一个小示例"></a>一个小示例</h3><p>我们先从一个小示例开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着，我们可以在业务方，通过 Action 的 dispatch 方法来调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&apos;increment&apos;, ...)</span><br></pre></td></tr></table></figure><p>另外一点需要注意的是，组合 Action 的时候，官方不建议使用异步，但是根据实测结果，异步调用目前没有发现什么问题。</p><p>来看一个更加实际的购物车示例，涉及到<strong>调用异步 API</strong> 和<strong>分发多重 mutation</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="mapState-amp-mapGetters"><a href="#mapState-amp-mapGetters" class="headerlink" title="mapState &amp; mapGetters"></a>mapState &amp; mapGetters</h3><p>作为 Vuex 的辅助方法，可以简化我们在业务中对 store 的引用，不必再写很多繁琐的映射。这里有一点需要在意的是：</p><p>如果你有使用 modules 使用多个模块，在调用 state 的时候，需要使用 <code>store.state.xxx.yyy</code>，其中 <code>xxx</code> 是模块名，也可以自定义模块名，<code>yyy</code> 就是 state 中定义的字段名；而在使用 getters 的时候，不管存在多少 modules，都是直接使用 <code>store.getters.yyy</code> 的方式来获取。</p><p>另外，Vuex 不仅仅提供状态同步和保存，更多时候可以作为 filter 来过滤处理脏数据，业务方无需关心原始数据，通过接口和参数，获取到自己想要的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>未完待续。。。 不断总结更新</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇枯燥的知识总结，希望在有需要的时候能够找到它！&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://blog.yuhanle.com/categories/Vue/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>代码中的缩进线</title>
    <link href="https://blog.yuhanle.com/2018/04/24/line-of-sight-in-code/"/>
    <id>https://blog.yuhanle.com/2018/04/24/line-of-sight-in-code/</id>
    <published>2018-04-24T01:00:00.000Z</published>
    <updated>2018-07-05T01:24:58.518Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_CBjBs9EzL8q1AL6XvjjpJg.png" alt="我在2016年伦敦Golang英国会议上谈论代码缩进线"></p><p>在近期伦敦举行的 <a href="https://www.youtube.com/watch?v=yeetIgNeIkc" target="_blank" rel="noopener">Golang 英国会议</a> 上，我在<a href="https://www.youtube.com/watch?v=yeetIgNeIkc" target="_blank" rel="noopener">地道的Go 语言窍门</a> 交流（<a href="http://go-talks.appspot.com/github.com/matryer/present/idiomatic-go-tricks/main.slide#1" target="_blank" rel="noopener">幻灯片</a>）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。</p><a id="more"></a><blockquote><p>缩进线是“观察者无障碍视线的直线”</p></blockquote><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_nXXRSHi_1kmgorkcDHyc1Q.png" alt="代码中的缩进线：左图的缩进是错误处理和边缘情况的快乐路径"></p><p>良好的代码缩进线不仅对你的功能没有任何影响，还可以帮助其他需要的人阅读你的代码。其他程序员（包括你未来的自己）可以浏览一个专栏并且理解代码的预期流程。如果他们不得不在脑子里分析 <code>if</code> 语句，若没有良好的缩进线，将会使这个任务变得非常艰难。</p><blockquote><p>大多数人关注编写代码的代价（比如“这需要多长时间才能完成？”）但是维护代码的成本要高得多 - 特别是在成熟的项目中。 让功能明显，清晰，简单易懂才是至关重要的。</p></blockquote><p>良好缩进线的建议：</p><ul><li>让<a href="https://en.wikipedia.org/wiki/Happy_path" target="_blank" rel="noopener">快乐路径</a>居左侧对齐，这样你就可以快速扫描一列来查看预期的执行流程</li><li>不要隐藏缩进大括号中代码逻辑</li><li>尽早的退出 <code>function</code></li><li>避免 <code>else return</code>，考虑翻转 <code>if</code> 语句</li><li>把 <code>return</code> 声明作为最后一行</li><li>提取 <code>function</code> 和 <code>method</code> 以保持结构小巧和可读</li><li>如果你需要大缩进的代码，考虑当做一个 <code>function</code> 分解出来</li></ul><p>当然，会有很多很好的理由来打破所有这些规则 - 但是采用这种风格作为默认规则，我们发现我们的代码变得更具可读性。</p><h2 id="避免-else-return"><a href="#避免-else-return" class="headerlink" title="避免 else return"></a>避免 <code>else return</code></h2><p>编写具有良好视觉效果的代码的关键是保持 <code>else</code> 结构小巧，或者如果可以的话，完全避免它们。 看下这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if something.OK() &#123;</span><br><span class="line">    something.Lock()</span><br><span class="line">    defer something.Unlock()</span><br><span class="line">    err := something.Do()</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        stop := StartTimer()</span><br><span class="line">        defer stop()</span><br><span class="line">        log.Println(&quot;working...&quot;)</span><br><span class="line">        doWork(something)</span><br><span class="line">        &lt;-something.Done() // wait for it</span><br><span class="line">        log.Println(&quot;finished&quot;)</span><br><span class="line">        return nil</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return errors.New(&quot;something not ok&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代表了我们最初如何思考我们的功能在做什么（“如果某件事情没问题，那么就做，如果没有错误，那么做这些事情”等等），但是它变得很难遵循。</p><p>上面的代码很难遵循’快乐路径’（执行顺利进行的路线）。它在第二行开始缩进并从那里继续。 当我们检查来自 <code>something.Do()</code> 的错误返回时，我们进一步缩进。 事实上，语句“ <code>return nil</code> ”在代码中间完全丢失。</p><p><code>else</code> 结构在 Go 和其他语言中作为单一行返回很常见，因为它们要处理中止或退出函数。 我认为他们不能保证缩进我们的其他代码。</p><h2 id="翻转-if-语句"><a href="#翻转-if-语句" class="headerlink" title="翻转 if 语句"></a>翻转 if 语句</h2><p>如果我们要翻译 <code>if</code> 语句<em>（如果你喜欢</em> ， <em>就把它们</em>翻<em>过来）</em> ，你可以看到代码变得更加可读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if !something.OK() &#123;  // flipped</span><br><span class="line">    return errors.New(&quot;something not ok&quot;)</span><br><span class="line">&#125;</span><br><span class="line">something.Lock()</span><br><span class="line">defer something.Unlock()</span><br><span class="line">err := something.Do()</span><br><span class="line">if err != nil &#123;       // flipped</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop := StartTimer()</span><br><span class="line">defer stop()</span><br><span class="line"></span><br><span class="line">log.Println(&quot;working...&quot;)</span><br><span class="line">doWork(something)</span><br><span class="line">&lt;-something.Done() // wait for it</span><br><span class="line">log.Println(&quot;finished&quot;)</span><br><span class="line">return nil</span><br></pre></td></tr></table></figure><p>在此代码中，我们正在尽早退出，退出代码与正常代码不同。而且，</p><ul><li>快乐路径沿着左侧向下保持，</li><li>我们缩进只是为了处理错误和边缘情况，</li><li>我们的 <code>retutn</code> 声明“ <code>return nil</code> ”在最后一行，并且，</li><li>我们有更少的缩进代码块。</li></ul><h2 id="促进大型条件块的功能"><a href="#促进大型条件块的功能" class="headerlink" title="促进大型条件块的功能"></a>促进大型条件块的功能</h2><p>如果你不能避免一个笨重的 <code>else</code> 结构或臃肿的选择切换的情况（我明白了，有时候你不能），那么就考虑把每个结构分解成它自己的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func processValue(v interface&#123;&#125;) error &#123;</span><br><span class="line">    switch val := v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        return processString(val)</span><br><span class="line">    case int:</span><br><span class="line">        return processInt(val)</span><br><span class="line">    case bool:</span><br><span class="line">        return processBool(val)</span><br><span class="line">    default:</span><br><span class="line">        return fmt.Errorf(&quot;unsupported type %T&quot;, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比读取大量的处理代码更容易阅读。</p><h2 id="分享你的经验"><a href="#分享你的经验" class="headerlink" title="分享你的经验"></a>分享你的经验</h2><p>如果你同意我的观点，请考虑分享这篇文章 - 随着越来越多的人注册，更好的（更一致的）Go 代码将会出现。</p><p>你有一些难以阅读的代码吗？ 为什么不在 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=https://twitter.com/matryer&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgR995EkjexZDOQl9LYu8Sl7eq3TA" target="_blank" rel="noopener">Twitter @matryer</a> 上分享它，可以看看我们是否可以找到一个更清洁，更简单的版本。</p><h2 id="致谢…"><a href="#致谢…" class="headerlink" title="致谢…"></a>致谢…</h2><p>评论家<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=http://dave.cheney.net/&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgTC1jmfDNNabAZ1iX8dJSOjyuddw" target="_blank" rel="noopener">戴夫切尼</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=http://twitter.com/dahernan&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhm04bLuew6j4VCw3ACIxtPeMMmxA" target="_blank" rel="noopener">大卫埃尔南德斯</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=https://twitter.com/goinggodotnet&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhi57B943koWpS6pe4_aRslBMy-7mw" target="_blank" rel="noopener">威廉肯尼迪</a> 。</p><hr><p>via: <a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p><p>作者：<a href="https://medium.com/@matryer" target="_blank" rel="noopener">Mat Ryer</a>  译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a>  校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/12928" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p><p>本文由 GCTT 原创翻译，<a href="https://studygolang.com/articles/12928" target="_blank" rel="noopener">Go语言中文网</a> 首发。也想加入译者行列，为开源做一些自己的贡献么？欢迎加入 <a href="https://studygolang.com/gctt" target="_blank" rel="noopener">GCTT</a>！<br>翻译工作和译文发表仅用于学习和交流目的，翻译工作遵照 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-SA 协议规定</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。<br>欢迎遵照 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-SA 协议规定</a> 转载，敬请在正文中标注并保留原文/译文链接和作者/译者等信息。<br>文章仅代表作者的知识和看法，如有不同观点，请楼下排队吐槽</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_CBjBs9EzL8q1AL6XvjjpJg.png&quot; alt=&quot;我在2016年伦敦Golang英国会议上谈论代码缩进线&quot;&gt;&lt;/p&gt;
&lt;p&gt;在近期伦敦举行的 &lt;a href=&quot;https://www.youtube.com/watch?v=yeetIgNeIkc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 英国会议&lt;/a&gt; 上，我在&lt;a href=&quot;https://www.youtube.com/watch?v=yeetIgNeIkc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地道的Go 语言窍门&lt;/a&gt; 交流（&lt;a href=&quot;http://go-talks.appspot.com/github.com/matryer/present/idiomatic-go-tricks/main.slide#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;幻灯片&lt;/a&gt;）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>记录一次简单的逆向</title>
    <link href="https://blog.yuhanle.com/2018/04/24/a-simple-iosre/"/>
    <id>https://blog.yuhanle.com/2018/04/24/a-simple-iosre/</id>
    <published>2018-04-24T01:00:00.000Z</published>
    <updated>2018-07-05T01:14:52.554Z</updated>
    
    <content type="html"><![CDATA[<p>由于爱奇艺会员到期，于是产生逆向APP 的想法，尚未找到解决办法。</p><h2 id="安装MonkeyDev"><a href="#安装MonkeyDev" class="headerlink" title="安装MonkeyDev"></a>安装MonkeyDev</h2><p>原有iOSOpenDev的升级，非越狱插件开发集成神器！</p><a id="more"></a><ul><li>可以使用Xcode开发CaptainHook Tweak、Logos Tweak 和 Command-line Tool，在越狱机器开发插件，这是原来iOSOpenDev功能的迁移和改进。</li><li>只需拖入一个砸壳应用，自动集成class-dump、restore-symbol、Reveal、Cycript和注入的动态库并重签名安装到非越狱机器。</li><li>支持调试自己编写的动态库和第三方App</li><li>支持通过CocoaPods第三方应用集成SDK以及非越狱插件，简单来说就是通过CocoaPods搭建了一个非越狱插件商店。</li></ul><p>安装教程可参考：<a href="https://github.com/AloneMonkey/MonkeyDev/wiki" target="_blank" rel="noopener">安装</a></p><h2 id="准备砸壳安装包"><a href="#准备砸壳安装包" class="headerlink" title="准备砸壳安装包"></a>准备砸壳安装包</h2><p>一般从某助手上下载的越狱版本，就是已经砸壳的，当然也可以自行通过 <a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a> 工具实现。</p><h2 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>class-dump</strong> 是一个工具，它利用了 Objective-C 语言的运行时特性，将存储在 Mach-O 文件中的头文件信息提取出来，并生成对应的 .h 文件。</p><h3 id="安装-class-dump"><a href="#安装-class-dump" class="headerlink" title="安装 class-dump"></a>安装 class-dump</h3><p>到 <a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">class-dump 官网</a> 进行下载，目前最新的版本为 3.5。</p><p>在个人目录下新建一个 <code>bin</code> 目录，并将其添加到 PATH 路径中，然后将下载后的 class-dump-3.5.dmg 里面的 class-dump 可执行文件复制到该 <code>bin</code> 目录下，赋予可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/bin</span><br><span class="line">$ vim ~/.bash_profile</span><br><span class="line"># 编辑 ~/.bash_profile 文件，并添加如下一行</span><br><span class="line">export PATH=$HOME/bin/:$PATH</span><br><span class="line"></span><br><span class="line"># 将 class-dump 拷贝到 bin 目录后执行下面命令</span><br><span class="line">$ chmod +x ~/bin/class-dump</span><br></pre></td></tr></table></figure><h3 id="使用-class-dump"><a href="#使用-class-dump" class="headerlink" title="使用 class-dump"></a>使用 class-dump</h3><p>到最后一步，以爱奇艺为例，使用 class-dump 来将微信的头文件导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ class-dump -H iQiYiPhoneVideo.app -o Payload/</span><br></pre></td></tr></table></figure><p>这样，所有的头文件就都被导出到了 <code>.Payload/</code> 目录下了。</p><p><img src="https://user-images.githubusercontent.com/10498756/39162346-a7f6fcb8-47a7-11e8-92d1-8a0e0f910036.png" alt="image"></p><h2 id="头文件分析"><a href="#头文件分析" class="headerlink" title="头文件分析"></a>头文件分析</h2><p>可以借助 FLEX 工具来查看APP 的层级和数据以及接口声明，可以快速定位我们要修改的位置</p><h3 id="安装-FLEX"><a href="#安装-FLEX" class="headerlink" title="安装 FLEX"></a>安装 FLEX</h3><p><a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a> 官方仓库，通过Cocoapods 安装依赖即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">'https://github.com/AloneMonkey/MonkeyDevSpecs.git'</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'9.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'antrees'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span></span><br><span class="line">  <span class="comment"># use_frameworks!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pods for antrees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'antreesDylib'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span></span><br><span class="line">  <span class="comment"># use_frameworks!</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 注意是安装到动态库 而不是APP</span></span><br><span class="line">  <span class="comment"># Pods for antreesDylib</span></span><br><span class="line">  pod <span class="string">'FLEX'</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>紧接着在程序启动以后，添加FLEX 的显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CHConstructor&#123;</span><br><span class="line">    NSLog(INSERT_SUCCESS_WELCOME);</span><br><span class="line">    </span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidFinishLaunchingNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">        [[FLEXManager sharedManager] showExplorer];</span><br><span class="line">#ifndef __OPTIMIZE__</span><br><span class="line">        CYListenServer(6666);</span><br><span class="line">        CycriptManager* manager = [CycriptManager sharedInstance];</span><br><span class="line">        [manager startDownloadCycript:NO];</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h3><p>我们可以通过这个FLipboard 来实现操作，具体效果如下</p><table><thead><tr><th style="text-align:center">主页</th><th style="text-align:center">菜单</th><th style="text-align:center">视图</th><th style="text-align:center">选择</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162331-94ee0fee-47a7-11e8-8a97-aec72ffba1b7.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162363-c0e9febe-47a7-11e8-8569-21ddef9f1f9c.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162378-d06b42b2-47a7-11e8-9687-a2e909151ea5.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162397-e1bfddca-47a7-11e8-8088-ac88bc83cf6b.png" alt="image"></td></tr></tbody></table><h3 id="小实战"><a href="#小实战" class="headerlink" title="小实战"></a>小实战</h3><p>比如，我们想去掉Tab 栏那个可恶的泡泡（截图部分已处理），我是非常讨厌那个功能，感觉很鸡肋，体验极差。</p><p>此时我们可以通过<code>select</code> 功能点击底部菜单栏，然后进入到视图查看层级关系，最终找到对应的实例，如下图所示</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">主页</th><th style="text-align:center">视图1</th><th style="text-align:center">视图2</th></tr></thead><tbody><tr><td style="text-align:center">处理前</td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162415-fa9508ca-47a7-11e8-9c25-55e8a1ccde35.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162445-178f1100-47a8-11e8-9d41-1b8c6bf3286a.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162508-7baa0f0a-47a8-11e8-92a6-1c71f6e0b48a.png" alt="image"></td></tr><tr><td style="text-align:center">处理后</td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162331-94ee0fee-47a7-11e8-8a97-aec72ffba1b7.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162490-531e8548-47a8-11e8-91aa-e3f0d9a3034f.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162508-7baa0f0a-47a8-11e8-92a6-1c71f6e0b48a.png" alt="image"></td></tr></tbody></table><p>代码实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CHDeclareClass(TabbarView)</span><br><span class="line"></span><br><span class="line">CHOptimizedMethod0(self, NSArray*, TabbarView, tabbarImageArray)&#123;</span><br><span class="line">    //get origin value</span><br><span class="line">    NSMutableArray* originArray = CHSuper(0, TabbarView, tabbarImageArray).mutableCopy;</span><br><span class="line">    </span><br><span class="line">    [originArray removeLastObject];</span><br><span class="line">    </span><br><span class="line">    //change the value</span><br><span class="line">    return originArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHOptimizedMethod0(self, NSArray*, TabbarView, tabbarTitleArray)&#123;</span><br><span class="line">    //get origin value</span><br><span class="line">    NSMutableArray* originArray = CHSuper(0, TabbarView, tabbarTitleArray).mutableCopy;</span><br><span class="line">    </span><br><span class="line">    [originArray removeLastObject];</span><br><span class="line">    </span><br><span class="line">    //change the value</span><br><span class="line">    return originArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHConstructor &#123;</span><br><span class="line">    CHLoadLateClass(TabbarView);</span><br><span class="line">    CHHook0(TabbarView, tabbarImageArray);</span><br><span class="line">    CHHook0(TabbarView, tabbarTitleArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://user-images.githubusercontent.com/10498756/39162834-08506cf0-47aa-11e8-9712-0c86beddf7b3.png" alt="image"></p><p>通过<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a> 大大降低了逆向开发的门槛，使得逆向变得更加有趣和更具规范性。通过逆向，可以实现很多意想不到的功能，给你不断的惊喜！</p><p>下面是本次实践的代码示例，会员和去广告相关功能暂未实现，正在寻求其他思路~</p><p><a href="https://github.com/yuhanle/SimpleiOSRE" target="_blank" rel="noopener">SimpleiOSRE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于爱奇艺会员到期，于是产生逆向APP 的想法，尚未找到解决办法。&lt;/p&gt;
&lt;h2 id=&quot;安装MonkeyDev&quot;&gt;&lt;a href=&quot;#安装MonkeyDev&quot; class=&quot;headerlink&quot; title=&quot;安装MonkeyDev&quot;&gt;&lt;/a&gt;安装MonkeyDev&lt;/h2&gt;&lt;p&gt;原有iOSOpenDev的升级，非越狱插件开发集成神器！&lt;/p&gt;
    
    </summary>
    
      <category term="iOSRE" scheme="https://blog.yuhanle.com/categories/iOSRE/"/>
    
    
      <category term="iOSRE" scheme="https://blog.yuhanle.com/tags/iOSRE/"/>
    
  </entry>
  
  <entry>
    <title>为什么我选择认识 Flutter ？</title>
    <link href="https://blog.yuhanle.com/2018/04/18/why-select-flutter/"/>
    <id>https://blog.yuhanle.com/2018/04/18/why-select-flutter/</id>
    <published>2018-04-18T01:00:00.000Z</published>
    <updated>2018-06-28T09:22:07.850Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/10498756/38983320-a1888c34-43f6-11e8-8003-a38e7230b2fd.jpeg" alt="1_uq4-35mu2_32qvpnyqyt9q"></p><h2 id="Flutter-是什么"><a href="#Flutter-是什么" class="headerlink" title="Flutter 是什么"></a>Flutter 是什么</h2><p>Flutter 移动应用程序 SDK 是为开发人员提供一种创建快捷、美观的应用程序的新方式，从而摆脱过去那种千篇一律的 app，尝试过 Flutter 的人都会真的爱上它。<br><a id="more"></a></p><p>与任何新系统一样，用户想知道 Flutter 有什么与众不同之处，“Flutter 有什么新的或者令人兴奋的东西吗？”，这是一个合理的问题，本文将从技术的角度回答 Flutter 有什么东西让人兴奋，而且给出它为什么让人兴奋的原因。</p><h3 id="Flutter-的优势"><a href="#Flutter-的优势" class="headerlink" title="Flutter 的优势"></a>Flutter 的优势</h3><ul><li>响应式视图的优点，不需要 JavaScript 的桥接器</li><li>快速，流畅，可预测 ; 代码将 AOT 编译为本机（ARM）代码</li><li>开发人员完全控制 UI 组件和布局</li><li>配有美观，可定制的 UI 组件</li><li>强大的开发者工具，惊人的热重新加载</li><li>性能更好，兼容性更好，开发起来更有乐趣</li></ul><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>目前Flutter只能在Mac和Linux(64位)上工作，使用windows的同学可能要借助虚拟机来进行学习。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><table><thead><tr><th>android</th><th>iOS</th></tr></thead><tbody><tr><td><img src="https://user-images.githubusercontent.com/10498756/38983248-7b0b07c6-43f6-11e8-9ec7-48fad12f6554.png" alt="screenshot_1524033161"></td><td><img src="https://user-images.githubusercontent.com/10498756/38983259-83079246-43f6-11e8-96fd-99752cc17a0b.png" alt="simulator screen shot - iphone x - 2018-04-18 at 14 32 39"></td></tr></tbody></table><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Flutter-SDK"><a href="#安装Flutter-SDK" class="headerlink" title="安装Flutter SDK"></a>安装Flutter SDK</h3><p>这一步其实很简单，就是将Flutter在github上的源码整个clone下来，在适当的目录执行👇命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/flutter/flutter.git</span><br><span class="line"><span class="meta">$</span> export PATH=`pwd`/flutter/bin:$PATH</span><br></pre></td></tr></table></figure><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> flutter doctor</span><br></pre></td></tr></table></figure><p>👆这个命令会告诉你你的flutter还缺少什么依赖，输出如下：</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> flutter</span><br></pre></td></tr></table></figure><p>第一次运行flutter它会自动下载一些依赖，并且进行自动编译。随后再次运行flutter就会跳过这些步骤</p><h3 id="安装-Android-studio"><a href="#安装-Android-studio" class="headerlink" title="安装 Android studio"></a>安装 Android studio</h3><p>官方指引完成即可</p><h3 id="安装Flutter"><a href="#安装Flutter" class="headerlink" title="安装Flutter"></a>安装Flutter</h3><p>偏好设置中安装插件</p><h3 id="安装Dart"><a href="#安装Dart" class="headerlink" title="安装Dart"></a>安装Dart</h3><p>偏好设置中安装插件</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create &#123;projectName&#125;</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//工程根目录下执行</span><br><span class="line">flutter packages get</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    <span class="keyword">new</span> Center(</span><br><span class="line">      child: <span class="keyword">new</span> Text(</span><br><span class="line">        <span class="string">'Hello, world!'</span>,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.dart 同样作为程序的入口文件，需要实现main 函数</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://docs.flutter.io/index.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488206&amp;idx=1&amp;sn=ed6a81769f37324b947b9a0a97fbe522&amp;source=41#wechat_redirect" target="_blank" rel="noopener">为什么说Flutter 是革命性的</a></li><li><a href="http://www.infoq.com/cn/articles/why-flutter-uses-dart" target="_blank" rel="noopener">为什么Flutter会选择 Dart ？</a></li><li><a href="https://www.zhihu.com/question/50156415" target="_blank" rel="noopener">如何评价 Google 的 Fuchsia、Android、iOS 跨平台应用框架 Flutter？</a></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>Android license status unknown.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hi everyone,</span><br><span class="line">type $flutter upgrade</span><br><span class="line">type $flutter doctor --android-licenses</span><br><span class="line">It might say some licenses are not accepted(something like that)</span><br><span class="line">you will be asked 'Do you want to review the licenses'?</span><br><span class="line">typey&lt;press enter&gt;</span><br><span class="line"></span><br><span class="line">accept all the licenses review.</span><br><span class="line"></span><br><span class="line">now check flutter again with $flutter doctor</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/10498756/38983320-a1888c34-43f6-11e8-8003-a38e7230b2fd.jpeg&quot; alt=&quot;1_uq4-35mu2_32qvpnyqyt9q&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flutter-是什么&quot;&gt;&lt;a href=&quot;#Flutter-是什么&quot; class=&quot;headerlink&quot; title=&quot;Flutter 是什么&quot;&gt;&lt;/a&gt;Flutter 是什么&lt;/h2&gt;&lt;p&gt;Flutter 移动应用程序 SDK 是为开发人员提供一种创建快捷、美观的应用程序的新方式，从而摆脱过去那种千篇一律的 app，尝试过 Flutter 的人都会真的爱上它。&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://blog.yuhanle.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://blog.yuhanle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Mac 搭建 nginx+rtmp 推流服务器</title>
    <link href="https://blog.yuhanle.com/2018/03/12/live-broadcast-rtmp/"/>
    <id>https://blog.yuhanle.com/2018/03/12/live-broadcast-rtmp/</id>
    <published>2018-03-12T01:00:00.000Z</published>
    <updated>2018-07-05T01:19:00.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直播协议选择"><a href="#直播协议选择" class="headerlink" title="直播协议选择"></a>直播协议选择</h2><p>国内常见公开的直播协议有几个：RTMP、HLS、HDL（HTTP-FLV）、RTP，我们来逐一介绍。</p><p><strong>RTMP协议：</strong></p><p>是Adobe的专利协议，现在大部分国外的CDN已不支持。在国内流行度很高。原因有几个方面：</p><a id="more"></a><p>1、开源软件和开源库的支持稳定完整。如斗鱼主播常用的OBS软件，开源的librtmp库，服务端有nginx-rtmp插件。</p><p>2、播放端安装率高。只要浏览器支持FlashPlayer就能非常简易的播放RTMP的直播，协议详解可以Google了解。相对其他协议而言，RTMP协议初次建立连接的时候握手过程过于复杂（底层基于TCP，这里说的是RTMP协议本身的交互），视不同的网络状况会带来给首开带来100ms以上的延迟。基于RTMP的直播一般内容延迟在2~5秒。</p><p><img src="http://blog.ucloud.cn/wp-content/uploads/2016/05/640-1.jpeg" alt="1"></p><p><strong>HTTP-FLV 协议：</strong></p><p>即使用HTTP协议流式的传输媒体内容。相对于RTMP，HTTP更简单和广为人知，而且不担心被Adobe的专利绑架。内容延迟同样可以做到2~5秒，打开速度更快，因为HTTP本身没有复杂的状态交互。所以从延迟角度来看，HTTP-FLV要优于RTMP。</p><p><strong>HLS 协议：</strong></p><p>即Http Live Streaming，是由苹果提出基于HTTP的流媒体传输协议。HLS有一个非常大的优点：<strong>HTML5可以直接打开播放；这个意味着可以把一个直播链接通过微信等转发分享</strong>，不需要安装任何独立的APP，有浏览器即可，所以流行度很高。<strong>社交直播APP，HLS可以说是刚需，</strong>下来我们分析下其原理 。</p><p>基于HLS的直播流URL是一个m3u8的文件，里面包含了最近若干个小视频TS（一种视频封装格式，这里就不扩展介绍）文件，如 <a href="http://www.ucloud.cn/helloworld.m3u8" target="_blank" rel="noopener">http://www.ucloud.cn/helloworld.m3u8 </a> 是一个直播留链接，其内容如下：</p><p><img src="http://blog.ucloud.cn/wp-content/uploads/2016/05/2-1.jpg" alt="2"></p><p>假设列表里面的包含5个TS文件，每个TS文件包含5秒的视频内容，那么整体的延迟就是25秒。当然可以缩短列表的长度和单个TS文件的大小来降低延迟，极致来说可以缩减列表长度为1，1秒内容的m3u8文件，但是极易受网络波动影响造成卡顿。</p><p>通过公网的验证，目前按同城网络可以做到比较好的效果是5~7秒的延迟，也是综合流畅度和内容延迟的结果。那么HTML5是否可以有更低延迟直接打开的直播流技术呢？ 我们在最后会探讨这个问题。</p><p><strong>RTP 协议：</strong></p><p>即Real-time Transport Protocol，用于Internet上针对多媒体数据流的一种传输层协议。</p><p>实际应用场景下经常需要RTCP（RTP Control Protocol）配合来使用，可以简单理解为RTCP传输交互控制的信令，RTP传输实际的媒体数据。</p><p><strong>RTP在视频监控、视频会议、IP电话上有广泛的应用</strong>，因为视频会议、IP电话的一个重要的使用体验：内容实时性强。</p><p>对比与上述3种或实际是2种协议，RTP和它们有一个重要的区别就是默认是使用UDP协议来传输数据，而RTMP和HTTP是基于TCP协议传输。为什么UDP 能做到如此实时的效果呢？关于TCP和UDP差别的分析文章一搜一大把，这里不在赘述，简单概括：</p><p><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；</strong></p><p><strong>TCP：流式，需要建立连接，复杂，可靠**</strong> ，有序。**</p><p>实时音视频流的场景不需要可靠保障，因此也不需要有重传的机制，实时的看到图像声音，网络抖动时丢了一些内容，画面模糊和花屏，完全不重要。TCP为了重传会造成延迟与不同步，如某一截内容因为重传，导致1秒以后才到，那么整个对话就延迟了1秒，随着网络抖动，延迟还会增加成2秒、3秒，如果客户端播放是不加以处理将严重影响直播的体验。</p><p><strong>总结一下：</strong>在直播协议的选择中，如果选择是RTMP或HTTP-FLV则意味着有2~5秒的内容延迟，但是就打开延迟开，HTTP-FLV 要优于RTMP。HLS则有5~7秒的内容延迟。选择RTP进行直播则可以做到1秒内的直播延迟。但就目前所了解，各大CDN厂商没有支持基于RTP直播的，所以目前国内主流还是RTMP或HTTP-FLV。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h3><p>确认是否已经安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man brow</span><br></pre></td></tr></table></figure><p>如果出现下面的代码,证明已经安装过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME  </span><br><span class="line">       brew - The missing package manager for macOS  </span><br><span class="line">  </span><br><span class="line">SYNOPSIS  </span><br><span class="line">       brew --version  </span><br><span class="line">       brew command [--verbose|-v] [options] [formula] ...</span><br></pre></td></tr></table></figure><p>安装命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>如果已经安装过，而想要卸载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure><p>如果不想重装,升级一下brow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><p>执行克隆命令，github 的项目(<a href="https://github.com/denji/homebrew-nginx" target="_blank" rel="noopener">https://github.com/denji/homebrew-nginx</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap denji/nginx</span><br></pre></td></tr></table></figure><p>注意brew tap homebrew/nginx报下面的错误，homebrew/nginx已经启用.</p><p> 报错：Error: homebrew/nginx was deprecated. This tap is now empty as all its formulae were migrated.</p><p>执行安装命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx-full --with-rtmp-module</span><br></pre></td></tr></table></figure><p>至此nginx和rtmp模块就安装好了，下面开始来配置nginx的rtmp模块</p><p>接下来看一下nginx安装在什么地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info nginx-full</span><br></pre></td></tr></table></figure><p>nginx安装所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/opt/nginx-full/bin/nginx</span><br></pre></td></tr></table></figure><p>nginx配置文件所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="运行-NGINX"><a href="#运行-NGINX" class="headerlink" title="运行 NGINX"></a>运行 NGINX</h3><p>启动nginx,执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>浏览器地址栏输入：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><p><img src="http://img.blog.csdn.net/20180309112217266" alt="img"></p><p>出现以上界面,说明安装成功.</p><p>如果终端上提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use)</span><br></pre></td></tr></table></figure><p>则表示8080端口被占用了, 查看端口PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:8080</span><br></pre></td></tr></table></figure><p>kill掉占用8080端口的PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 9663（这里替换成占用8080端口的PID）</span><br></pre></td></tr></table></figure><p>重新执行nginx…</p><h4 id="nginx常用方法"><a href="#nginx常用方法" class="headerlink" title="nginx常用方法:"></a>nginx常用方法:</h4><p>重新加载配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>重新加载日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reopen</span><br></pre></td></tr></table></figure><p>停止 nginx:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure><p>有序退出 nginx:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="配置-RTMP"><a href="#配置-RTMP" class="headerlink" title="配置 RTMP"></a>配置 RTMP</h3><p>修改nginx.conf这个配置文件，配置rtmp</p><p>复制nginx配置文件所在位置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>执行上面命令直接编辑,或者直接前往当前文件用记事本打开.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;  </span><br><span class="line"> ​  ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在http节点后面加上rtmp配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;  </span><br><span class="line">  server &#123;  </span><br><span class="line">    listen 2016;  </span><br><span class="line">    application rtmplive &#123;  </span><br><span class="line">    live on;  </span><br><span class="line">    record off;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑完成之后,执行一下重新加载配置文件命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>重启nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/opt/nginx-full/bin/nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="安装-FFmpeg-工具"><a href="#安装-FFmpeg-工具" class="headerlink" title="安装 FFmpeg 工具"></a>安装 FFmpeg 工具</h3><p>注:ffmepg转码工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure><p>安装完成之后</p><p>安装一个支持rtmp协议的视频播放器，Mac下可以用VLC</p><p>本地下载一个视频文件路径为 /Users/yuhanle/Downloads/test.mp4</p><p>执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i /Users/yuhanle/Downloads/test.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>然后打开 VLC 中 的 file – Open Network, 直接输入代码中的 url:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>然后进行播放</p><h2 id="FFmpeg-推流"><a href="#FFmpeg-推流" class="headerlink" title="FFmpeg 推流"></a>FFmpeg 推流</h2><p>1、桌面录制或者分享</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i &quot;1&quot; -vcodec libx264 -preset ultrafast -acodec libfaac -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>2、桌面+麦克风</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i &quot;1:0&quot; -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>3、桌面+麦克风，并且还要摄像头拍摄到自己</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; \-f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; \-c:v libx264 -preset ultrafast \-filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><h2 id="LFLiveKit"><a href="#LFLiveKit" class="headerlink" title="LFLiveKit"></a>LFLiveKit</h2><p><img src="https://camo.githubusercontent.com/34026396e449a30121c9fe86707423305663462f/68747470733a2f2f7261772e6769746875622e636f6d2f4c616946656e67694f532f4c464c6976654b69742f6d61737465722f73616d706c65732f49636f6e2e706e67" alt=""></p><p>LaiFeng IOS Live Kit,H264 and AAC Hard coding，support GPUImage Beauty， rtmp transmission，weak network lost frame，Dynamic switching rate</p><p>通过集成 <a href="https://github.com/LaiFengiOS/LFLiveKit" target="_blank" rel="noopener">LFLiveKit</a>，我们可以使用手机录制并推送至直播间地址，然后使用播放端直接播放视频。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.ucloud.cn/archives/699" target="_blank" rel="noopener">关于直播，所有的技术细节都在这里了（二）</a><br><a href="http://blog.ucloud.cn/?p=694" target="_blank" rel="noopener">关于直播，所有的技术细节都在这里了（一）</a><br><a href="http://blog.csdn.net/zcvbnh/article/details/79495285" target="_blank" rel="noopener">Mac 搭建 nginx+rtmp 服务器-带你出坑</a><br><a href="http://www.voidcn.com/article/p-abhhplih-p.html" target="_blank" rel="noopener">在Mac系统上搭建iOS手机推流服务器相关总结</a><br><a href="http://9dic.com/ios/2016/07/15/install-nginx+rtmp-on-mac/" target="_blank" rel="noopener">Mac搭建nginx+rtmp服务器 推流</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;直播协议选择&quot;&gt;&lt;a href=&quot;#直播协议选择&quot; class=&quot;headerlink&quot; title=&quot;直播协议选择&quot;&gt;&lt;/a&gt;直播协议选择&lt;/h2&gt;&lt;p&gt;国内常见公开的直播协议有几个：RTMP、HLS、HDL（HTTP-FLV）、RTP，我们来逐一介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTMP协议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是Adobe的专利协议，现在大部分国外的CDN已不支持。在国内流行度很高。原因有几个方面：&lt;/p&gt;
    
    </summary>
    
      <category term="live" scheme="https://blog.yuhanle.com/categories/live/"/>
    
    
      <category term="live" scheme="https://blog.yuhanle.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>如何在 GitHub Pages 上部署 vue-cli 项目</title>
    <link href="https://blog.yuhanle.com/2018/03/06/deploy-the-vue-cli-project-on-github-pages/"/>
    <id>https://blog.yuhanle.com/2018/03/06/deploy-the-vue-cli-project-on-github-pages/</id>
    <published>2018-03-06T01:55:34.000Z</published>
    <updated>2018-07-05T01:16:52.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在-GitHub-上创建与本地项目同名的远程仓库"><a href="#1-在-GitHub-上创建与本地项目同名的远程仓库" class="headerlink" title="1. 在 GitHub 上创建与本地项目同名的远程仓库"></a>1. 在 GitHub 上创建与本地项目同名的远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接在GitHub 上新建一个远程仓库</span><br></pre></td></tr></table></figure><h3 id="2-将本地项目-push-到远程"><a href="#2-将本地项目-push-到远程" class="headerlink" title="2. 将本地项目 push 到远程"></a>2. 将本地项目 push 到远程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git cmt -m &apos;create project&apos;</span><br><span class="line">$ git remote add origin git@github.com:yuhanle/resume.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="3-将-dist-下的所有文件夹-push-到-gh-pages"><a href="#3-将-dist-下的所有文件夹-push-到-gh-pages" class="headerlink" title="3. 将 dist 下的所有文件夹 push 到 gh-pages"></a>3. 将 dist 下的所有文件夹 push 到 gh-pages</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br><span class="line">$ git checkout -b gh-pages</span><br><span class="line">$ git add -f dist</span><br><span class="line">$ git commit -m &apos;create project&apos;</span><br><span class="line">$ git subtree push --prefix dist origin gh-pages</span><br></pre></td></tr></table></figure><p>这些步骤做完之后在 gh-pages 分支展示项目了，比如<br><a href="https://yuhanle.github.io/resume/" target="_blank" rel="noopener">https://yuhanle.github.io/resume/</a></p><h3 id="4-资源路径错误问题"><a href="#4-资源路径错误问题" class="headerlink" title="4. 资源路径错误问题"></a>4. 资源路径错误问题</h3><ol><li>在 <code>npm run build</code> 之前要将 <code>config/index.js</code> 里边 <code>build</code> 配置里边的 <code>assetsPublicPath: &#39;/&#39;</code> 改成 <code>assetsPublicPath: &#39;./&#39;</code></li><li>将 <code>webpack.prod.conf.js</code> 中的 <code>removeAttributeQuotes</code> 改为 <code>false</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-在-GitHub-上创建与本地项目同名的远程仓库&quot;&gt;&lt;a href=&quot;#1-在-GitHub-上创建与本地项目同名的远程仓库&quot; class=&quot;headerlink&quot; title=&quot;1. 在 GitHub 上创建与本地项目同名的远程仓库&quot;&gt;&lt;/a&gt;1. 在 GitHub 上创建与本地项目同名的远程仓库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;直接在GitHub 上新建一个远程仓库&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-将本地项目-push-到远程&quot;&gt;&lt;a href=&quot;#2-将本地项目-push-到远程&quot; class=&quot;headerlink&quot; title=&quot;2. 将本地项目 push 到远程&quot;&gt;&lt;/a&gt;2. 将本地项目 push 到远程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git cmt -m &amp;apos;create project&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote add origin git@github.com:yuhanle/resume.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push -u origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="BIGFE" scheme="https://blog.yuhanle.com/categories/BIGFE/"/>
    
    
      <category term="vue" scheme="https://blog.yuhanle.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Go 实现对 HTTP 对象的查找</title>
    <link href="https://blog.yuhanle.com/2018/02/24/seeking-around-in-an-http-object/"/>
    <id>https://blog.yuhanle.com/2018/02/24/seeking-around-in-an-http-object/</id>
    <published>2018-02-24T01:00:00.000Z</published>
    <updated>2018-07-05T01:14:33.978Z</updated>
    
    <content type="html"><![CDATA[<p>已发布：<a href="https://studygolang.com/articles/12638" target="_blank" rel="noopener">https://studygolang.com/articles/12638</a></p><h1 id="Go-实现对-HTTP-对象的查找"><a href="#Go-实现对-HTTP-对象的查找" class="headerlink" title="Go 实现对 HTTP 对象的查找"></a>Go 实现对 HTTP 对象的查找</h1><p>想象一下，在 <code>HTTP</code> 服务器上有一个巨大的 <code>ZIP</code> 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行  <code>unzip -l https://example.com/giant.zip</code> 的操作来查看压缩包的内容呢？</p><p>这并不是一个为了用 <code>Go</code> 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 <a href="https://bulkdata.uspto.gov/data/patent/officialgazette/2017/" target="_blank" rel="noopener">美国专利和商标局（USPTO）</a> 下载大量专利。或者，我认为，能够从这些 <code>tar</code> 文件中获取 <a href="https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/" target="_blank" rel="noopener">1790 年发布的一些专利图像</a> 有多酷？</p><p>去看看。那里有数百个巨大的 <code>ZIP</code> 和 <code>tarfiles</code> 值得探索！</p><a id="more"></a><p>在 <code>ZIP</code> 文件中最后的位置，有一个目录。因此在本地磁盘上，<code>“unzip -l”</code> 就像“寻求最终结果，找到 <code>TOC</code>，解析并打印它”一样简单。事实上，我们可以知道 <code>Go</code> 是如何处理的，因为在 <a href="https://godoc.org/archive/zip#NewReader" target="_blank" rel="noopener"><code>zip.NewReader</code> 函数</a> 需要传入一个文件路径。至于 <code>TAR</code> 文件，它们被设计用于磁带流式传输和内存稀少的时候，因此它们的目录在文件本身之间交错排列。</p><p>但我们不在本地，要从 <code>URL</code> 中读取内容对我们来说很有挑战。该怎么办？从哪里开始？</p><p>我们有几件事需要考虑，然后我们可以规划接下来的方向。寻找和读取 <code>HTTP</code> 文件也就是要找到和读取 <code>Range</code> 标头。那么，<code>USPTO</code> 服务器是否支持 <code>Range</code> 头呢？这很容易检查，使用 <code>curl</code> 和 <code>HTTP HEAD</code> 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -I https://bulkdata.uspto.gov/data/patent/officialgazette/2017/e-OG20170103_1434-1.zip</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 11 Dec 2017 21:10:26 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 03 Jan 2017 11:58:45 GMT</span><br><span class="line">ETag: "afb8ac8-5452f63e0a82f"</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 184257224</span><br><span class="line">X-Frame-Options: DENY</span><br><span class="line">Content-Type: application/zip</span><br></pre></td></tr></table></figure><p>请注意那里的 <code>“Accept-Ranges”</code> 标头，它表示我们可以向它发送字节范围。<code>Range</code> 头允许您像随机访问读取操作系统的一样操作 <code>HTTP</code>。（例如 <a href="https://godoc.org/io#ReaderAt" target="_blank" rel="noopener">io.ReaderAt</a> 接口）</p><p>因此理论上可以选择从 <code>Web</code> 服务器下载其中包含元数据（目录）的文件部分来决定下载哪些字节。</p><p>现在我们需要写一个处理 <code>ZIP</code> 文件格式的方法，它可以让我们使用具有 <code>Range</code> 头部的 <code>HTTP</code> 的 <code>GET</code> 请求，只读取元数据的方式，实现替换“读取下一个目录头文件”的某个部分。这就是 <code>Go</code> 的 <a href="https://golang.org/pkg/archive/zip" target="_blank" rel="noopener"><code>archive/zip</code></a> 和 <a href="https://godoc.org/archive/tar" target="_blank" rel="noopener"><code>archive/tar</code></a> 包的实现！</p><p>正如我们前面所说，<a href="https://godoc.org/archive/zip#NewReader" target="_blank" rel="noopener">zip.NewReader</a> 正在琢磨什么位置开始查找。然而，当我们看看 <code>TAR</code> 时，我们发现了一个问题。<code>tar.NewReader</code> 方法需要一个 <code>io.Reader</code>。<code>io.Reader</code> 的问题在于，它不会让我们随机访问资源，就像<code>io.ReaderAt</code> 一样。它是这样实现的，因为它使 <code>tar</code> 包更具适应性。特别是，您可以将 <code>Go tar</code> 包直接挂接到 <code>compress/gzip</code> 包并读取 <code>tar.gz</code> 文件 - 只要您按顺序读取它们，而不是像我们希望的那样跳过。</p><p>那么该怎么办？使用源码。环顾四周，找找<a href="https://github.com/golang/go/blob/c007ce824d9a4fccb148f9204e04c23ed2984b71/src/archive/tar/reader.go#L88" target="_blank" rel="noopener">下一个方法</a>。这就是我们期望它能够找到下一个元数据的地方。在几行代码内，对于 <a href="https://github.com/golang/go/blob/c007ce824d9a4fccb148f9204e04c23ed2984b71/src/archive/tar/reader.go#L407" target="_blank" rel="noopener"><code>skipUnread</code></a> 函数， 我们发现一个有趣的调用。在那里，我们发现一些非常有趣的东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skipUnread skips any unread bytes in the existing file entry, as well as any alignment padding.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *Reader)</span> <span class="title">skipUnread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nr := tr.numBytes() + tr.pad <span class="comment">// number of bytes to skip</span></span><br><span class="line">  tr.curr, tr.pad = <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> sr, ok := tr.r.(io.Seeker); ok &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := sr.Seek(nr, os.SEEK_CUR); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _, tr.err = io.CopyN(ioutil.Discard, tr.r, nr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: This is from Go 1.4, which had a simpler skipUnread than go 1.9 does.</span></span><br></pre></td></tr></table></figure><p>这里表示：”如果 <code>io.Reader</code> 实际上也能够搜索，那么我们不是直接读取和丢弃，而是直接找到正确的地方。“找到了！我们只需要将 <code>tar</code> 文件传给 <code>io.Reader</code>。<code>NewReader</code> 也满足 <a href="https://golang.org/pkg/io/#Seeker" target="_blank" rel="noopener"><code>io.Seeker</code></a>的功能（因此，它是一个<a href="https://golang.org/pkg/io/#ReadSeeker" target="_blank" rel="noopener"><code>io.ReadSeeker</code></a>）。</p><p>所以，现在请查看包 <a href="https://godoc.org/github.com/jeffallen/seekinghttp" target="_blank" rel="noopener"><code>github.com/jeffallen/seekinghttp</code></a>，就像它的名字所暗示的那样，它是一个用于在 <code>HTTP</code> 对象（<a href="https://github.com/jeffallen/seekinghttp" target="_blank" rel="noopener"><code>Github</code> 上的源代码</a> 中查找的软件包。</p><p>这个软件包不仅<a href="https://github.com/jeffallen/seekinghttp/blob/master/seekinghttp.go#L26" target="_blank" rel="noopener">实现</a>了 <code>io.ReadSeeker</code>，还实现了 <code>io.ReaderAt</code>。</p><p>为什么？因为，正如我上面提到的，读取 <code>ZIP</code> 文件需要一个 <code>io.ReaderAt</code>。它还需要传递给它的文件的长度，以便它可以查看目录文件的末尾。<code>HTTP HEAD</code> 方法可以很好地获取 <code>HTTP</code> 对象的 <code>Content-Length</code>，而不需要下载整个文件。</p><p>用于远程获取 <code>tar</code> 和 <code>zip</code> 文件目录的命令行工具位于 <code>remote-archive-ls</code> 中。打开 <code>“-debug”</code> 选项用来查看日志。<strong>将 <code>Go</code> 的标准库作为 <code>TAR</code> 或 <code>ZIP</code> 阅读器“回调”到我们的代码中，并在这里请求几个字节，这里有几个字节是很有趣的。</strong> </p><p>在我第一次运行这个程序后不久，我发现了一个严重的缺陷。这是一个示例运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./remote-archive-ls -debug 'https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/grant_pdf_17900731_18641101.tar'</span><br><span class="line">2017/12/12 00:07:38 got read len 512</span><br><span class="line">2017/12/12 00:07:38 ReadAt len 512 off 0</span><br><span class="line">2017/12/12 00:07:38 Start HTTP GET with Range: bytes=0-511</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 512</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=512-1023</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 1024</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=1024-1535</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 1536</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=1536-2047</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 2048</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=2048-2559</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/us-patent-image.xml</span><br><span class="line">2017/12/12 00:07:39 got seek 0 1</span><br><span class="line">2017/12/12 00:07:39 got seek 982 1</span><br><span class="line">2017/12/12 00:07:39 got read len 42</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 42 off 3542</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=3542-3583</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 3584</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=3584-4095</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/00000001.pdf</span><br><span class="line">2017/12/12 00:07:39 got seek 0 1</span><br><span class="line">2017/12/12 00:07:39 got seek 320840 1</span><br><span class="line">2017/12/12 00:07:39 got read len 184</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 184 off 324936</span><br><span class="line">...etc...</span><br></pre></td></tr></table></figure><p>你能看到问题吗？这是很多 <code>HTTP</code> 事务！ <code>TAR reader</code> 正在一次一点点地完成 <code>TAR</code> 流，发出一小串 <code>bit</code>。所有这些短的 <code>HTTP</code> 事务在服务器上都很难实现，并且对于吞吐量来说很糟糕，因为每个 <code>HTTP</code> 事务都需要多次往返服务器。</p><p>当然，解决方案是缓存。<strong>读取TAR读取器要求的前 512 个字节，而不是读取其中的 10 倍，以便接下来的几个读取将直接从缓存中获取。</strong>如果读取超出了缓存的范围，我们假设其他读取也将进入该区域，并删除整个当前缓存，以便用当前偏移量的 10 倍填充它。</p><p><code>TAR</code> 阅读器发送<strong>大量小读数</strong>的事实指出了有关缓冲的一些非常重要的事情。将 <a href="https://godoc.org/os#Open" target="_blank" rel="noopener"><code>os.Open</code></a> 的结果直接发送给 <code>tar</code>。<code>NewReader</code> 不是很聪明，尤其是如果你打算跳过文件寻找元数据。尽管 <code>* os.File</code> 实现了 <code>io.ReadSeeker</code>，我们现在知道 <code>TAR</code> 将会向内核发出大量的<strong>小系统调用</strong>。该解决方案与上面的解决方案非常相似，可能是使用 <a href="https://godoc.org/bufio" target="_blank" rel="noopener"><code>bufio</code></a> 包来缓冲 <code>* os.File</code>，以便 <code>TAR</code> 发出的小数据将从 <code>RAM</code> 中取出，而不是转到操作系统。但请注意：它真的是解决方案吗？<code>bufio.Reader</code> 是否真的实现了 <code>io</code>？<code>ReadSeeker</code> 和 <code>io.ReadAt</code> 就像我们需要的一样？ <strong>（破坏者：它没有;也许你们有读者想告诉我们如何使用下一个的替代品 <code>bufio</code> 加速 <code>Go</code> 的 <code>tar</code>？</strong></p><p>我希望你喜欢通过标准库和 <code>HTTP</code>，看看如何与标准库一起工作，以帮助它实现更多的功能，以便它可以帮助你完成你的工作这个小小的旅程。当你实现 <code>io.Reader</code> 和朋友时，你有机会走到你所调用的库的幕后，并从他们的作者从未期望的地方给他们提供数据！</p><hr><p>via：<a href="https://blog.gopheracademy.com/advent-2017/seekable-http/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2017/seekable-http/</a></p><p>作者：<a href="https://github.com/jeffallen" target="_blank" rel="noopener">Jeff R. Allen</a><br>译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a><br>校对：<a href="https://github.com/Unknwon" target="_blank" rel="noopener">Unknwon</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已发布：&lt;a href=&quot;https://studygolang.com/articles/12638&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://studygolang.com/articles/12638&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Go-实现对-HTTP-对象的查找&quot;&gt;&lt;a href=&quot;#Go-实现对-HTTP-对象的查找&quot; class=&quot;headerlink&quot; title=&quot;Go 实现对 HTTP 对象的查找&quot;&gt;&lt;/a&gt;Go 实现对 HTTP 对象的查找&lt;/h1&gt;&lt;p&gt;想象一下，在 &lt;code&gt;HTTP&lt;/code&gt; 服务器上有一个巨大的 &lt;code&gt;ZIP&lt;/code&gt; 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行  &lt;code&gt;unzip -l https://example.com/giant.zip&lt;/code&gt; 的操作来查看压缩包的内容呢？&lt;/p&gt;
&lt;p&gt;这并不是一个为了用 &lt;code&gt;Go&lt;/code&gt; 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 &lt;a href=&quot;https://bulkdata.uspto.gov/data/patent/officialgazette/2017/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美国专利和商标局（USPTO）&lt;/a&gt; 下载大量专利。或者，我认为，能够从这些 &lt;code&gt;tar&lt;/code&gt; 文件中获取 &lt;a href=&quot;https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1790 年发布的一些专利图像&lt;/a&gt; 有多酷？&lt;/p&gt;
&lt;p&gt;去看看。那里有数百个巨大的 &lt;code&gt;ZIP&lt;/code&gt; 和 &lt;code&gt;tarfiles&lt;/code&gt; 值得探索！&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>iOS 真机调试如何安装 WebDriverAgent</title>
    <link href="https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/"/>
    <id>https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/</id>
    <published>2018-01-03T10:30:47.000Z</published>
    <updated>2018-07-05T01:18:16.306Z</updated>
    
    <content type="html"><![CDATA[<p>近期，微信<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">跳一跳外挂</a>火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/wda.png" alt="WDA 工作原理"> </p><p>其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 <a href="https://testerhome.com/topics/7220" target="_blank" rel="noopener">WebDriverAgent · TesterHome</a>，下面就按照这篇教程，各个击破真机调试WDA 的问题：</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/WebDriverAgent.git</span><br></pre></td></tr></table></figure><p>切换到WDA 根目录，运行初始化脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd WebDriverAgent</span><br><span class="line">./Scripts/bootstrap.sh</span><br></pre></td></tr></table></figure><p>以上脚本是安装依赖库，同时使用npm 打包响应的js 文件。感兴趣的同学可以浏览脚本文件，同级目录下还有一个<code>build.sh</code>，也可以直接执行该脚本来编译安装WDA。当然，初次接触，希望一步步操作的话会好一些。</p><p>如果中途出现错误，需要先解决，否则接下来的操作都无法进行。</p><h1 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h1><p>接下来，通过Xcode 打开<code>WebDriverAgent.xcodeproj</code> 这个文件。</p><p>可以先尝试编译一下，方便定位目前存在的问题，使用组合键或者通过鼠标操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command + b</span><br></pre></td></tr></table></figure><p>这个时候，肯定会有提示配置证书的问题，真机调试证书是必须设置的。可以设置个人开发者免费证书，或者其他付费证书。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/WX20180103-141257.png" alt=""></p><p>然后选择<code>WebDriverAgentRunner</code> 这个Target 和 真机设备，执行测试。组合键<code>command+u</code>，或从菜单栏Product 中通过鼠标操作</p><blockquote><p>一切正常的话，手机上会出现一个无图标的WebDriverAgent应用，启动之后，马上又返回到桌面。这是很正常的不要奇怪。</p></blockquote><p>应用教程中的原话，上述现象正常，但是也有可能会在控制台报错，从而无法打印出ip 地址。</p><p>当把所有的流程重新捋一遍，你会发现，根本发现不了哪一步做错了，我遇到的情况就是，一直停留在控制台的那里，不会出现奇迹。经过一番搜索，发现<a href="https://testerhome.com/topics/9666" target="_blank" rel="noopener">有个帖子</a>里的警告提示，我决定放手一搏！</p><blockquote><p>你们以为这样就能运行吗？</p><p>并不是！<br>最关键一步来了：</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>重要的话要说三遍！</p></blockquote><p>反正是在保证数据线连接的情况下，重启一下手机，然后重新build 就成功看到ip 地址！而且在以后操作中，这种情况还会复现，所以重启手机吧，不用浪费无辜的时间研究~</p><p>通过上面给出的IP和端口，加上<code>/status</code>合成一个url地址。例如<code>http://10.0.0.1:8100/status</code>，然后浏览器打开。如果出现一串JSON输出，说明WDA安装成功了。</p><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><p>有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上。关于这个问题，我是通过端口转发才看到效果，所以你也应该会遇到同样的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install imobiledevice</span><br><span class="line">$ iproxy 8100 8100 [4c47766e78f9d84e1da55b07d69f2747e9fb4f71]</span><br></pre></td></tr></table></figure><p>使用iproxy –help 可以查到更具体的用法。 这时通过访问<code>http://localhost:8100/status</code> 确认WDA是否运行成功。</p><p>而inspector的地址是<code>http://localhost:8100/inspector</code>， inspector是用来查看UI的图层，方便写测试脚本用。</p><blockquote><p>注：端口转发后，域名不再是IP 地址，而是你的本机IP或者使用<code>localhost</code>+ 端口号</p></blockquote><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>完成上述操作以后，可以随意开启应用内的某个应用，就能看到如下效果。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/WX20180103-143535.png" alt=""></p><p>这里结合 <a href="https://testerhome.com/topics/7840" target="_blank" rel="noopener">Appium Desktop</a> 一起食用，效果更佳~</p><p>Good luck!!!</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>相信你会对这个感兴趣，通过WDA 做自动化测试，恩！</p><p>接下来演示一下怎么用ATX打开iPhone自带的计时器，开始然后退出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/local/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> atx</span><br><span class="line"></span><br><span class="line">d = atx.connect(<span class="string">"http://localhost:8100"</span>)</span><br><span class="line">d.start_app(<span class="string">"com.apple.mobiletimer"</span>)</span><br><span class="line">d(text=<span class="string">u'计时器'</span>).click()</span><br><span class="line">d(text=<span class="string">u'开始计时'</span>).click()</span><br><span class="line">d(text=<span class="string">u'取消'</span>).click()</span><br><span class="line">d.stop_app()</span><br></pre></td></tr></table></figure><p>执行以上代码即可体验</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>最后墙裂推荐基于Python自动化框架地址 <a href="https://github.com/NetEaseGame/ATX" target="_blank" rel="noopener">https://github.com/NetEaseGame/ATX</a></p><p>Xcode问题多多，愿WDA与你同在。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://testerhome.com/topics/7220" target="_blank" rel="noopener">ATX 文档 - iOS 真机如何安装 WebDriverAgent</a></p><p><a href="https://testerhome.com/topics/8820#reply47" target="_blank" rel="noopener">Macaca App Inspector 2.0 发布</a></p><p><a href="https://testerhome.com/topics/7840" target="_blank" rel="noopener">Appium Desktop 简单介绍 —— xcodebuild failed with code 65 解决</a></p><p><a href="https://testerhome.com/topics/9666" target="_blank" rel="noopener">WebDriverAgent 天坑记</a></p><p><a href="https://testerhome.com/topics/7324" target="_blank" rel="noopener">启动 WebDriverAgent 后再启动 appium，运行脚本一直卡在 Waiting for WebDriverAgent to start on device</a></p><p><a href="https://testerhome.com/topics/6331" target="_blank" rel="noopener">ATX 支持 iOS10 手机测试 方法说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，微信&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跳一跳外挂&lt;/a&gt;火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/wda.png&quot; alt=&quot;WDA 工作原理&quot;&gt; &lt;/p&gt;
&lt;p&gt;其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 &lt;a href=&quot;https://testerhome.com/topics/7220&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebDriverAgent · TesterHome&lt;/a&gt;，下面就按照这篇教程，各个击破真机调试WDA 的问题：&lt;/p&gt;
&lt;h1 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h1&gt;&lt;p&gt;首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地&lt;/p&gt;
    
    </summary>
    
      <category term="UI Auto Test" scheme="https://blog.yuhanle.com/categories/UI-Auto-Test/"/>
    
    
      <category term="WDA" scheme="https://blog.yuhanle.com/tags/WDA/"/>
    
      <category term="UI Test" scheme="https://blog.yuhanle.com/tags/UI-Test/"/>
    
  </entry>
  
  <entry>
    <title>Electron 入门指南</title>
    <link href="https://blog.yuhanle.com/2017/12/16/electron-abc/"/>
    <id>https://blog.yuhanle.com/2017/12/16/electron-abc/</id>
    <published>2017-12-16T06:48:05.000Z</published>
    <updated>2018-07-05T01:17:21.429Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/electron.jpeg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>目前，使用前端技术开发桌面应用越来越成熟，所以前端同学也可以参与桌面应用的开发。目前类似的工具有electron，NW.js等。刚好最近在学习Vue，简单做了些入门页面，B/S 的方式虽然能够跨平台使用，但是对于不折腾会死的周末来说，尝试着踩坑才是最充实的。</p><a id="more"></a><p>这里我们简单介绍下 <a href="https://electron.org.cn/" target="_blank" rel="noopener">Electron</a>的使用。</p><p>Electron 中文网上对于他的功能描述的很直观，也很吸引众多开发者的探索。</p><center><br><h4>比你想象的更容易</h4><br></center><blockquote><p>如果您能够搭建一个网站，那么您就可以搭建一个桌面应用。 Electron是这样一个框架，它可以帮助您使用JavaScript/Html/Css等网站相关技术，非常快速而容易地搭建一个原生应用。这样，您就可以聚焦于您的业务系统本身了，然后把剩下的那些难题交给我们好了。</p></blockquote><h2 id="如何开发"><a href="#如何开发" class="headerlink" title="如何开发"></a>如何开发</h2><p>简单来说，Electron 是基于Node.js 和Chromium 做的一个工具，通过将前端页面加壳的方式，实现桌面开发，并且支持跨平台。</p><p>他是一个工具，除了官方文档上的基础配置，开发相关的只是主要是是前端业务相关，对于工具的使用看文档，论坛交流和更多Demo 的学习足够。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一个最简单的Electron 项目包含三个文件，package.json, index.html, main,js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- package.json Node.js 项目的配置文件</span><br><span class="line">|-- index.html 桌面应用的业务</span><br><span class="line">|-- main.js 应用的启动入口文件</span><br></pre></td></tr></table></figure><p>其中，核心的文件是index.html 和main.js。</p><p>回到最近写的小工具，目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-- voicepkgtool </span><br><span class="line">||-- config webpack配置文件</span><br><span class="line">|||-- dev.env.js </span><br><span class="line">|||-- index.js</span><br><span class="line">||-- dist 发布</span><br><span class="line">||-- node_modules</span><br><span class="line">||-- samples Node.js Server</span><br><span class="line">||-- src 源码目录</span><br><span class="line">||-- main.js Electron 应用入口</span><br><span class="line">||-- package.json配置文件</span><br></pre></td></tr></table></figure><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>推荐查阅官网的教程<a href="https://electron.org.cn/vue/index.html" target="_blank" rel="noopener">Electron-vue</a></p><p>我们这个简单的Web 项目部署以后，希望可以通过Electron 打包跨屏体运行，所以只需要简单几步配置就搞定！</p><h3 id="安装Electron"><a href="#安装Electron" class="headerlink" title="安装Electron"></a>安装Electron</h3><p>在使用前，需要先安装相关模块，然后在项目中引入使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 核心模块</span><br><span class="line">npm install electron -s</span><br><span class="line">// 打包模块 | 也可以使用electron-builder</span><br><span class="line">npm install electron-packager -s</span><br></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>在执行Electron 相关命令并启动应用时，需要一个入口文件，就是上面提到的main.js，文件包含整个应用的生命周期回调，同时也用来存放应用相关配置信息。</p><p>以下便是我们为目前这个小项目编辑的main.js 文件，API 可以参考官方教程。</p><p>注释也可以清楚的了解每一行的含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;)</span><br><span class="line">// Module to control application life.</span><br><span class="line">const app = electron.app</span><br><span class="line">// Module to create native browser window.</span><br><span class="line">const BrowserWindow = electron.BrowserWindow</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line"></span><br><span class="line">// Keep a global reference of the window object, if you don&apos;t, the window will</span><br><span class="line">// be closed automatically when the JavaScript object is garbage collected.</span><br><span class="line">let mainWindow</span><br><span class="line"></span><br><span class="line">function createWindow () &#123;</span><br><span class="line">  // Create the browser window.</span><br><span class="line">  mainWindow = new BrowserWindow(&#123;width: 800, height: 600&#125;)</span><br><span class="line"></span><br><span class="line">  // and load the index.html of the app.</span><br><span class="line">  mainWindow.loadURL(url.format(&#123;</span><br><span class="line">    pathname: path.join(__dirname, &apos;dist/index.html&apos;),</span><br><span class="line">    protocol: &apos;file:&apos;,</span><br><span class="line">    slashes: true</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  // Open the DevTools.</span><br><span class="line">  // mainWindow.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">  // Emitted when the window is closed.</span><br><span class="line">  mainWindow.on(&apos;closed&apos;, function () &#123;</span><br><span class="line">    // Dereference the window object, usually you would store windows</span><br><span class="line">    // in an array if your app supports multi windows, this is the time</span><br><span class="line">    // when you should delete the corresponding element.</span><br><span class="line">    mainWindow = null</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This method will be called when Electron has finished</span><br><span class="line">// initialization and is ready to create browser windows.</span><br><span class="line">// Some APIs can only be used after this event occurs.</span><br><span class="line">app.on(&apos;ready&apos;, createWindow)</span><br><span class="line"></span><br><span class="line">// Quit when all windows are closed.</span><br><span class="line">app.on(&apos;window-all-closed&apos;, function () &#123;</span><br><span class="line">  // On OS X it is common for applications and their menu bar</span><br><span class="line">  // to stay active until the user quits explicitly with Cmd + Q</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(&apos;activate&apos;, function () &#123;</span><br><span class="line">  // On OS X it&apos;s common to re-create a window in the app when the</span><br><span class="line">  // dock icon is clicked and there are no other windows open.</span><br><span class="line">  if (mainWindow === null) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// In this file you can include the rest of your app&apos;s specific main process</span><br><span class="line">// code. You can also put them in separate files and require them here.</span><br></pre></td></tr></table></figure><h3 id="编辑脚本"><a href="#编辑脚本" class="headerlink" title="编辑脚本"></a>编辑脚本</h3><p>入口文件的路径，我们需要通过键值对的方式，新增在package.json 文件里，同时可以在Scripts 里添加启动、编译以及打包的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;voicepkgtool&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A Vue.js project&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;shibo.wen@ti-link.com.cn&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;,// 入口文件路径 不可缺少 否则执行时会报错</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;electron .&quot;,// 启动应用</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --env.dev&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack -p --progress --hide-modules&quot;,</span><br><span class="line">    &quot;build:all&quot;: &quot;electron-packager . voicepkgtool --platform=all --arch=all -version=0.0.1 --icon=app.ico --out=Staging --version-string.ProductName=Telar Converter --version-string.ProductVersion=0.5.0&quot;,</span><br><span class="line">    &quot;package&quot;: &quot;electron-packager ./ voicepkgtool --all --out ./ --version 0.0.1 --overwrite&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;axios&quot;: &quot;^0.17.1&quot;,</span><br><span class="line">    &quot;checksum&quot;: &quot;^0.1.1&quot;,</span><br><span class="line">    &quot;electron&quot;: &quot;^1.7.9&quot;,</span><br><span class="line">    &quot;electron-packager&quot;: &quot;^10.1.0&quot;,</span><br><span class="line">    &quot;element-ui&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;file-saver&quot;: &quot;^1.3.3&quot;,</span><br><span class="line">    &quot;jszip&quot;: &quot;^3.1.5&quot;,</span><br><span class="line">    &quot;qs&quot;: &quot;^6.5.1&quot;,</span><br><span class="line">    &quot;querystring&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.5.2&quot;,</span><br><span class="line">    &quot;vue-simple-uploader&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;webpack-merge&quot;: &quot;^4.1.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;=6&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;autoprefixer&quot;: &quot;^6.6.0&quot;,</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^6.4.0&quot;,</span><br><span class="line">    &quot;babel-preset-vue-app&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^0.27.0&quot;,</span><br><span class="line">    &quot;file-loader&quot;: &quot;^0.10.1&quot;,</span><br><span class="line">    &quot;html-webpack-plugin&quot;: &quot;^2.24.1&quot;,</span><br><span class="line">    &quot;postcss-loader&quot;: &quot;^1.3.3&quot;,</span><br><span class="line">    &quot;rimraf&quot;: &quot;^2.5.4&quot;,</span><br><span class="line">    &quot;style-loader&quot;: &quot;^0.13.2&quot;,</span><br><span class="line">    &quot;url-loader&quot;: &quot;^0.5.8&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^2.4.1&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^2.4.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>一个跨屏台的应用就展现在桌面上。</p><h3 id="构建打包"><a href="#构建打包" class="headerlink" title="构建打包"></a>构建打包</h3><p>进阶教程参考<a href="https://electron.org.cn/build.html" target="_blank" rel="noopener">Electron构建打包</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">electron-packager . --overwrite --platform=darwin --arch=x64 --out=out --icon=assets/app-icon/mac/app.icns --osx-sign.identity=&apos;Developer ID Application: GitHub&apos; --extend-info=assets/mac/info.plist</span><br><span class="line"></span><br><span class="line">electron-packager . --overwrite --platform=win32 --arch=ia32 --out=out --icon=assets/app-icon/win/app.ico</span><br><span class="line"></span><br><span class="line">electron-packager . --overwrite --platform=linux --arch=x64 --out=out</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="Electron-不支持XP-系统"><a href="#Electron-不支持XP-系统" class="headerlink" title="Electron 不支持XP 系统"></a>Electron 不支持XP 系统</h3><p>如果有考虑在XP 系统上使用，不用考虑了</p><p>参考：<a href="https://js3.org/question/43" target="_blank" rel="noopener">https://js3.org/question/43</a></p><h3 id="安装包大小"><a href="#安装包大小" class="headerlink" title="安装包大小"></a>安装包大小</h3><p>一般情况下，通过packager或者builder打包完毕后，exe、dll、asr等文件总和的大小为100M左右。而通过builder制作的nsis安装包，一般为32M左右。通过innosetup生成的安装包，一般为31M左右。总体来说，体积较大。但是您通过一系列的手段可以有效的减少它的体积，到一个可接受的范围。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><p>浏览器窗口的开发工具仅能调试渲染器的进程脚本（比如 web 页面）。为了提供一个可以调试主进程 的方法，Electron 提供了 –debug 和 –debug-brk 开关。</p><p>使用如下的命令行开关来调试 Electron 的主进程：</p><p>–debug=[port]</p><p>当这个开关用于 Electron 时，它将会监听 V8 引擎中有关 port 的调试器协议信息。 默认的 port 是 5858。</p><p>–debug-brk=[port]</p><p>就像 –debug 一样，但是会在第一行暂停脚本运行。</p><h2 id="Electron-常见问题"><a href="#Electron-常见问题" class="headerlink" title="Electron 常见问题"></a>Electron 常见问题</h2><p>如何解决下载源的时候timeout问题<br>对于国内的网络用户，请切换npm源为淘宝的cnpm源，切换方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br><span class="line">npm config set electron_mirror http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><p>另外，对于文件构建时的timeout问题，需要您下载对应的文件到本地缓存文件夹。具体的下载切换办法，可以点击这里查看：<a href="https://js3.org/article/7" target="_blank" rel="noopener">https://js3.org/article/7</a></p><p>更多问题参考：<a href="https://electron.org.cn/doc/faq.html" target="_blank" rel="noopener">Electron 常见问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/electron.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;目前，使用前端技术开发桌面应用越来越成熟，所以前端同学也可以参与桌面应用的开发。目前类似的工具有electron，NW.js等。刚好最近在学习Vue，简单做了些入门页面，B/S 的方式虽然能够跨平台使用，但是对于不折腾会死的周末来说，尝试着踩坑才是最充实的。&lt;/p&gt;
    
    </summary>
    
      <category term="BIGFE" scheme="https://blog.yuhanle.com/categories/BIGFE/"/>
    
    
      <category term="electron" scheme="https://blog.yuhanle.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>Xcode9.2 编译在iOS8.1 系统上图片显示异常</title>
    <link href="https://blog.yuhanle.com/2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/"/>
    <id>https://blog.yuhanle.com/2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/</id>
    <published>2017-12-09T01:52:47.000Z</published>
    <updated>2018-07-05T01:21:37.978Z</updated>
    
    <content type="html"><![CDATA[<p>趁着下载Xcode 9.1 的空隙，在周末的早晨记录一下这个坑，希望能解决相同遭遇同行的困惑。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/0342bcd3280e6eaafcd3e99e0f4bc362.jpg" alt=""></p><h2 id="始因"><a href="#始因" class="headerlink" title="始因"></a>始因</h2><p>昨天刚发布了适配iPhone X 的最新版本，之所以使用Xcode 9.2打包，是因为早期的适配，通过Xcode 8.2打包，安装到iPhone X上显示的效果是没有适配。</p><a id="more"></a><p>这个也是无法解释的，我们开发使用的Xcode9，在适配过程中没有遇到该问题，总是升级就对了。</p><p>刚好最近苹果爹发布了Xcode 9.2，就索性升级到最新版本。</p><p>持续化集成就是方便，代码提交以后，喝杯咖啡的工具，就上传成功，等待审核。</p><p>也就是在昨天中午，收到审核通过的提醒，很奇怪，这个时候应该是他们休息的时间。</p><p>然后，就非常肯定，因为在适配的过程中，特意找了两个iPhone X的用户帮助测试体验。随着审核通过，就很快发布出去。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>大概下午3点钟，距离发布版本只过了3 个小时左右。收到客服妹子的一个大写的问号。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/WX20171209-100043@2x.png" alt=""></p><p>这一瞬间，整个人都是懵的，慌忙让用户重启APP，重启系统，升级系统，最后被用户拒绝掉。</p><p>既然是必现的问题，不能将问题推到升级系统上，该解决还是要尽快解决的。</p><p>接着就开始着手另外一个项目，晚上回到家开始思考，问题存在的版本近期究竟改了什么内容。同时也下载了iOS8.1 的模拟器，使用最新版本的Xcode 运行看了下效果，确实如此是复现的。</p><p>所以，要马上改变态度，和客服同志搞好关系，早点认错才能走得更远。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/WX20171209-101223@2x.png" alt=""></p><h2 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h2><h3 id="1-删掉LaunchScreen-sb-文件"><a href="#1-删掉LaunchScreen-sb-文件" class="headerlink" title="1. 删掉LaunchScreen.sb 文件"></a>1. 删掉LaunchScreen.sb 文件</h3><p>为了适配iPhone X 的启动图，同时在启动后使用启动图做了简单的效果，决定使用LaunchImage 的方式设置启动图。</p><p>在更改代码后，尝试了一下修改结果，依然是非正常的。</p><p>效果如下，丝毫没有改变：</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator Screen Shot - iPhone 6 - 2017-12-09 at 10.17.01.png" alt=""></p><h3 id="2-Xcode-版本升级"><a href="#2-Xcode-版本升级" class="headerlink" title="2. Xcode 版本升级"></a>2. Xcode 版本升级</h3><p>这次的改动比较小，所以在排除上述的改动后，直接想到的就是可能就是这个问题，但是很少会怀疑苹果爹会挖这么大的坑，让开发者跳进去。</p><p>不管如何，降级版本试试就知道是不是这个原因。</p><table><thead><tr><th>Xcode9.2</th><th>Xcode9.1</th></tr></thead><tbody><tr><td><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator Screen Shot - iPhone 6 - 2017-12-09 at 10.17.01.png" alt="修改前"></td><td><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator%20Screen%20Shot%20-%20iPhone%206%20-%202017-12-09%20at%2010.51.55.png" alt="修改后"></td></tr></tbody></table><p>通过上述对比，确定问题就处在Xcode 版本上。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-等苹果爹更新"><a href="#1-等苹果爹更新" class="headerlink" title="1. 等苹果爹更新"></a>1. 等苹果爹更新</h3><p>如果苹果爹一直没注意到这个问题，或者没有人提，谁知道还要等多久？<br>关于此问题，我已经向苹果爹提交了bug，期待后续修复：</p><p><a href="https://bugreport.apple.com/web/?problemID=35948702" target="_blank" rel="noopener">ProblemID=35948702</a></p><h3 id="2-先降级Xcode"><a href="#2-先降级Xcode" class="headerlink" title="2. 先降级Xcode"></a>2. 先降级Xcode</h3><p>确切的说，这是目前最快捷的一个方式，保证没有问题。</p><h3 id="3-改变图片资源存储"><a href="#3-改变图片资源存储" class="headerlink" title="3. 改变图片资源存储"></a>3. 改变图片资源存储</h3><p>图片不要放在asset里面，方法放在bundle里面就没问题。不知道是Xcode9.2bug还是没设置相关属性。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cocoachina.com/bbs/read.php?tid=1729079" target="_blank" rel="noopener">Xcode9.2 运行iOS8.1图片异常</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;趁着下载Xcode 9.1 的空隙，在周末的早晨记录一下这个坑，希望能解决相同遭遇同行的困惑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yuhanle/blogbag/raw/master/uploads/images/0342bcd3280e6eaafcd3e99e0f4bc362.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;始因&quot;&gt;&lt;a href=&quot;#始因&quot; class=&quot;headerlink&quot; title=&quot;始因&quot;&gt;&lt;/a&gt;始因&lt;/h2&gt;&lt;p&gt;昨天刚发布了适配iPhone X 的最新版本，之所以使用Xcode 9.2打包，是因为早期的适配，通过Xcode 8.2打包，安装到iPhone X上显示的效果是没有适配。&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="https://blog.yuhanle.com/categories/tools/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>升级 macOS High Sierra 后与 Cocoapods 的兼容问题</title>
    <link href="https://blog.yuhanle.com/2017/12/06/macos-high-sierra-with-cocoapods/"/>
    <id>https://blog.yuhanle.com/2017/12/06/macos-high-sierra-with-cocoapods/</id>
    <published>2017-12-06T03:42:36.000Z</published>
    <updated>2018-07-05T01:19:13.989Z</updated>
    
    <content type="html"><![CDATA[<p>当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？</p><p>最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚</p><p>不过在使用 Cocoapods 的时候还是遇到了问题：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">06-Dec-2017 09:28:38/Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-1550561307052749322.sh: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory</span><br><span class="line">06-Dec-2017 11:24:58env: ruby_executable_hooks: No such file or directory</span><br><span class="line">06-Dec-2017 11:30:11/Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-5355633338674781643.sh: line 7: pod: command not found</span><br><span class="line">06-Dec-2017 11:31:27env: ruby_executable_hooks: No such file or directory</span><br></pre></td></tr></table></figure><p>看起来是 Cocoapods 依赖的 Ruby 版本问题，Google 一下，发现已经有人在 Cocoapods 的 repo 下提了这个 <a href="https://github.com/CocoaPods/CocoaPods/issues/6778" target="_blank" rel="noopener">issue</a>，下面也有开发者给出了解决方案：重新安装 Cocoapods. </p><p>Pod 命令需要用到 2.0 版本的 Ruby 解释器 <code>/System/Library/Frameworks/Ruby.framework/Versions/2.0</code>，而 <code>macOS High Sierra</code> 将系统的 Ruby 解释器升级到了 <code>2.3</code> <code>/System/Library/Frameworks/Ruby.framework/Versions/2.3</code>，因此执行 pod 命令的时候由于找不到 Ruby 解释器而报错。</p><p>于是按照提示重装 Cocoapods：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>安装完成后继续执行 pod install，又报了同样的错误。我决定继续重装一次 Cocoapods，不过这次加上 –verbose 参数，看看安装过程中做了哪些操作。log 太长我就不贴了，不过注意到最后输出的 pod 命令位置似乎跟上面执行 which pod 输出有点不一样，它是 /usr/bin/pod，而 which pod 的输出是 /usr/local/bin/pod，再看一下我的 $PATH 路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/Users/tianyi/.rvm/gems/ruby-2.4.1/bin:/Users/tianyi/.rvm/gems/ruby-2.4.1@global/bin:/Users/tianyi/.rvm/rubies/ruby-2.4.1/bin:/Users/tianyi/.rvm/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin:/Users/tianyi/.jenv/shims:/Users/tianyi/.jenv/bin:/opt/subversion/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Server.app/Contents/ServerRoot/usr/bin:/Applications/Server.app/Contents/ServerRoot/usr/sbin:/usr/local/go/bin:/Users/tianyi/bin:/Users/tianyi/goProject/bin:/usr/local/go/bin:/usr/local/Cellar/nginx/1.12.0/bin:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>可以看到在我的 $PATH 环境变量里，/usr/local/bin 的优先级是高于 /usr/bin 的，因此当这两个地方都存在一个名叫 pod 的命令时，系统优先执行 /usr/local/bin/pod，于是错误就这么产生了。因此我直接删除 /usr/local/bin/pod 文件，再执行 pod install –verbose，这一次果然安装成功了。</p><p>这个问题应该是由于 Cocoapods 改变了安装路径导致的，记得 macOS 启用 System Integrity Protection 之后 Cocoapods 的安装路径也修改过，这次应该也是类似的问题吧，由于 $PATH 这个环境变量的问题，导致老版本的 pod 命令优先被执行。</p><p>事情至此还未结局</p><p>本地执行pod 指令已经没问题了，但是我们通过Bamboo 集成，使用脚本打包，却一直重复前面的错误无法自拔。</p><p>重启bamboo 服务，依然不能解决问题</p><p>尝试着使用重启治百病的手段，电脑关机重启试试看！</p><p>祈祷中…🙏</p><p>2017年12月6日午时三刻更</p><p>说了你可能不相信，重启电脑后，一切问题都好了~</p><p>更新</p><p>解决macOS Sierra下注册机无法运行的问题</p><p>很多软件都不兼容了<br>「安全性与隐私」设置中「任何来源」选项消失<br>几乎所有注册机都用不了</p><p>恢复任何来源选项<br>ps：如果系统升级前就已经选择了任何来源，升级后还会正常显示</p><p>打开终端(Terminal.app)<br>执行<code>sudo spctl --master-disable</code></p><p>“任何来源”恢复~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？&lt;/p&gt;
&lt;p&gt;最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚&lt;/p&gt;
&lt;p&gt;不过在使用 Cocoapods 的时候还是遇到了问题：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>伙计们，Go 并没有那么简单</title>
    <link href="https://blog.yuhanle.com/2017/12/04/go-is-not-very-simple-folks/"/>
    <id>https://blog.yuhanle.com/2017/12/04/go-is-not-very-simple-folks/</id>
    <published>2017-12-04T01:00:00.000Z</published>
    <updated>2018-07-05T01:14:17.624Z</updated>
    
    <content type="html"><![CDATA[<p>已发布：<a href="https://studygolang.com/articles/12330" target="_blank" rel="noopener">https://studygolang.com/articles/12330</a></p><h1 id="伙计们，Go-并没有那么简单"><a href="#伙计们，Go-并没有那么简单" class="headerlink" title="伙计们，Go 并没有那么简单"></a>伙计们，Go 并没有那么简单</h1><p>出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。</p><p>到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。</p><a id="more"></a><p>社区实际上并不那么令人愉快，特别是那些因为它的简单性而主张使用 Go 的人。似乎简单已经成为 Go 社区中的一个流行语，许多人反复重复提到这点，却没有给出太多实际的想法。</p><p>这对我来说似乎很不幸，因为在我看来，Go 是一个“极其简单的语言”：</p><ol><li>不应该作为考虑使用 Go 的主要原因</li><li>从他们的关注点中找到其他更有利的推荐理由</li><li>甚至不是真的（不是真的简单）</li></ol><p>在这篇文章中，我想围绕 Go 来分析一些简单观点。</p><p><em>在深入之前，我想强调一件事情</em>：这篇文章并不是对 Go 的批评，而是一种对 Go 的宣传和倡导的方式。有时候，我可能会批评这个语言的某个方面，但这不是我们关注的重点，我只会试图用一种非正式的、事实的，每种语言都会涉及的方式来讲述。</p><h2 id="我来自哪里"><a href="#我来自哪里" class="headerlink" title="我来自哪里"></a>我来自哪里</h2><p>出于工作和业余爱好，我同时使用多种编程语言。我不赞成有“最喜欢的语言”的概念。过去我曾经有过一些最喜欢的语言，但这种认识往往是一时的情感，随着时间推移，会发生变化。</p><p>在我的工作中，我使用 <code>C++</code> 和 <code>Python</code> 写大型服务的后端代码。过去我曾经在一个你可能知道的操作系统上工作，而且我也做了嵌入式工作。在业余项目中，我做了其他各种事情。</p><p>我并不是夸耀什么（我不是一个专家），我只是想表明，我在编程的许多领域至少有一些见解，而且我一直努力保持开放的心态。</p><p>所以，不要着急，让我们开始讨论正题，看看几个观点。</p><h3 id="1-“与主流语言相比，Go-的关键字非常少”"><a href="#1-“与主流语言相比，Go-的关键字非常少”" class="headerlink" title="1. “与主流语言相比，Go 的关键字非常少”"></a>1. “与主流语言相比，Go 的关键字非常少”</h3><p>我从一个最常见的例子开始。当推广 Go 时，这会是大家的口头禅。</p><p>首先，即使它是真实的，我不知道为什么关键字数量会是判断一个语言的学习曲线或复杂性的重要依据。当然，如果有成千上万的关键字，这可能是一个问题。但是大多数语言最多只有几十个关键字，这种规模下，关键字的多少是无关紧要的。</p><p>我还没有听到有人因为关键字的数量而抱怨某门语言</p><p>其次，Go 所谓的“很少”的关键字实际上只不过是一个聪明律师的伎俩（也许，我甚至会认为这是 Go 的虚假广告）。<a href="https://golang.org/ref/spec#Keywords" target="_blank" rel="noopener">Go 规范</a> 列出了 25 个关键字，这的确比大多数语言要少些。但在我看来，Go 并没有比其他语言关键字表示更少的概念，Go 虽然没有这些关键字，但相应的概念依然是语言的一部分（即实际的复杂性保持不变）。</p><p>为了说明我的意思，请考虑一个 <code>while</code> 循环。 Go 没有这个关键字，这是真的，但它仍然有一个 while 循环，<a href="https://tour.golang.org/flowcontrol/3" target="_blank" rel="noopener">文档</a>甚至是这样说的，它的目的只是重用其他关键字。</p><p>另一个这样的例子是 <code>private</code> 和 <code>public</code>。 Go 没有这些关键字，但它仍然有 <code>private</code> 和 <code>public</code>，它只是使用字母大小写而不是关键字。</p><p>用来删减关键字的另一个技巧叫 <a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">预定义标识符（Predeclared identifiers）</a>，在技术上它不是关键字，但是在实践中仍然需要它们，创建一个和它同名的变量仍然不是一个好主意，因此，最后看来…它们基本上是关键字。此外，其中一些预定义标识符是其他语言的关键字，因此仅将它们与 Go 的关键字列表进行比较是非常不公平的。就像苹果和桔子。</p><h3 id="2-接收者参数"><a href="#2-接收者参数" class="headerlink" title="2. 接收者参数"></a>2. 接收者参数</h3><p><a href="https://tour.golang.org/methods/1" target="_blank" rel="noopener">接受者参数</a>对我来说有些古怪。看起来 Go 似乎并不建议使用 <code>this</code> 和 <code>self</code>，但是仍然需要方法，所以就存在 “接收者参数”，除了方法签名看上去很奇怪之外，它们基本上是一样的。</p><p>接收者参数有一个问题，当访问一个方法时，我需要知道接收者参数（这是任意的）的名称，以明确这个方法的作用。因为缺少关键字（译注：如 this），语法高亮成为一个问题。（看吧？这是如何减少关键字实际上使事情变得更加复杂的例子。）这有点像 <code>C++</code> 中的隐式 <code>this</code>。</p><p>这里有一个新人容易混淆的<a href="https://stackoverflow.com/questions/17932722/go-difference-between-parameter-and-receiver" target="_blank" rel="noopener">例子</a>。</p><p>恕我直言，最简单、最直接的方式来表达一个接收器是 <a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank" rel="noopener">UFCS</a>，而不是 C++ 或 Go 的方式。但就像我说的，我不是在抱怨 Go，我真的不介意接受者参数的观点（如果我忍受不了 C++ 的怪异，我可以忍受 Go 的）。</p><h3 id="3-函数返回值"><a href="#3-函数返回值" class="headerlink" title="3. 函数返回值"></a>3. 函数返回值</h3><p>如果接收参数不够，函数甚至能够通过各种形式的返回值来声明。通常语言允许你通过 <code>return</code> 语句返回函数中的一个值。而在 Go 语言中，你可以返回多个值（我认为可以用更优雅的方式通过元组来解决，但是就这样吧）。除此之外，还有<a href="https://tour.golang.org/basics/7" target="_blank" rel="noopener">命名返回值</a>。在我看来，并不是一个好主意，因为它允许我们在那些很难找到返回值的地方写上晕头转向的代码。结合接收方参数，您可以创建这样的函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foobar)</span> <span class="title">Something</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> <span class="params">(foo <span class="keyword">int</span>, bar <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是有效的 Go 代码。如您所见，有三个参数。我真的不希望任何人试图选择这个“简单”，因为这个语法除了简单，什么也不是。</p><h3 id="4-“没有继承”"><a href="#4-“没有继承”" class="headerlink" title="4. “没有继承”"></a>4. “没有继承”</h3><p>Go（或许只是社区）似乎很反对“传统的 OOP”（不管这是指哪个，可能是 Java 或者 C++），我记得有人说 Go 没有继承是一件好事。</p><p>除此之外，Go 有一个功能叫做<a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">嵌入</a>，这个文档以及一些博客文章声称 Go 没有继承。我试着用各种方式使用它，我没法认为 Go 反对继承。上面链接的文档说：</p><blockquote><p>还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法，但当它们被调用时，该方法的接收者是内部类型，而非外部的。</p></blockquote><p>有差别吗？继承通常以相同的方式工作，继承的方法也对内部类型起作用。</p><p>在我看来，在 Go 中，真正唯一不同的是，多态性从结构中解耦。你需要使用接口来使用多态性。但一旦你做了，做的事情和传统的 OOP 非常相似，包括方法覆盖 - <a href="https://play.golang.org/p/DRozP3HCAk" target="_blank" rel="noopener">这里是个演示</a>。</p><p>关于 Go，有件事令我很惊讶 —— 这门所谓简单的语言 —— 你甚至可以实现多重继承。<strong>确实很糟糕。</strong> <a href="https://groups.google.com/forum/#!topic/golang-nuts/fRfkPNlA7Pk" target="_blank" rel="noopener">golang-nut 的邮件列表</a>中，有人提到，Go 并不能很好的处理继承的歧义。我已经调整了其中提及的代码，以便它展示了著名的“可怕的钻石问题”（Dreaded diamond problem）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">T2</span><br><span class="line">T3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">T4</span><br><span class="line">foo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">struct</span> &#123;</span><br><span class="line">T4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T4 <span class="keyword">struct</span> &#123;</span><br><span class="line">foo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t2 := T2&#123; T4&#123; <span class="number">9000</span> &#125;, <span class="number">2</span> &#125;</span><br><span class="line">t3 := T3&#123; T4&#123; <span class="number">3</span> &#125; &#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t2.foo)</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t3.foo)</span><br><span class="line">t1 := T1&#123;</span><br><span class="line">t2,</span><br><span class="line">t3,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t1.foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://play.golang.org/p/cSCLyGHssR" target="_blank" rel="noopener">在线运行以上代码</a></p><p>上面的代码没有任何编译时警告或者错误。<a href="https://ideone.com/gfKYqR" target="_blank" rel="noopener">这是 C++ 的类似的代码</a>，你可以看到，它编译不通过，因为存在歧义。</p><p>结果会如何？首先，我认为具有多重继承功能，几乎不能在描述该编程语言时使用“简单”一词。<strong>在我看到上面的代码后，没有人能说服我，Go 是最简单的语言之一，甚至连简单语言都不算。</strong>甚至没有其他一些你可以用嵌入来做的事情，比如通过指针嵌入或者通过指针嵌入接口。 （我甚至不确定这些功能的真正含义。）</p><p>其次，我想做一个简短、对 Go 语言本身的批评。不处理这样的歧义似乎是一个设计或者实现错误。甚至连 C++ 都没有如此疯狂，让这种代码编译通过。这足以告诉你一些事情。</p><h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><p>各种错误处理通常会导致一个巨大的口水战。我不想谈那件事。我曾经在不同的语言中使用过所有常见的错误处理风格（我认为），我也不喜欢所有这些语言。我认为，错误处理无论什么一直是一个 <code>PITA</code>（译注：应该是国外的一种比喻）。把一种风格换成另一种风格，你只需把一套问题换成另一套。没有好的方法。</p><p>回到简单的话题：Go 让我选择不使用异常，这使事情更简单了。多个返回值的特征不能使事情变得简单，这意味着不能返回一个错误或成功的结果，你可以返回所有值或者都不返回（<code>CS</code> 术语，你可以说这个问题是一个产品类型而不是总和式的用法）。事实上，我看过的许多对于新人的代码审查。</p><p>如果 Go 不允许多个返回值，而有一些合适的或者喜欢的类型，在我看来，这会使事情变得更简单。出于同样的原因，在 Go 中忽略错误或者不向向调用者或其他适当目的地报告错误是相当容易的。</p><p>另一不简单的是 panic。不要误解我的意思，我理解它在 Go 中存在的原因以及它的用处，事实上，其他语言也有类似的处理。我只是提出来作为反对简单性的一个论据。恕我直言，对于一个新人，很可能会混淆 error 和 panic 之间的区别，以及什么时候适合用什么。</p><h3 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6. 泛型"></a>6. 泛型</h3><p>这个主题和错误处理比起来，可能是一个更大的蠕虫。</p><p>和 errors 一样，我只想考虑一下这里的复杂性或者简单性。Go 社区的许多人似乎认为，泛型的本质上是复杂的（=坏，嗯嗯嗯咳），有这样或那样的巨大开销。这在某种程度上是事实，但我不认为它像有些人描述的那么糟糕。似乎那些人已经经历了 <code>C++</code> 模板的痛苦，从那以后，无论何时提及泛型，都会遭受 PTSD（创伤后应激障碍） 的攻击。</p><p>看到这里的人，<strong>泛型不是一个怪物</strong>。它们当然绝对不应该像 <code>C++</code> 那样复杂（或者其他一些奇怪的语言）。我的意思是，甚至前端的人都用泛型工作了一段时间（TypeScript, Flow, …），如果他们不害怕泛型，其他程序员应该是没有理由害怕：）（对不起，前端开发者，只是开个玩笑。）</p><p>人们还没有意识到，如果正确地使用泛型，它可以使许多类型和函数的使用更加简单。例如，考虑 Go 中的<a href="https://golang.org/pkg/container/heap/" target="_blank" rel="noopener">堆接口</a>。这就是从一个堆中声明这个接口的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popped := heap.Pop(&amp;someheap)</span><br><span class="line">myfoo := popped.(*Foo)       <span class="comment">// ZOMG what just happened here?</span></span><br></pre></td></tr></table></figure><p>对新人解释这些，包括 panic 的问题。也许可以考虑一下，如果他们没有真正把整个 <code>interface{}</code> 搞对，那么会发生什么。相比之下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfoo := heap.Pop(&amp;someheap) <span class="comment">// myfoo has the correct type</span></span><br></pre></td></tr></table></figure><p>这更容易阅读、更容易解释（你解释它，就像你将解释 <code>map</code> 类型已经存在于 Go！）。而且在编写代码时也更难弄乱。</p><p>缺乏泛型是造成额外复杂性的原因，它在 Go 的其他部分也会造成相当多的复杂性，主要是需要存在各种“神奇”的函数/类型。<code>map</code>，<code>slice</code> 和 <code>channel</code> 类型的魔法，以及伴随的 <code>make()</code> 功能，这是它们三个的构造函数。<code>slice</code> 类型既可以作为数组的引用，也可以作为动态数组。（不管发生什么事，“做一件事，并做好它”？）</p><p>（只是为了提醒大家，我并不介意这些，只是为了不简单的争论而提及它。）</p><h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h3><p>我想我已经把主要的简单违反者排除在外了。我的单子上只剩下几个简单的：</p><ol><li><code>&lt;-</code> 和 <code>-&gt;</code> 操作符。这些可能只是 <code>channel</code> 类型的方法。</li><li><code>iota</code> - 基本一样，但奇怪的枚举。</li><li>内置的复数。</li><li><a href="https://tour.golang.org/flowcontrol/6" target="_blank" rel="noopener">if 支持短语句</a>（有时可能有用，但 <code>if</code> 语法比其他语言中更复杂）</li></ol><p>我想就是这样。可能忘记了什么，但我想已经足够了。</p><p>那么，我觉得如果不是简单的话，Go 实际上会带来什么呢？</p><h2 id="任务-“goroutines”"><a href="#任务-“goroutines”" class="headerlink" title="任务 - “goroutines”"></a>任务 - “goroutines”</h2><p>这可能看起来有点显而易见，因为 <code>goroutines</code> 是一个经常被提及的特性，就像“简单”一样，所以我觉得需要区分下：我认为这不是通常意义上的并发性，它不能认为是 Go 的优势。不要误解我的意思，Go 的并发性是没问题的。只是说这没有什么特别的。你有 channel，这肯定是好的，但基本上，它们只是像我在别处常用的并发队列。然后你有常规的并发原语，像 mutex，读写锁，条件变量等。你可以同步你的代码，你可能会遇到像许多其他语言一样的竞争条件和死锁。</p><p>我喜欢 <code>goroutines</code>（除了明显的事实，它们是轻量级的用户空间线程）是它们可以使用 I/O 的方式 - 调度连接到主机操作系统的低级 I/O API 的方式（如 epoll、kqueue、IOCP…）。这对于程序员来说通常很难做出令人愉快和有用的东西，特别是在编译本地语言的时候。我仍然在这里了解细节，但在我看来，这是一个很好的做法，也是为什么我认为 Go 是未来工程的一个亮点。</p><p>正如已经暗示的，我也喜欢 Go 这种编译为本地代码的语言。看到新的语言使用垃圾收集来保持这种不可思议的效果真是太好了。（或其他形式的自动内存管理 - <code>Swift</code> 中有提及）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以，读者们，为什么所有这些都离开了你呢？是 Go 复杂还是其他什么原因？</p><p>当然不是，绝对不像 <code>C++</code> 或 <code>Haskell</code> 那样复杂。相比之下，Go 的确很简单。另一方面，比较 Go 和其他常见语言（如<code>Java</code> ，<code>JavaScript</code> ，<code>Python</code> 等）的复杂性时，情况就不太清楚了，正如我希望的那样。 （此外，这是一个很难，没有明确定义的任务。）</p><p>我可以提供类似的例子。在某些方面，Go 可能比这些语言更简单，有些则不是…大致上我会说它和其他常用语言的平均差不多。我也不认为简单，无论是感觉上还是实际使用中，最终的体验很重要。</p><p>最后，这篇文章从哪里来，作者是谁？我不肯定。我还不知道 Go 是否会在我的日常工作中被选为一个（子）项目，或者我是否可能将它用于兴趣爱好项目。我想避免像本文提到的那种教条的社区推广的一份子。有没有意识形态导向的地方呢？ 大家可以随意就此提出建议。</p><p>我和 <code>Rust</code> 社区有同样的问题，请不要介意，我也知道离开那些更狂热的支持者会更好。 （Q：“你能否在 <code>Rust</code> 重写你的项目？”A：“迷失了”）也许这就是这些新语言的性质，以及他们为激励人们如此激励阳光的争斗。</p><hr><p>via: <a href="https://medium.com/@bob.clark_34506/go-is-not-very-simple-folks-3e84220e73c7" target="_blank" rel="noopener">https://medium.com/@bob.clark_34506/go-is-not-very-simple-folks-3e84220e73c7</a></p><p>作者：<a href="https://medium.com/@bob.clark_34506" target="_blank" rel="noopener">The Other Bob</a><br>译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已发布：&lt;a href=&quot;https://studygolang.com/articles/12330&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://studygolang.com/articles/12330&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;伙计们，Go-并没有那么简单&quot;&gt;&lt;a href=&quot;#伙计们，Go-并没有那么简单&quot; class=&quot;headerlink&quot; title=&quot;伙计们，Go 并没有那么简单&quot;&gt;&lt;/a&gt;伙计们，Go 并没有那么简单&lt;/h1&gt;&lt;p&gt;出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。&lt;/p&gt;
&lt;p&gt;到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Beego 入门指南（一）如何新建项目</title>
    <link href="https://blog.yuhanle.com/2017/06/24/beego-study-newproject/"/>
    <id>https://blog.yuhanle.com/2017/06/24/beego-study-newproject/</id>
    <published>2017-06-24T09:00:00.000Z</published>
    <updated>2018-07-05T01:15:35.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何新建项目"><a href="#如何新建项目" class="headerlink" title="如何新建项目"></a>如何新建项目</h1><p>你对beego一无所知？没关系，这篇文档会很好的详细介绍beego的各个方面，看这个文档之前首先确认你已经安装了beego，如果你没有安装的话，请看这篇<a href="https://github.com/astaxie/beego/blob/master/docs/zh/Install.md" target="_blank" rel="noopener">安装指南</a></p><p>beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架，主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架。</p><a id="more"></a><blockquote><p>以下内容需要掌握 golang 的语法基础</p></blockquote><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>首先我们可以看一下入门必学课程，编写一个Hello world 的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/astaxie/beego&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MainController struct &#123;</span><br><span class="line">    beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MainController) Get() &#123;</span><br><span class="line">    this.Ctx.WriteString(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    beego.Router(&quot;/&quot;, &amp;MainController&#123;&#125;)</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的代码保存为hello.go，然后通过命令行进行编译并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build hello.go</span><br><span class="line">$ ./hello</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/545755-436febc86fad703e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170507-084105@2x.png"></p><p>这个时候你可以打开你的浏览器，通过这个地址浏览<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080</a>返回“hello world”</p><p>那么上面的代码到底做了些什么呢？</p><p>1、首先我们引入了包github.com/astaxie/beego,我们知道Go语言里面引入包会深度优先的去执行引入包的初始化(变量和init函数，<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/ebook/02.3.md#maininit" target="_blank" rel="noopener">更多</a>)，beego包中会初始化一个BeeAPP的应用，初始化一些参数。</p><p>2、定义Controller，这里我们定义了一个struct为MainController，充分利用了Go语言的组合的概念，匿名包含了beego.Controller，这样我们的MainController就拥有了beego.Controller的所有方法。</p><p>3、定义RESTFul方法，通过匿名组合之后，其实目前的MainController已经拥有了Get、Post、Delete、Put等方法，这些方法是分别用来对应用户请求的Method函数，如果用户发起的是POST请求，那么就执行Post函数。所以这里我们定义了MainController的Get方法用来重写继承的Get函数，这样当用户GET请求的时候就会执行该函数。</p><p>4、定义main函数，所有的Go应用程序和C语言一样都是Main函数作为入口，所以我们这里定义了我们应用的入口。</p><p>5、Router注册路由，路由就是告诉beego，当用户来请求的时候，该如何去调用相应的Controller，这里我们注册了请求/的时候，请求到MainController。这里我们需要知道，Router函数的两个参数函数，第一个是路径，第二个是Controller的指针。</p><p>6、Run应用，最后一步就是把在1中初始化的BeeApp开启起来，其实就是内部监听了8080端口:Go默认情况会监听你本机所有的IP上面的8080端口</p><p>停止服务的话，请按ctrl+c</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>首先进入goPath目录，通过如下命令创建beego项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src</span><br><span class="line">$ bee new hello</span><br><span class="line"></span><br><span class="line">// bee command</span><br><span class="line">// 默认创建带 view 的工程</span><br><span class="line">// bee new [appname] </span><br><span class="line">// 当然也可以直接快速创建 api 工程</span><br><span class="line">// bee api [appserver]</span><br></pre></td></tr></table></figure><p>这样就建立了一个项目hello，目录结构如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">quickstart</span><br><span class="line">|-- conf</span><br><span class="line">|   `-- app.conf</span><br><span class="line">|-- controllers</span><br><span class="line">|   `-- default.go</span><br><span class="line">|-- main.go</span><br><span class="line">|-- models</span><br><span class="line">|-- routers</span><br><span class="line">|   `-- router.go</span><br><span class="line">|-- static</span><br><span class="line">|   |-- css</span><br><span class="line">|   |-- img</span><br><span class="line">|   `-- js</span><br><span class="line">|-- tests</span><br><span class="line">|   `-- default_test.go</span><br><span class="line">`-- views</span><br><span class="line">    `-- index.tpl</span><br></pre></td></tr></table></figure><p>从目录结构中我们也可以看出来这是一个典型的 MVC 架构的应用，main.go 是入口文件。</p><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>通过bee创建的项目，beego默认情况下是开发模式。<br>我们可以打开app.conf 文件，通过如下的方式改变我们的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beego.RunMode = &quot;pro&quot;</span><br></pre></td></tr></table></figure><p>或者我们在conf/app.conf下面设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runmode = pro</span><br></pre></td></tr></table></figure><p>以上两种效果一样。</p><p>开发模式中</p><ul><li>开发模式下，如果你的目录不存在views目录，那么会出现类似下面的错误提示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017/05/07 9:36:17 [W] [stat views: no such file or directory]</span><br></pre></td></tr></table></figure><ul><li><p>模板会自动重新加载不缓存。</p></li><li><p>如果服务端出错，那么就会在浏览器端显示如下类似的截图：</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/545755-cce31499ceaeda1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170507-090203@2x.png"></p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>首先进入到hello 的根目录，执行以下命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yuhanledeMacBook-Pro:goProject yuhanle$ cd src/hello/</span><br><span class="line">yuhanledeMacBook-Pro:hello yuhanle$ bee run</span><br><span class="line">______</span><br><span class="line">| ___ \</span><br><span class="line">| |_/ /  ___   ___</span><br><span class="line">| ___ \ / _ \ / _ \</span><br><span class="line">| |_/ /|  __/|  __/</span><br><span class="line">\____/  \___| \___| v1.8.3</span><br><span class="line">2017/05/07 08:54:08 INFO     ▶ 0001 Using &apos;hello&apos; as &apos;appname&apos;</span><br><span class="line">2017/05/07 08:54:08 INFO     ▶ 0002 Initializing watcher...</span><br><span class="line">hello/controllers</span><br><span class="line">hello/routers</span><br><span class="line">hello</span><br><span class="line">2017/05/07 08:54:10 SUCCESS  ▶ 0003 Built Successfully!</span><br><span class="line">2017/05/07 08:54:10 INFO     ▶ 0004 Restarting &apos;hello&apos;...</span><br><span class="line">2017/05/07 08:54:10 SUCCESS  ▶ 0005 &apos;./hello&apos; is running...</span><br><span class="line">2017/05/07 08:54:10 [I] [asm_amd64.s:2197] http server Running on http://:8080</span><br></pre></td></tr></table></figure><p>这样我们的应用已经在 8080 端口(beego 的默认端口)跑起来了.你是不是觉得很神奇，为什么没有 nginx 和 apache 居然可以自己干这个事情？是的，Go 其实已经做了网络层的东西，beego 只是封装了一下，所以可以做到不需要 nginx 和 apache。</p><p>然后就可以在浏览器中打开 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 预览我们创建的第一个项目。</p><p><img src="http://upload-images.jianshu.io/upload_images/545755-8f52376c9d2c1e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170507-090245@2x.png"></p><p>下一节：路由设置（预计周末）</p><p>更多内容请参考：<strong><a href="https://github.com/yuhanle/BeegoStudyNotes" target="_blank" rel="noopener">BeegoStudyNotes</a></strong></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://beego.me/docs/quickstart/" target="_blank" rel="noopener">beego 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何新建项目&quot;&gt;&lt;a href=&quot;#如何新建项目&quot; class=&quot;headerlink&quot; title=&quot;如何新建项目&quot;&gt;&lt;/a&gt;如何新建项目&lt;/h1&gt;&lt;p&gt;你对beego一无所知？没关系，这篇文档会很好的详细介绍beego的各个方面，看这个文档之前首先确认你已经安装了beego，如果你没有安装的话，请看这篇&lt;a href=&quot;https://github.com/astaxie/beego/blob/master/docs/zh/Install.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架，主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Beego" scheme="https://blog.yuhanle.com/categories/Beego/"/>
    
    
      <category term="Beego" scheme="https://blog.yuhanle.com/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>GCD 同步异步以及串并行详解</title>
    <link href="https://blog.yuhanle.com/2017/05/02/gcd-sync-parallel/"/>
    <id>https://blog.yuhanle.com/2017/05/02/gcd-sync-parallel/</id>
    <published>2017-05-02T00:00:00.000Z</published>
    <updated>2018-07-05T01:17:36.614Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/gcd/wind-surfing-67627_1920.jpg" alt="浪起来"></p><p>GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语<br><a id="more"></a></p><p>描述多个任务之间同一时刻的运行关系：</p><ul><li>serial（串行） 某一时刻，只执行一个任务</li><li>concurrent（并行） 可以同时执行多个任务</li></ul><p>侧重描述一个函数的执行完成，对其他任务的影响 (既 是否任务在等待某个函数完成，然后才可以运行)：</p><ul><li>synchronous（同步） 任务执行完成后reture，（阻塞）</li><li>asynchronous（异步） 不等待任务执行完成，立即reture，（不阻塞当前）</li></ul><p>在GCD中，我们用串行并行描述队列。这就是在描述，该队列里面的所有任务，相互之间在同一时刻，是怎样的运行关系。是指队列内本身的任务运行顺序。 </p><p>我们还用同步异步，描述某一个任务。比如说任务A是同步执行的。这就是在说，A任务，会阻塞当前任务，直到A结束。这是指不同任务之间的关系，与队列无关，可以是不同队列，也可以是相同队列。</p><p>接下来，我们先来看下，GCD里面的不同队列。</p><h2 id="Serial-Queues"><a href="#Serial-Queues" class="headerlink" title="Serial Queues"></a>Serial Queues</h2><p>在串行队列里，同一时间只能执行一个任务。任务按照被添加进入队列的顺序依次执行。每一个任务只有在前面的任务完成后，才可以开始执行。</p><p>系统为我们提供的串行队列</p><ul><li>main queue ( dispatch_get_main_queue )</li></ul><p>main queue是一个串行队列，有串行队列的一切特性。比较特殊的一点是加入这个队列的任务，都是在主线程执行的。</p><h2 id="Concurrent-Queues"><a href="#Concurrent-Queues" class="headerlink" title="Concurrent Queues"></a>Concurrent Queues</h2><p>加入并行队列的任务，执行的顺序也是按照任务被加入队列的顺序执行，这是我们唯一可以保证的。每个任务都不用等待之前的任务完成，同一时刻可以多个任务同时执行。</p><p>系统同样有一个全局的并发队列</p><ul><li>global dispatch queue ( dispatch_get_global_queue )</li></ul><p>这是另一个我们熟悉的并发队列，很多时候我们直接使用这个队列，可以简单处理一些我们需要并发执行的任务。</p><h2 id="Custom-Queue"><a href="#Custom-Queue" class="headerlink" title="Custom Queue"></a>Custom Queue</h2><p>除了系统提供的全局队列之外，我们还可以自定义串行或者并行的队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>上面是几种我们用GCD时，需要使用到的队列。</p><p>另外，使用GCD，除了选择正确的队列外，还要关注：我们要执行的任务是同步还是异步执行。</p><h2 id="dispatch-async-异步执行"><a href="#dispatch-async-异步执行" class="headerlink" title="dispatch_async 异步执行"></a>dispatch_async 异步执行</h2><p>dispatch_async 用来用异步的方式执行串行或者并行队列里面的任务，我们来看一下使用 dispatch_async 的几种常见情况：</p><ul><li>custom Serial Queue：当我们需要执行几个应该串行执行的任务，又不阻塞当前的时候。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// task1 task2 顺序依次执行，同时不阻塞others</span><br><span class="line"></span><br><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">dispatch_async(mySerialQueue, ^&#123;</span><br><span class="line">   ...task1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(mySerialQueue, ^&#123;</span><br><span class="line">  ...task2</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...others</span><br></pre></td></tr></table></figure><ul><li><p>main Queue：当我们执行并完成了一段异步的任务，需要回到主线程更新UI的时候，很常见的选择就是使用GCD的 main queue。</p></li><li><p>custom or global concurrent Queue：这个是我们执行非UI任务的常见选择。要注意的是，加入队列的多个任务之间并发执行，我们无法知道那个任务先完成。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">  ...task1    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          Update UI </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dispatch-sync-同步执行"><a href="#dispatch-sync-同步执行" class="headerlink" title="dispatch_sync 同步执行"></a>dispatch_sync 同步执行</h2><p>大部分时候我们执行dispatch_sync操作，都要格外小心些。</p><ul><li>custom or main Serial Queue： 同步执行串行队列时，要注意防止发生死锁，比如下面的代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/串行队列中，task2 等待 task1完成，所以不会开始。而task1又完成不了，因为task2还没有执行完(甚至都没有开始)。死锁。</span><br><span class="line">  </span><br><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">dispatch_sync(mySerialQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    ...task1</span><br><span class="line">    dispatch_sync(mySerialQueue, ^&#123;</span><br><span class="line">       </span><br><span class="line">       ...task2            </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>concurrent Queue：合理使用可以解决一些并发读写问题。例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//task1 执行结束后，task2才会开始执行。</span><br><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_sync(myConcurrentQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">  ...task1 读</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">  ...task2 写</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>异步延迟操作。实际上 dispatch_after 就像一个延迟执行的 dispatch_async。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double delayInSeconds = 1.0;</span><br><span class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line"> dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xqhcq.com1.z0.glb.clouddn.com/gcd/wind-surfing-67627_1920.jpg&quot; alt=&quot;浪起来&quot;&gt;&lt;/p&gt;
&lt;p&gt;GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="GCD" scheme="https://blog.yuhanle.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>GCD 同步操作之 Resource Competition</title>
    <link href="https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/"/>
    <id>https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/</id>
    <published>2017-04-28T00:00:00.000Z</published>
    <updated>2018-07-05T01:17:30.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/gcd/surfer-2212948_1920.jpg" alt="更快更高更强"></p><p>在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。<br><a id="more"></a></p><h2 id="dispatch-barriers"><a href="#dispatch-barriers" class="headerlink" title="dispatch barriers"></a>dispatch barriers</h2><p>在使用 Concurrent Queue 的时候，有时候我们希望队列中的某项任务，能够被串行执行，来避免资源竞争等多线程问题。比如遇到读写问题，这时候我们就需要使用 dispatch barriers。来保证即使在并行队列中，对某个对象的读和写操作，在同一时刻，只有一个可以被执行。这时候就可以用到 dispatch barriers了。下面我们来讨论一下，不同的队列中barriers的使用：</p><ul><li><p>Custom Serial Queue: 在串行队列中，队列都是顺序串行执行，使用barriers没有任何好处。一般来讲我们不需要这么做。</p></li><li><p>Global Concurrent Queue: 这里虽然是并行队列，但这个队列是全局的，我们不能保证别人没有使用这个队列。对这个队列加barriers，可能会影响到其他模块的功能。所以不建议在这个队列中使用。</p></li><li><p>Custom Concurrent Queue: 在自定义的并行队列中使用barriers，是比较合适的方式。</p></li></ul><p>所以当我们要做的并行操作，可能存在线程安全问题的时候。我们最好考虑新建自定义并行队列，而不是简单地使用系统提供的 Global Queue。</p><p>举一个例子，假设某一个类要管理MyClass这个类型的读写，下面列举这个类的一些相关方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//初始化自定义并发队列</span><br><span class="line">  - (instancetype)init&#123;</span><br><span class="line">      </span><br><span class="line">      if(self = [super init])&#123;</span><br><span class="line">          customConcurrentQueue = dispatch_queue_create(&quot;com.customConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //写方法</span><br><span class="line">  - (void)write:(MyClass *)myClass &#123;</span><br><span class="line">  </span><br><span class="line">      if( myClass )&#123;</span><br><span class="line">          </span><br><span class="line">          //使用barrier，保证写方法，可以串行执行</span><br><span class="line">            dispatch_barrier_async(self.customConcurrentQueue, ^&#123; </span><br><span class="line">              </span><br><span class="line">              //写操作</span><br><span class="line">              ...</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //读方法</span><br><span class="line">  - (MyClass *)read&#123;</span><br><span class="line">      </span><br><span class="line">      //要保证，读和写方法不能同时执行，</span><br><span class="line">      //首先，他们要在同一个队列中 ：self.customConcurrentQueue</span><br><span class="line">      //其次，读方法要等待读出数据后返回，所以应该是同步操作 ：dispatch_sync</span><br><span class="line">      </span><br><span class="line">      __block MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">      </span><br><span class="line">      dispatch_sync(self.customConcurrentQueue, ^&#123;</span><br><span class="line">      </span><br><span class="line">          //读操作</span><br><span class="line">          myClass = ...</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      return myClass;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="dispatch-groups"><a href="#dispatch-groups" class="headerlink" title="dispatch groups"></a>dispatch groups</h2><p>有时候，我们需要在多个并行任务全部完成后，做一些操作，这时候就需要用到 group来管理了。</p><p>举一个简单的例子。我有4个任务要使用并发处理，任务4要等待，任务1、2、3完成后执行。同时，任务4不阻塞当前的线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroup&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.test.testConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  //异步操作</span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务1</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务2</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务3</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //dispatch_group_notify 中的block执行的是我们最后要做的任务。同时，这里是异步操作，不会阻塞后面其他代码的执行。</span><br><span class="line">  dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      </span><br><span class="line">      //前面3个任务，都执行完成后，执行里面的block</span><br><span class="line">      任务4</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看另一个需求，还是之前的4个任务。唯一的区别是，任务4除了要等待其他任务完成，还要阻塞当前线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroup&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  //异步操作</span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务1</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务2</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务3</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  //dispatch_group_wait 等待上面任务全部完成，阻塞当前线程，直到超过设置的时间</span><br><span class="line">  //使用时，要注意避免阻塞主线程等问题</span><br><span class="line">  dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">  </span><br><span class="line">  任务4</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，除了使用<code>dispatch_group_async</code>管理要做的任务。还可以使用<code>dispatch_group_enter</code>、 <code>dispatch_group_leave</code> 组合的方式，手动通知任务完成。如果使用手动管理的话，我们要注意：<code>enter</code>和<code>leave</code>方法，应该是成对出现的。</p><p>dispatch_group_enter(customGroup) : 手动告知customGroup，表示一个任务已经开始执行。</p><p>dispatch_group_leave(customGroup) : 手动告知<code>customGroup</code>，表示一个任务已经完成。当所有<code>enter</code>对应的<code>leave</code>方法都执行过后。我们的<code>dispatch_group_notify()</code>或者<code>dispatch_group_wait()</code>，就可以接到任务完成的通知。</p><h2 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch semaphore 信号量"></a>dispatch semaphore 信号量</h2><p>当有多个消费者，访问有限的资源的时候，<a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="noopener">信号量</a>) 可以让我们更好的控制。简单来说，我们通过对信号个数的控制，来达到线程间的同步操作。当信号个数为0的时候，当前线程被阻塞，等待信号量增加，当信号量个数大于0的时候，则线程继续执行。</p><p>注意，同步的操作都要小心使用，避免死锁等问题。</p><p>另外，根据dispatch_semaphore_wait的返回值，可以用于判断某任务是否超时操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)testSemaphore&#123;</span><br><span class="line"></span><br><span class="line">  //创建 信号量 参数代表初始个数</span><br><span class="line">  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">      sleep(2);</span><br><span class="line">  </span><br><span class="line">      //发送一个信号，信号量个数 +1   </span><br><span class="line">      dispatch_semaphore_signal(semaphore);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">      dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);</span><br><span class="line">  </span><br><span class="line">      //线程等待，当信号量大于0时 任务继续执行，信号量 -1</span><br><span class="line">      //线程等待，超过预定的超时时间 任务继续执行 信号量不变</span><br><span class="line">      //关于返回值：当返回值 不为0 的时候，说明超时</span><br><span class="line">      if( dispatch_semaphore_wait(semaphore, timeoutTime) )&#123;</span><br><span class="line">          NSLog(@&quot;time out&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xqhcq.com1.z0.glb.clouddn.com/gcd/surfer-2212948_1920.jpg&quot; alt=&quot;更快更高更强&quot;&gt;&lt;/p&gt;
&lt;p&gt;在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="GCD" scheme="https://blog.yuhanle.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>离开象牙塔以后</title>
    <link href="https://blog.yuhanle.com/2017/04/18/say-hello-work/"/>
    <id>https://blog.yuhanle.com/2017/04/18/say-hello-work/</id>
    <published>2017-04-18T00:00:00.000Z</published>
    <updated>2018-07-05T01:20:17.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/nenshuocijun/architecture-768432_1920.jpg" alt="离开象牙塔以后"></p><p>学校出来有很多区别，其中有一点是最无聊的。</p><a id="more"></a><p>由过去的三点一线，转变成两点一线，没了教室，没了食堂，变成了公司和宿舍。</p><p>没有认真数过，平均每天，在同一条路上来回，将近三年，磨平了几双鞋子，擦碰过多少次路边的槐树。</p><p>出了地铁站，有一个红绿灯路口，八点半钟是高峰期，人正多，很多人迫不及待，趁着车来车往，迅速的窜到对面，急匆匆地消失在视线里。</p><p>习惯过了马路，穿过停车场，因为路边的小路很窄，如果对面同时走过来一个人，就需要相互侧身，就像那篇雨巷，也经常的不小心踩到石坑，污泥溅到另一双鞋子。</p><p>停车场里走着，很危险，可能正在玩手机，我没注意。有一次，有位女士，低着头走着走着，穿过停车杆，没想到停车杆当时正在下落，我能听到敲击头部的声音，很脆，接着就是歇斯底里的嗷叫。</p><p>路边有个快客，我一直以为他是假的快客，在我印象中，这个名字不应该是感冒药吗？很少去光顾这家便利店，因为东西少，不合口味，还特别的贵，除了早餐，还有午饭，零食，如果时间来得及，我会去那家罗森买杯永和豆浆，虽然喝起来没有大豆的味道，但还蛮合口味，特别是冬天，路上顺便暖暖手。</p><p>办公楼里的电梯，工作日上班时间，我没有乘过。就在五楼，闭着眼我都摸上去了，平日里吹嘘着锻炼身体，要减肥，这也是唯一能够坚持下去，锻炼的方式了。</p><p>很想念，两年前每天来回骑行20公里的日子，身体是好了些，腿越来越粗，越有力，凌晨两点的路上，迎着风，骑在快车道上，肚子饿的话就在路边吃点路边摊。摊主们出来的很晚，以至于我的很多朋友都说没见过路边摊，也许是上海整治的很严格吧！</p><p>不管这一天，如何如何，也不会影响新的一天。</p><p>或许，只有清华北大才能称之为象牙塔吧？</p><hr><p>题图：aobahorse 不要求署名</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xqhcq.com1.z0.glb.clouddn.com/nenshuocijun/architecture-768432_1920.jpg&quot; alt=&quot;离开象牙塔以后&quot;&gt;&lt;/p&gt;
&lt;p&gt;学校出来有很多区别，其中有一点是最无聊的。&lt;/p&gt;
    
    </summary>
    
      <category term="suibi" scheme="https://blog.yuhanle.com/categories/suibi/"/>
    
    
      <category term="motion" scheme="https://blog.yuhanle.com/tags/motion/"/>
    
  </entry>
  
  <entry>
    <title>通过Sonar 初步构建代码持续审查</title>
    <link href="https://blog.yuhanle.com/2017/02/15/continuous-code-quality-sonarqube-install/"/>
    <id>https://blog.yuhanle.com/2017/02/15/continuous-code-quality-sonarqube-install/</id>
    <published>2017-02-15T00:00:00.000Z</published>
    <updated>2018-07-05T01:16:38.948Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/Benefits-of-Using-SonarQube-For-Code-Reviews.jpg" alt="SonarQube"></p><h2 id="介绍篇"><a href="#介绍篇" class="headerlink" title="介绍篇"></a>介绍篇</h2><h3 id="SonarQube-介绍"><a href="#SonarQube-介绍" class="headerlink" title="SonarQube 介绍"></a>SonarQube 介绍</h3><p><a href="https://www.sonarqube.org/" target="_blank" rel="noopener">SonarQube</a> 是一款领先的持续代码质量监控平台，开源在github 上，现在已更新到6.2 版本，star 数量超过 1400+，可以轻松配置在内网服务器，实时监控代码，帮助了解提升提升团队项目代码质量。通过插件机制，SonarQube可以继承不同的测试工具，代码分析工具，以及持续集成工具。</p><a id="more"></a><p>与持续集成工具（例如 Hudson/Jenkins 等）不同，SonarQube 并不是简单地把不同的代码检查工具结果（例如 FindBugs，PMD 等）直接显示在 Web 页面上，而是通过不同的插件对这些结果进行再加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。</p><p>在对其他工具的支持方面，Sonar 不仅提供了对 IDE 的支持，可以在 Eclipse 和 IntelliJ IDEA 这些工具里联机查看结果；同时 SonarQube 还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用 SonarQube。</p><p>此外，SonarQube 的插件还可以对 Java 以外的其他编程语言提供支持，对国际化以及报告文档化也有良好的支持。</p><p>行业内提到”代码质量管理, 自动化质量管理”, 一般指的都是通过Sonar来实现。本文的目标是实现在Sonar上显示出iOS项目, 先看张最终的效果图:</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/main-des.png" alt="SonarQube"></p><p>用Sonar能够实现什么?</p><ul><li>技术债务(sonar根据”规则”扫描出不符合规则的代码)</li><li>覆盖率(单元测试覆盖率)</li><li>重复(重复的代码, 有利于提醒封装)</li><li>结构</li></ul><p>问题1: “规则”指的是什么? </p><pre><code>在Sonar工具中配置检测工具(规则), 然后sonar根据规则检测&quot;质量报告文件&quot;, 得出问题数目。 比如本文配置的规则是OCLint</code></pre><p>问题2: 技术债务的天数怎么得出?</p><pre><code>每个规则都有对应的处理时间, 最后:问题类型1数目 * 对应时间 + 问题类型2数目 * 对应时间 +... 得到时间。</code></pre><h3 id="SonarQube-工作流程"><a href="#SonarQube-工作流程" class="headerlink" title="SonarQube 工作流程"></a>SonarQube 工作流程</h3><p>SonarQube 并不是简单地将各种质量检测工具的结果（例如 FindBugs，PMD 等）直接展现给客户，而是通过不同的插件算法来对这些结果进行再加工，最终以量化的方式来衡量代码质量，从而方便地对不同规模和种类的工程进行相应的代码质量管理。</p><p>SonarQube 在进行代码质量管理时，会从图 1 所示的七个纬度来分析项目的质量。</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/image001.png" alt="图 1"></p><p>SonarQube 不是那种安装即可用的工具，他需要数据库的支持，用于存储检测项目后的分析数据，同时为了实现可持续监测，还需要项目持续集成工具（如Jenkins）的支持，在构建版本前，通过Jenkins+Sonar 插件执行项目分析指令，最终的结果会通过SonarQube 服务器的Web 页面展示。</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/image4.png" alt="网络图"></p><p>下面我们就通过mysql+Jenkins+SonarQube 实现项目代码质量的可持续监测</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/SQ55Integration.png" alt=""></p><h2 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h2><h3 id="SonarQube-的安装"><a href="#SonarQube-的安装" class="headerlink" title="SonarQube 的安装"></a>SonarQube 的安装</h3><h4 id="涉及到的知识点"><a href="#涉及到的知识点" class="headerlink" title="涉及到的知识点"></a>涉及到的知识点</h4><ul><li>XCTool工具</li><li>OClint工具</li><li>Gcovr工具</li><li>Git, SVN命令</li><li>Linux 命令</li><li>mysql 操作</li><li>Jenkins工具</li><li>Sonar工具</li><li>Shell语法</li><li>Sonar-runner工具</li></ul><h4 id="软件及硬件的要求"><a href="#软件及硬件的要求" class="headerlink" title="软件及硬件的要求"></a>软件及硬件的要求</h4><p>SonarQube 的安装通常需要满足一定的软硬件条件，具体要求如下所示：</p><ol><li><p>Server 要求</p><p> Web server 最少需要 500MB 的内存空间，推荐内存空间大小 2GB。Sonar 在进行代码质量分析时，通常大约每 1 KLOC 需要存储 350KB 左右的数据，所以要尽量为 SonarQube 的 web server 提供大的内存。</p></li><li><p>Database 要求</p><p> 尽管 SonarQube 本身自带嵌入的 Derby 数据库，但是由于 Derby 比较简单，所以在生产环境中强烈推荐安装相应的企业版数据库，SonarQube 支持的数据库包括： MySQL 5.x+、Oracle10g+、PostgreSQL 9.x 和 MS SQLServer 2005 and 2008，推荐使用 MySQL。</p></li><li><p>Browser 要求</p><p> SonarQube 支持大多数的浏览器，包括 Firefox、Internet Explorer 7.x and 8.x and chromed 等，推荐使用 chromed。</p><p> <del>目前官方最新的版本是6.2，但是对于部分插件会存在不兼容的问题，导致Sonar 服务启动失败，所以为了使用和演示，我采用了旧版本4.5.7，因为此版本兼容 sonar-objective-c-plugin-0.3.1 插件。</del></p><p> <strong>更新：</strong></p><p> 关于XCode8的兼容方案, 请看<a href="https://my.oschina.net/ChenTF/blog/806565" target="_blank" rel="noopener">这篇文章</a></p></li></ol><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol><li><p>数据库配置</p><p> 进入数据库命令模式或者直接使用GUI 工具，创建Sonar-Qube 服务所需的数据库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci; </span><br><span class="line">mysql&gt; CREATE USER &apos;sonar&apos; IDENTIFIED BY &apos;sonar&apos;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;%&apos; IDENTIFIED BY &apos;sonar&apos;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;sonar&apos;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p> <img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/init-sql.png" alt="创建数据库"></p><p> 完成以后测试一下连接是否正确</p></li><li><p>安装SonarQube 与SonarQube-Runner</p><p> SonarQube Runner 2.4 <a href="https://docs.sonarqube.org/display/SONARQUBE45/Installing+and+Configuring+SonarQube+Runner" target="_blank" rel="noopener">下载地址</a></p><p> 从官网下载 SonarQube 的最新版本并解压到<code>/usr/local/</code>文件夹    </p><p> <img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/sonar-install-2.png" alt="SonarQube"></p><p> 添加SONAR_HOME、SONAR_RUNNER_HOME 环境变量，并将SONAR_RUNNER_HOME 加入PATH</p></li><li><p>修改Sonar-Qube 配置文件</p><p> 配置文件路径在 <code>./conf/sonar.properties</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 设置数据库的账户密码</span><br><span class="line">sonar.jdbc.username=ua</span><br><span class="line">sonar.jdbc.password=pwd</span><br><span class="line"></span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</span><br><span class="line"></span><br><span class="line"># By default, ports will be used on all IP addresses associated with the server.</span><br><span class="line">sonar.web.host=0.0.0.0</span><br><span class="line"></span><br><span class="line"># The default value is root context (empty value).</span><br><span class="line">sonar.web.context=/</span><br><span class="line"># TCP port for incoming HTTP connections. Default value is 9000.</span><br><span class="line">sonar.web.port=9003</span><br></pre></td></tr></table></figure></li><li><p>运行如下命令启动 Sonar-Qube，根据操作系统选择</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Last login: Wed Feb 15 18:15:05 on ttys000</span><br><span class="line">localhost:~ tianyi$ /usr/local/sonarqube-6.2/bin/macosx-universal-64/sonar.sh start</span><br><span class="line"></span><br><span class="line">localhost:~ tianyi$ /usr/local/sonarqube-6.2/bin/macosx-universal-64/sonar.sh start</span><br><span class="line">Starting SonarQube...</span><br><span class="line">Started SonarQube.</span><br></pre></td></tr></table></figure></li><li><p>创建一个简单的工程</p><p> 默认密码是admin：admin，登陆管理员账号以后，配置系统参数</p><p> 创建一个Demo 工程</p><p> <img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/make-new1.png" alt="创建一个工程"></p><p> Demo 工程简介</p><p> <img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/make-demo.png" alt="Demo 工程简介"></p><p> 因为还没有进行过分析，所以Demo 暂时只能配置，在使用篇我们会详细介绍如果通过指令或自动化执行分析审查。</p></li><li><p>安装一些必备插件，都可以从官网或者github 上搜索到</p><p> Sonar支持多种插件，插件的下载地址为：<a href="http://docs.codehaus.org/display/SONAR/Plugin+Library" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Plugin+Library</a></p><p> 将下载后的插件上传到${SONAR_HOME}extensions\plugins目录下，重新启动sonar。</p></li></ol><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><p>（注意版本号兼容性问题）</p><ul><li>SonarQube 汉化包：<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="noopener">https://github.com/SonarQubeCommunity/sonar-l10n-zh</a></li><li>Objective-C 代码检查：<a href="https://github.com/octo-technology/sonar-objective-c" target="_blank" rel="noopener">https://github.com/octo-technology/sonar-objective-c</a></li><li>JavaScript 代码检查：<a href="http://docs.codehaus.org/display/SONAR/JavaScript+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/JavaScript+Plugin</a></li><li>python 代码检查：<a href="http://docs.codehaus.org/display/SONAR/Python+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Python+Plugin</a></li><li>Web页面检查（HTML、JSP、JSF、Ruby、PHP等）：<a href="http://docs.codehaus.org/display/SONAR/Web+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Web+Plugin</a></li><li>xml文件检查：<a href="http://docs.codehaus.org/display/SONAR/XML+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/XML+Plugin</a></li><li>scm源码库统计分析：<a href="http://docs.codehaus.org/display/SONAR/SCM+Stats+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/SCM+Stats+Plugin</a></li><li>文件度量：<a href="http://docs.codehaus.org/display/SONAR/Tab+Metrics+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Tab+Metrics+Plugin</a></li><li>中文语言包：<a href="http://docs.codehaus.org/display/SONAR/Chinese+Pack" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Chinese+Pack</a></li><li>时间表显示度量结果：<a href="http://docs.codehaus.org/display/SONAR/Timeline+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Timeline+Plugin</a></li><li>度量结果演进图：<a href="http://docs.codehaus.org/display/SONAR/Motion+Chart+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Motion+Chart+Plugin</a></li></ul><h4 id="我的资源"><a href="#我的资源" class="headerlink" title="我的资源"></a>我的资源</h4><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/commonly-used1.png" alt=""></p><h2 id="使用篇"><a href="#使用篇" class="headerlink" title="使用篇"></a>使用篇</h2><h3 id="使用SonarQube-Runner分析源码"><a href="#使用SonarQube-Runner分析源码" class="headerlink" title="使用SonarQube Runner分析源码"></a>使用SonarQube Runner分析源码</h3><h4 id="预置条件"><a href="#预置条件" class="headerlink" title="预置条件"></a>预置条件</h4><p>已安装SonarQube Runner且环境变量已配置，即sonar-runner命令可在任意目录下执行</p><p>如何配置环境变量，参考<a href="http://www.cnblogs.com/caowei/p/mac-path_2013-08-26.html" target="_blank" rel="noopener">这篇文章</a></p><h4 id="如何分析"><a href="#如何分析" class="headerlink" title="如何分析"></a>如何分析</h4><p><strong>1. 在项目源码的根目录下创建sonar-project.properties配置文件</strong></p><p>以iOS 项目为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Required metadata</span><br><span class="line">sonar.projectKey=iOS::Demo</span><br><span class="line">sonar.projectName=iOS::Demo</span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line"></span><br><span class="line"># Comma-separated paths to directories with sources (required)</span><br><span class="line">sonar.sources=Demo</span><br><span class="line"></span><br><span class="line"># Language</span><br><span class="line">sonar.language=objectivec</span><br><span class="line"></span><br><span class="line"># Encoding of the source files</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br></pre></td></tr></table></figure><p><strong>注意：sonar.language 和安装的代码审查插件有关，需要安装 sonar-objective-c 插件，否则运行时会提示无法找到这个语言</strong></p><p><strong>2. 执行分析</strong></p><p>在项目的根目录执行分析指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/sonar-runner-2.4/bin/sonar-runner</span><br></pre></td></tr></table></figure><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/sonar-ext.png" alt="执行分析指令"></p><p>查看Sonar 分析的结果</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/sonar-ext-result.png" alt="分析结果"></p><p>以上是创建Demo 工程后，通过手动执行分析指令完成代码审查分析。</p><h3 id="与Jenkins-持续集成"><a href="#与Jenkins-持续集成" class="headerlink" title="与Jenkins 持续集成"></a>与Jenkins 持续集成</h3><h4 id="构建前操作"><a href="#构建前操作" class="headerlink" title="构建前操作"></a>构建前操作</h4><p>在jenkins的插件管理中选择安装SonarQube-Scanner，该插件可以使项目每次构建都调用sonar进行代码度量。</p><p>进入配置页面对sonar插件进行配置，如下图：</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/jenkins-goujian.png" alt="新增构建前操作"></p><p>以上配置可以使项目在构建前，自动执行代码审查和分析，结果会自动保存并上传到数据库，通过Sonar 服务器展示给开发者。</p><h4 id="设置触发器"><a href="#设置触发器" class="headerlink" title="设置触发器"></a>设置触发器</h4><p>每5分钟检查一次仓库，若有上库，则自动执行代码检测</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/jenkins-chufa.png" alt="设置触发器"></p><p>至此，通过Sonar 初步构建代码持续审查的工作完成。</p><h2 id="问题篇"><a href="#问题篇" class="headerlink" title="问题篇"></a>问题篇</h2><h3 id="安装中的问题"><a href="#安装中的问题" class="headerlink" title="安装中的问题"></a>安装中的问题</h3><ol><li><p>资源找寻的问题</p><p> 文中提到的资源文件，网上谷歌百度都用上，也找了很久，包括一些插件的问题，必须安装的就是 Sonar-Qube，Runner 其实不必要安装，因为Jenkins 里有插件，可以直接使用。</p></li><li><p>环境配置问题</p><p> 如果不常用指令的话，可以不配置，直接通过绝对路径做操作，环境配置的方法参考<a href="http://www.cnblogs.com/caowei/p/mac-path_2013-08-26.html" target="_blank" rel="noopener">这篇文章</a></p></li><li><p>初始化时遇到Sorry 的问题</p><p> 遇到这种问题可以去根目录 /log/xx.log 中查看日志，具体问题具体解决</p><p> <img src="http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/qa-3.png" alt="sorry"></p></li><li><p>汉化包的问题</p><p> 如果你不习惯英文的使用，想做一做汉化的事情时，汉化包一定要对，如果有问题会导致服务启动失败。</p><p> 附上：<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="noopener">汉化包下载地址</a></p></li></ol><h3 id="SonarQube-实际使用中遇到的问题及解决方案"><a href="#SonarQube-实际使用中遇到的问题及解决方案" class="headerlink" title="SonarQube 实际使用中遇到的问题及解决方案"></a>SonarQube 实际使用中遇到的问题及解决方案</h3><p>在使用 SonarQube6.2 分析代码质量时，可能会遇到的问题：</p><ol><li><p>Xcode 8 兼容性问题</p><p> 原有的xctool已不支持XCode8, 改用xcodebuild + xcpretty 来替代xctool环节生成对应的产出物。</p><p> 关于XCode8的兼容方案, 请看<a href="https://my.oschina.net/ChenTF/blog/806565" target="_blank" rel="noopener">这篇文章</a></p></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>代码质量管理对提高项目质量意义重大。本文介绍了 SonarQube 的工作原理，并从项目实战的角度讲解了使用 SonarQube 进行项目代码质量管理的流程和注意事项。</p><p>代码规范贵在坚持与执行力，自动审查只是做了提醒的作用，当然根据语言的规则，很多规范在使用者来讲看似不合理或者不好用，有了这个工具，参与者们可以切身感受到团队的成长。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://my.oschina.net/ChenTF/blog/708646" target="_blank" rel="noopener">[实践]iOS Sonar集成流程详解</a></p><p><a href="https://my.oschina.net/ChenTF/blog/806565" target="_blank" rel="noopener">[实践]Sonar Xcode8兼容</a></p><p><a href="http://www.uml.org.cn/rjzl/201312132.asp" target="_blank" rel="noopener">SonarQube代码质量管理平台安装与使用</a></p><p><a href="http://www.cnblogs.com/gao241/p/3190701.html" target="_blank" rel="noopener">配置sonar、jenkins进行持续审查</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xqhcq.com1.z0.glb.clouddn.com/continuous-code-quality-sonarqube-install/Benefits-of-Using-SonarQube-For-Code-Reviews.jpg&quot; alt=&quot;SonarQube&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍篇&quot;&gt;&lt;a href=&quot;#介绍篇&quot; class=&quot;headerlink&quot; title=&quot;介绍篇&quot;&gt;&lt;/a&gt;介绍篇&lt;/h2&gt;&lt;h3 id=&quot;SonarQube-介绍&quot;&gt;&lt;a href=&quot;#SonarQube-介绍&quot; class=&quot;headerlink&quot; title=&quot;SonarQube 介绍&quot;&gt;&lt;/a&gt;SonarQube 介绍&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.sonarqube.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SonarQube&lt;/a&gt; 是一款领先的持续代码质量监控平台，开源在github 上，现在已更新到6.2 版本，star 数量超过 1400+，可以轻松配置在内网服务器，实时监控代码，帮助了解提升提升团队项目代码质量。通过插件机制，SonarQube可以继承不同的测试工具，代码分析工具，以及持续集成工具。&lt;/p&gt;
    
    </summary>
    
      <category term="continue" scheme="https://blog.yuhanle.com/categories/continue/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="Sonar" scheme="https://blog.yuhanle.com/tags/Sonar/"/>
    
      <category term="Quality" scheme="https://blog.yuhanle.com/tags/Quality/"/>
    
  </entry>
  
  <entry>
    <title>见字如面的过去一年</title>
    <link href="https://blog.yuhanle.com/2017/01/22/see-words-as-face/"/>
    <id>https://blog.yuhanle.com/2017/01/22/see-words-as-face/</id>
    <published>2017-01-22T04:29:59.000Z</published>
    <updated>2018-07-05T01:20:36.472Z</updated>
    
    <content type="html"><![CDATA[<p>见字如面，甚是想念。<br><a id="more"></a></p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/see-words-as-face/children-1807511_1920.jpg" alt=""><br></center><p>2016，时间总是如此，过的很快。工作后对于时间的概念只有在白天了，总觉得不够用，上班下班，吃饭睡觉，一如既往的重复重复，就像花钱一样，每一笔微小的开支，累积起来都让人不敢相信。</p><p>跟你在一起的这一年，庸庸碌碌，本该在元旦就跟你告别，没想到一拖就是一个月，从未想过你会走的如此之快，可能是我没太在意，因为你带给我的这是疲惫和不堪，甚至是我至今都不愿接受的未曾改变。</p><p>这个365天，我得到了这些：</p><h2 id="这一年的生活"><a href="#这一年的生活" class="headerlink" title="这一年的生活"></a>这一年的生活</h2><p>在2015 年11月底，女朋友来到了这个我们都很陌生的大都市，接着到了2016 年4月，她开始了正式的工作，小俩口挣得不多，部分房租，部分吃喝，余下的就更少了。</p><p>4月底，我们摆脱了不到20平米的单身公寓，摆脱了隔三差五停电，还得去灌天然气，走很远去买菜的生活，搬到了某小区50+ 平米的一室一厅。没错，房租很贵，足足翻了一倍多，距离我们上班的地方也很远，但这些都不重要，我们都很开心，附近有些朋友，周末可以聚聚，楼下就有菜市场，最总要的是主卧朝南，再也不用宅在冷冰冰的小房间里玩手机了。</p><p>紧接着，5月份最重要的是大学舍友从新疆过来玩，那一天，我们去了七宝，田子坊，在港汇广场吃过饭，夜晚还去了外滩看夜景，回想起来，这是来这个城市以后最好玩的一天。时间比较敢，大家一路上几乎都是跑起来的，为了外滩的夜景，也值。</p><p>接下来的几个月，天气很热，除了周末爬爬山，也就在家待着啃西瓜。</p><p>中秋节假期，我和女友约好去了趟南京，古都南京是个很适合游玩的地方，不仅有很多著名景点，还有很多各色小吃，两天一夜的时间，刚刚好，只是累了些，前同事作为地道的南京人，带我们吃了一遍大排档里的招牌菜，真是流连忘返，因为回去就得马上上班。</p><p>到了10 月，国庆节的假期很长，提前回了趟家，刚好家里的房子装修好，准备搬家呢。前前后后忙活了三四天，接着就一家人带着彩礼，去和女友的家人见面了。说起来也认识近7 年，阻力还好，日久见人心嘛！现在的父母都很开明，我们之间还是比较顺利的，至少彼此还算满意，不会让家里瞎操心。</p><p>国庆节结束后，在郑州见了几个朋友，临走前一直在锅大侠二七店吃了顿火锅，之所以选在这个地方，是因为马上就要坐上火车拜拜了。这顿饭吃起来，大家完全没有好久不见的样子，都在聊着工作，聊着房价，这一年，房价没有骗人，一直在涨。回到上海以后，我就开始着急了，按照我们的家庭条件来讲，首付的问题很大，也是最主要的问题。后来我们还是决定，在房价趋于稳定的11 月份，多次往返两个城市，将此事定了下来。当然还有一件好事，我们领了结婚证，这个意义很大。</p><p>很快，这一年就结束了，17 年元旦，带着女朋友去了趟巴黎春天，买了她向往已久的钻戒，对此毫无概念，30+ 分，虽然没有鹅卵石那么大，但是低调一些，我们都还是很高兴的。在此之前，也订好了17 年3 月份去三亚旅行的事情，顺便拍拍结婚照，准备好了，就该步入婚姻的殿堂了。</p><h2 id="这一年的工作"><a href="#这一年的工作" class="headerlink" title="这一年的工作"></a>这一年的工作</h2><p>原本一个人的项目，15 年底新增了个小伙伴，91 年的研究僧，大家相互学习，工作起来配合也很默契，很满意。</p><p>原有的1.0 版本新增功能，维护了一整年。蓝牙的项目在15 年底就搁置了，三四月份的时候，领导说，可能要继续启动蓝牙的项目，于是我们有加了一个小伙伴，于是3 个男人的小团队就开启了。</p><p>接着就是一个月的蓝牙项目，1.0 版本的更新迭代，内部销售系统的更新迭代，没有深入的学习机会，但是事情多而杂，有做不完的东西。</p><p>很快到了6 月份，1.0 的更新变慢了，更多的时间，我们开始了2.0 的软件研发，相比较而言，2.0 的软件更适合用户，体验提升了不少，但也增大了研发的难度，对技术的要求也高了很多。但是原本计划八九月份发布，没想到到了今天还只是在公测阶段，中间遇到的那些坑，还有需求的变更，简直让人生不如死。</p><p>接着8 月份，一位同事因为个人原因离职了，共事了一年，真的是挺舍不得，公司就像市集，来来往往很多人，谁也不知道回去买谁家的东西。项目仍然如此，同事离职以后，2.0 版本又迎来了大改版，不知道是该高兴还是怎么地，总之，继续改，继续同时维护几个版本，看起来总是那么遥遥无期。</p><p>到了11月份，项目又多了两个，不得不再找一个小伙伴，还好这个行业，资源很多，只是面试起来，找到合适的也挺难，最后要了一个内推的小姑娘，总算是调和了一下我们部门的男女比例，不过年龄惊人，瞬间拉低了公司的平均年龄。</p><p>截止到17 年1 月中旬，2.0 版本终于公测，新增的两个项目也可以拿出来展示，作为研发，不在意评价，有人尊重劳动成果就心满意足。</p><p>以上是这一年的工作，代码没少些，只是多了很多管理经验上的学习和历练。</p><h2 id="这一年的学习"><a href="#这一年的学习" class="headerlink" title="这一年的学习"></a>这一年的学习</h2><p>这块东西很少，因为大部分时间都是在工作嘛~</p><p>中间有一天时间参加了饿了么移动技术分享，在此之前也认识了卓同学，还有冰霜和冬瓜，只见了一次面，本人不善言语，只是听他们聊得多了一些，技术圈的微信群和QQ 群加了不少，每天都能看到有人问有人答，偶尔也会参与讨论。</p><p>具体的项目中，逐渐剥离了各个模块之间的联系，数据库方面也尝试了Realm 和CoreData，做了一些比较和分析，最后选择了后者。</p><p>工作之余也搭建了持续集成平台和远程持续代码审核平台，这些都比较简单，网上的教程看的细致都不会存在什么问题。</p><p>总之，学习的很欠缺。</p><h2 id="下一年的小目标"><a href="#下一年的小目标" class="headerlink" title="下一年的小目标"></a>下一年的小目标</h2><p>健林先生的目标我很欣赏，比如先挣他一个亿。</p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/see-words-as-face/lens-1209823_1920.jpg" alt=""><br></center><ul><li>Swift 一定要玩转，至少要在一个项目中使用Swift 开发</li><li>终身大事要尽早解决</li><li>见更多的朋友</li><li>情商</li></ul><p>2016 年，也并不是毫无收获，应当保持激情，做好每一件事，善待每一个人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;见字如面，甚是想念。&lt;br&gt;
    
    </summary>
    
      <category term="word" scheme="https://blog.yuhanle.com/categories/word/"/>
    
    
      <category term="see a word" scheme="https://blog.yuhanle.com/tags/see-a-word/"/>
    
  </entry>
  
  <entry>
    <title>升级到Xcode8.3之后PackageApplication的问题</title>
    <link href="https://blog.yuhanle.com/2016/12/06/xcrun-error/"/>
    <id>https://blog.yuhanle.com/2016/12/06/xcrun-error/</id>
    <published>2016-12-06T05:03:29.000Z</published>
    <updated>2018-07-05T01:21:04.712Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode升级到8.3后 用命令进行打包 提示下面这个错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: unable to find utility &quot;PackageApplication&quot;, not a developer tool or in PATH</span><br></pre></td></tr></table></figure><a id="more"></a><p>后面根据对比发现新版的Xcode少了这个PackageApplication<br>先去找个旧版的Xcode里面copy一份过来<br>放到下面这个目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/</span><br></pre></td></tr></table></figure><p>然后执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer/</span><br><span class="line">chmod +x /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/PackageApplication</span><br></pre></td></tr></table></figure><p>最后附上PackageApplication下载地址：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1hstjpGS" target="_blank" rel="noopener">https://pan.baidu.com/s/1hstjpGS</a>  密码:jvdv</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xcode升级到8.3后 用命令进行打包 提示下面这个错误&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xcrun: error: unable to find utility &amp;quot;PackageApplication&amp;quot;, not a developer tool or in PATH&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="update" scheme="https://blog.yuhanle.com/tags/update/"/>
    
      <category term="error" scheme="https://blog.yuhanle.com/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>如何设计扫一扫功能才能更优雅</title>
    <link href="https://blog.yuhanle.com/2016/12/04/design-scan-function/"/>
    <id>https://blog.yuhanle.com/2016/12/04/design-scan-function/</id>
    <published>2016-12-04T00:00:00.000Z</published>
    <updated>2018-07-05T01:17:10.148Z</updated>
    
    <content type="html"><![CDATA[<p>当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离<a id="more"></a>。</p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/Thematic1.jpg" alt="Thematic"><br></center><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>正如题图，当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离。</p><p>二维码的使用场景很多，比如添加好友，关注公众号，移动支付，还有很多的某某活动入口，用户无需记住太多信息，拿出手机，轻轻的扫一扫对方的资料就能完成操作；移动支付时代，也是因为这个功能的便捷，才能发展的更普遍，剁起手来也就一瞬间；在商家举办的很多活动中，只需要提供一个二维码图片，再通过朋友圈等社交媒体的疯狂转发，亿万用户都能与商家零距离参与活动，接着二次分享，从而给商家带来蹭蹭蹭的流量。</p><p>然而，以上的种种便捷，都离不开扫一扫这个功能。下面，本人就站在一个刚刚接触此行业的基础上，跟大家聊一聊我脑袋里的扫一扫是如何设计的（如有非议，请艾特我）。</p><h2 id="正正正文"><a href="#正正正文" class="headerlink" title="正正正文"></a>正正正文</h2><h3 id="市场上主导应用是如何做的"><a href="#市场上主导应用是如何做的" class="headerlink" title="市场上主导应用是如何做的"></a>市场上主导应用是如何做的</h3><p>想必接触这个行业的产品和开发人员都了解，无论什么应用，这块的功能应该都是大差不差，条条大路通罗马，但其中的规则，应该都是统一的。</p><p>那我在这里就班门弄斧，顺便体验一下微信的扫一扫功能。</p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/wechat_qrcode_meitu_1.png" alt="该二维码图片由微信APP提供" title="该二维码图片由微信APP提供"><br></center><center><br>该二维码图片由微信APP提供<br></center><p><b>1. 先看一下微信扫描结果</b></p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/wechat_result_meitu_2.png" alt="该图片由微信APP提供" title="该图片由微信APP提供"><br></center><center><br>该图片由微信APP提供<br></center><p>这里因为是本人的二维码，所以下面显示的操作是<code>发消息</code>，如果是陌生人的二维码，就是<code>添加到通讯录</code>。这里可以知道，扫描这个二维码的操作，就是查看该用户的个人资料。那这个二维码里究竟藏有什么信息？我们可以通过其他工具扫描一下结果。</p><p><b>2. 看一下草料扫描结果</b></p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/cli_result.png" alt="该图片由草料二维码提供" title="该图片由草料二维码提供"><br></center><center><br>该图片由草料二维码提供<br></center><p>很显然，这是一个http 的url 链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://weixin.qq.com/r/35zcxLnE_uSFrf2n98nN</span><br></pre></td></tr></table></figure><p>我们先分析一下这url 的大概参数，下面用一个表格来说明：</p><table><thead><tr><th>参数</th><th style="text-align:center">类型</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td><a href="http://weixin.qq.com" target="_blank" rel="noopener">http://weixin.qq.com</a></td><td style="text-align:center">String</td><td style="text-align:right">域名</td></tr><tr><td>r</td><td style="text-align:center">String</td><td style="text-align:right">看起来是路由 表示要查看资料</td></tr><tr><td>35zcxLnE_uSFrf2n98nN</td><td style="text-align:center">String</td><td style="text-align:right">看起来是加密后的能标识用户唯一属性</td></tr></tbody></table><p>值得一提的是，这个url 是真实可以访问的，通过电脑打开会直接跳转到官方网站。可能会有很多人（包括我们的QA人员）提出疑问，如此简单的一个扫码查看资料的功能，为什么要做成一个复杂逻辑的url 超链接呢？</p><p><b>3. UC 扫码结果</b></p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/uc_result.png" alt="该图片由UC提供" title="该图片由UC提供"><br></center><center><br>该图片由UC提供<br></center><p>以上是UC 浏览器扫码的结果，同样是跳转到微信官网，但是与之不同的是，紧接着直接打开微信APP（如果安装微信的话），否则就跳到应用市场告知用户下载微信APP。那这里就可以很好的解释一下，为什么二维码的扫描结果使用url 超链接，因为这样可以更好体验的引导用户，从而提升自身产品的流量，也就是说不管你通过何种方式，什么应用扫码，对于用户来讲，你可以很快速很直观的了解到你扫描的东西是什么，不再是二维码实际意义上的一段字符，从产品的角度来说，也能够保证这块的用户流量流失减少，操作体验上也有很大的提升。</p><h3 id="我们的应用该如何设计"><a href="#我们的应用该如何设计" class="headerlink" title="我们的应用该如何设计"></a>我们的应用该如何设计</h3><p>那这个，跟产品本身的需求有很大关系，但是开发的思路和逻辑都是统一的，类似微信这种超级APP，有各种牛人集思广益，项目中应该是会各种组件化，模块化的设计，拿一个简单的扫一扫功能来说，作为一个模块，在他的功能以及和其他模块之间的耦合性来说，肯定是值得我们借鉴和学些的，当然我没有找到任何相关资料，下面只能按照近期的项目来聊聊我是如何处理的。</p><p><b>1. 二维码扫描的结果必定是一个可以访问的超链接</b></p><p>这个应该是没人反驳的。</p><p>之所以这么定义，有两点优势。第一，用户体验和导流上，可以做到更好，具体上面的分析中也提到，就不再赘述；第二，在研发上，通过超链接，可以很方便的将功能集成到我们的路由模块，当然这里也有其他的方法，不过也同样是为了处理扫码结果来定义的。</p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/router.001.png" alt="路由模块的耦合设计" title="路由模块的耦合设计"><br><br></center><center><br>路由模块的耦合设计<br></center><p>上图中，扫一扫功能通过超链接的形式，可以直接整合到路由模块中，<b>通过scheme 的方式，先将域名 替换成 自定义的scheme，如果路由模块可以处理就丢过去处理，不能处理的情况下，就通过APP 内部的浏览器打开该链接，其他逻辑的操作就丢给web 页面处理，比如引导用户到官网，提醒用户下载应用</b>，等一些错误的处理。</p><p><b>2.为了更好地兼容扫码功能，做一些优化 </b></p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/router.002.png" alt="路由模块的扫码功能优化" title="路由模块的扫码功能优化"><br></center><center>路由模块的扫码功能优化</center><p>这里，我们把一些通用的处理操作，通过类别或者代理协议的方法，按功能分别添加到路由模块中，这种优化不仅优化了扫一扫的功能，也同时优化了其他各模块使用路由模块的逻辑。</p><h3 id="那我们可以开始着手研发了"><a href="#那我们可以开始着手研发了" class="headerlink" title="那我们可以开始着手研发了"></a>那我们可以开始着手研发了</h3><h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><p>Web或其他应用调用XXX应用特定功能，也可以用于应用内部功能跳转</p><h4 id="支持系统"><a href="#支持系统" class="headerlink" title="支持系统"></a>支持系统</h4><p>iOS，Android，H5</p><p>如有因系统特性导致的不一致，在协议中详细列出</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><h5 id="Web端"><a href="#Web端" class="headerlink" title="Web端"></a>Web端</h5><p><a href="http://appwebv2.xxx.cn/" target="_blank" rel="noopener">http://appwebv2.xxx.cn/</a><action>/?parms (开发测试环境为appwebv2test.xxx.cn)</action></p><h5 id="App端"><a href="#App端" class="headerlink" title="App端"></a>App端</h5><p>xxxapp://<action>/?params</action></p><p>Web 调用端需要先判断XXX应用是否已经安装<br>如已安装，则通过xxxapp://调用<br>如未安装，视实际定义及功能，通过web调用或者提示用户下载应用</p><p>App 端需要先通过xxxapp:// 路由</p><p>如果本地已经注册，继续执行</p><p>没有注册，直接通过应用内浏览器打开 Web 页面（需要匹配模板填充必要参数）</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><a href="http://appwebv2.xxx.cn/action/bind/bike/{bikeid}/" target="_blank" rel="noopener">http://appwebv2.xxx.cn/action/bind/bike/{bikeid}/</a>?<font color="red">appversion={version}&amp;platform={platform}&amp;xxxkey={xxxkey}</font></p><p>链接前半部分，由服务器生成，后面红色部分参数需要客户端在不能正常通过路由打开该功能，调用浏览器时拼接在 url 里。</p><p>后面红色部分参数，根据服务器的模板链接匹配填充，然后生成二维码展示。</p><h5 id="必要参数"><a href="#必要参数" class="headerlink" title="必要参数"></a>必要参数</h5><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>action/</td><td>Router</td><td>此路由是action 表示该链接是要实现某功能</td></tr><tr><td>bind</td><td>String</td><td>表示绑定的操作</td></tr><tr><td>bike</td><td>String</td><td>表示要绑定的是车</td></tr><tr><td>bikeid</td><td>String</td><td>需要处理的参数</td></tr></tbody></table><h3 id="功能已经实现"><a href="#功能已经实现" class="headerlink" title="功能已经实现"></a>功能已经实现</h3><p>按照上面的定义和逻辑，扫一扫的功能已经可以据此定义砌砖实现。对于路由的功能，可以本地实现，也可以像蘑菇街那样，通过后台的配置可以随时更改处理操作。</p><p>于是，web 端准备了一个页面，超链接是 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://appwebv2.xxx.cn/action/bind/bike</span><br></pre></td></tr></table></figure><p>生成二维码之前，服务端给了你一个字符串，内容是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://appwebv2.xxx.cn/action/bind/bike/11234/?appversion=&#123;version&#125;&amp;platform=&#123;platform&#125;&amp;xxxkey=&#123;xxxkey&#125;</span><br></pre></td></tr></table></figure><p>客户端根据字符串，通过匹配和填充，生成一个二维码</p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/qr_result.png" alt="生成二维码" title="生成二维码"><br></center><center>生成二维码</center><p>二维码的实际结果就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://appwebv2.xxx.cn/action/bind/bike/11234/?appversion=V1.0&amp;platform=iOS&amp;xxxkey=3a10362d077cd27b5f2c537e1ff2fc48</span><br></pre></td></tr></table></figure><p>至此，通过XXX 应用扫码，就会调用添加车辆的功能。<br>通过第三方APP 扫码的话，会先打开浏览器，web 页面会再通过系统方法先尝试调用XXX 应用，如果不能调起，就提醒用户去商店下载，如果能调起应用，XXX 应用在启动以后，通过路由模块处理，首先跳转到扫一扫界面，然后调用添加车辆的功能，如果路由无法处理这个http 超链接，就会调用浏览器再加载这个web 页面。</p><p>到这里，我脑海里能想到的基本分析完了，如果有更好的想法或建议，请艾特我~ 新浪微博：<a href="http://weibo.com/2621837475/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" rel="noopener">煜寒了</a></p><p>附：<br>文中插入的微信是本人的，处于部分原因，加了马赛克，不能扫描添加。如有兴趣添加好友的朋友，请关注微信公众号Neanother，回复<code>我从掘金来</code>即可收到我的所有联系方式哦~</p><center><br><img src="http://7xqhcq.com1.z0.glb.clouddn.com/Elegant-design-scan-function/nenshuo.jpeg" alt="恁说二维码" title="恁说二维码"><br></center><center>恁说二维码</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离
    
    </summary>
    
      <category term="mobile" scheme="https://blog.yuhanle.com/categories/mobile/"/>
    
    
      <category term="scan" scheme="https://blog.yuhanle.com/tags/scan/"/>
    
  </entry>
  
</feed>
