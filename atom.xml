<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>煜寒了</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yuhanle.com/"/>
  <updated>2018-08-07T06:43:53.850Z</updated>
  <id>https://blog.yuhanle.com/</id>
  
  <author>
    <name>煜寒了</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 fastlane 进行 iOS 打包</title>
    <link href="https://blog.yuhanle.com/2018/08/06/fastlane-say-here/"/>
    <id>https://blog.yuhanle.com/2018/08/06/fastlane-say-here/</id>
    <published>2018-08-06T01:00:00.000Z</published>
    <updated>2018-08-07T06:43:53.850Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://docs.fastlane.tools/img/fastlane_text.png" alt=""></p><p><a href="https://fastlane.tools/" target="_blank" rel="noopener">fastlane</a> 是一个通过简单命令来完成诸如截图、获取证书、编译、导出安装包、提交 iTunesConnect 等一系列操作的工具，它同时支持 iOS 和 Android。 </p><table><thead><tr><th style="text-align:center"></th><th>fastlane</th></tr></thead><tbody><tr><td style="text-align:center">🚀</td><td>Save <strong>hours</strong> every time you push a new release to the store or beta testing service</td></tr><tr><td style="text-align:center">✨</td><td>Integrates with all your existing tools and services (170 actions currently)</td></tr><tr><td style="text-align:center">📖</td><td>100% open source under the MIT license</td></tr><tr><td style="text-align:center">🎩</td><td>Easy setup assistant to get started in a few minutes</td></tr><tr><td style="text-align:center">⚒</td><td>Runs on <strong>your</strong> machine, it’s your app and your data</td></tr><tr><td style="text-align:center">👻</td><td>Integrates with all major CI systems</td></tr><tr><td style="text-align:center">🖥</td><td>Supports iOS, Mac, and Android apps</td></tr><tr><td style="text-align:center">🔧</td><td>Extend and customise <em>fastlane</em> to fit your needs, you’re not dependent on anyone</td></tr><tr><td style="text-align:center">💭</td><td>Never remember any commands any more, just <em>fastlane</em></td></tr><tr><td style="text-align:center">🚢</td><td>Deploy from any computer, including a CI server</td></tr></tbody></table><p>你能够通过简单的方式配置流程进行的顺序，并通过非常简单的命令执行其中的一个流程。当然它的简单并不代表功能也简陋，有开源社区的支持，更新迅速且有很多功能能够满足你的需求。</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/fastlane/2017-12-21-fastlane01.png" alt=""></p><h2 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h2><p>作为公司的 iOS 程序员，少不了在发布应用的时候各种等待。标准的手动发布流程是：编译-&gt;打包上传-&gt;填写应用更新数据-&gt;等待 iTunesConnect 编译-&gt;选择版本发布，整个过程大概需要 30 分钟左右。关键是这个过程就像windows 装系统一样，虽然手动参与的不多，但是要一直守在电脑前等着。</p><p>刚开始用 fastlane，发现其使用和配置还算简单，有开源社区支持，更新迅速功能强大。且相比 jenkins 里的插件，fastlane 可以单独使用，也可以被<strong><a href="https://docs.fastlane.tools/best-practices/continuous-integration/" target="_blank" rel="noopener">多种CI </a></strong>接入。</p><p>程序员这么懒，一定会想办法让他自动化的。后来发现特别懒的 <a href="https://github.com/KrauseFx" target="_blank" rel="noopener">Felix Krause</a> 写的 <a href="https://docs.fastlane.tools/" target="_blank" rel="noopener">Fastlane</a>，Fastlane可以非常快速简单的搭建一个自动化发布服务，并且支持 <code>Android</code>，<code>iOS</code>，<code>MacOS</code>。他可以实现一条命令从<strong>编译</strong>到<strong>选版发布</strong>全程不用干预。作为程序员的你只要一条命令，看集美剧，发布就完成了。截止刚刚 Fastlane 官网上宣称已经为程序员节省了<strong>13,746,550小时+</strong>。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>提交时执行测试（包括单元测试和集成测试）；</li><li>构建并分发内部测试，公开测试版本；</li><li>构建生产版本并上传至 ITC（包括更新配置文件，创建新的屏幕截图，上传应用并提交审核）；</li><li>…</li></ul><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul><li>会编程</li><li>Xcode7+</li><li>Mac OS 10.11+</li></ul><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p><code>fastlane</code> 将如下的工具套件有机地结合起来,从管理证书到单元测试,从编译打包到上传发布,都能通过命令行轻松完成.该套件支持与 <code>Jenkins</code> 和 <code>CocoaPods</code>，<code>xctools</code> 等其他第三方工具的集成,并且能够定义多个通道（lanes）以支持不同的部署目标。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/scan" target="_blank" rel="noopener">scan</a> =&gt; 自动运行测试工具，并且可以生成漂亮的 HTML 报告</li></ul><h3 id="证书，配置文件"><a href="#证书，配置文件" class="headerlink" title="证书，配置文件"></a>证书，配置文件</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/cert" target="_blank" rel="noopener">cert</a> =&gt; 自动创建管理 iOS 代码签名证书</li><li><a href="https://github.com/fastlane/fastlane/tree/master/sigh" target="_blank" rel="noopener">sigh</a> =&gt; 一声叹息啊，这么多年和 <code>Provisioning Profile</code>战斗过无数次。总是有这样那样的问题导致配置文件过期或者失效。<code>sigh</code> 是用来创建、更新、下载、修复 <code>Provisioning Profile</code> 的工具。</li><li><a href="https://github.com/fastlane/fastlane/tree/master/pem" target="_blank" rel="noopener">pem</a> =&gt; 自动生成、更新推送配置文件</li><li><a href="https://github.com/fastlane/fastlane/tree/master/match" target="_blank" rel="noopener">match</a> =&gt; 一个新的证书和配置文件管理工具。我会另写一篇文章专门介绍这个工具。他会所有需要用到的证书传到 git 私有库上，任何需要配置的机器直接用 <code>match</code> 同步回来就不用管证书问题了，小团队福音啊！</li></ul><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/snapshot" target="_blank" rel="noopener">snapshot</a> =&gt; 用 <code>Xcode7</code> 推出的 <code>UI test</code> 功能实现自动化截图</li><li><a href="https://github.com/fastlane/fastlane/tree/master/frameit" target="_blank" rel="noopener">frameit</a> =&gt; 可以把截的图片自动套上一层外边框</li></ul><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/produce" target="_blank" rel="noopener">produce</a> =&gt; 如果你的产品还没在 iTunes Connect(iTC) 或者 Apple Developer Center(ADC) 建立，produce 可以自动帮你完成这些工作</li><li><a href="https://github.com/fastlane/fastlane/tree/master/deliver" target="_blank" rel="noopener">deliver</a> =&gt; 自动上传截图，APP 的元数据，二进制 (ipa) 文件到 iTunes Connect</li></ul><h3 id="TestFlight-管理"><a href="#TestFlight-管理" class="headerlink" title="TestFlight 管理"></a>TestFlight 管理</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/pilot" target="_blank" rel="noopener">pilot</a> =&gt; 管理 <code>TestFlight</code> 的测试用户，上传二进制文件</li><li><a href="https://github.com/fastlane/boarding" target="_blank" rel="noopener">boarding</a> =&gt; 建立一个添加测试用户界面，发给测试者，可自行添加邮件地址，并同步到 <code>iTC</code></li></ul><h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/spaceship" target="_blank" rel="noopener">spaceship</a> =&gt; 为 <code>pilot</code>，<code>boarding</code>和 <code>deliver</code>等工具提供和 iTC 和 ADC 的交互 API。<code>spaceship</code>本来是个独立的项目，后来被 <code>Fastlane</code> 收编进来</li><li><a href="https://github.com/fastlane/fastlane/tree/master/watchbuild" target="_blank" rel="noopener">WatchBuild</a> =&gt; 是一个独立的 iTC 监控工具，开启 <code>WatchBuild</code> 可以监控 iTC 上的文件状态，弹出 MacOS 自带的 Notification</li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/supply#readme" target="_blank" rel="noopener">supply</a> =&gt; 自动上传到 Google Play 工具</li><li><a href="https://github.com/fastlane/fastlane/tree/master/screengrab#readme" target="_blank" rel="noopener">screengrab</a> =&gt; Android 的自动截图工具</li></ul><h2 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h2><p>fastlane 命令是一个流程控制的命令行工具(CLI)，通过内部集成 <code>action</code> 和第三方的 <code>action</code> 完成一系列控制流程。运行 fastlane 命令行工具，会读取当前目录或者 <code>./fastlane</code> 目录下的 <code>Fastfile</code> 配置文件。</p><p>在 <code>Fastfile</code> 中：</p><ul><li><code>action</code> =&gt; Fastlane 中的每一条命令都是一个扩展(action)，上面提到的 <code>deliver</code>，<code>sigh</code>之类的工具本身是 CLI，但是在 Fastlane 中内嵌了对他们支持的 <code>action</code></li><li><code>lane</code> =&gt; Fastlane 中流程的合集，每一个动作即可以是 <code>action</code>，也可以是其他的 <code>lane</code>。语法和 ruby 中的 rake 非常像</li></ul><p>一个简单的发布流程：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:deploy</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 执行 pod instasll</span></span><br><span class="line">  cocoapods</span><br><span class="line">  <span class="comment"># 执行 carthage bootstrap</span></span><br><span class="line">  carthage</span><br><span class="line">  <span class="comment"># 增加build版本号</span></span><br><span class="line">  increment_build_number</span><br><span class="line">  <span class="comment"># 编译代码</span></span><br><span class="line">  gym</span><br><span class="line">  <span class="comment"># 发布到Apple Store</span></span><br><span class="line">  deliver(<span class="symbol">force:</span> <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>如果 ruby 版本满足要求，可以直接在命令行执行以下命令安装 fastlane</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装fastlane</span></span><br><span class="line">sudo gem install -n /usr/<span class="built_in">local</span>/bin fastlane</span><br></pre></td></tr></table></figure><p>使用的环境搭建好了，就可以进行下一步来配置 fastlane </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行默认的初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 项目目录</span><br><span class="line">fastlane init</span><br></pre></td></tr></table></figure><p>如果你的项目只有一个 bundle id 也只有一个开发者账号的话，可以直接遵循官方的步骤配置。否则需要按照官方文档，配置不同参数和环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Aug  7 13:19:59 on ttys000</span><br><span class="line">yuhanle:360qws-G100 yuhanle$ fastlane init</span><br><span class="line">[✔] 🚀 </span><br><span class="line">[✔] Looking for iOS and Android projects in current directory...</span><br><span class="line">[13:33:35]: Created new folder './fastlane'.</span><br><span class="line">[13:33:35]: Detected an iOS/macOS project in the current directory: 'G100.xcworkspace'</span><br><span class="line">[13:33:35]: -----------------------------</span><br><span class="line">[13:33:35]: --- Welcome to fastlane 🚀 ---</span><br><span class="line">[13:33:35]: -----------------------------</span><br><span class="line">[13:33:35]: fastlane can help you with all kinds of automation for your mobile app</span><br><span class="line">[13:33:35]: We recommend automating one task first, and then gradually automating more over time</span><br><span class="line">[13:33:35]: What would you like to use fastlane for?</span><br><span class="line">1. 📸  Automate screenshots</span><br><span class="line">2. 👩‍✈️  Automate beta distribution to TestFlight</span><br><span class="line">3. 🚀  Automate App Store distribution</span><br><span class="line">4. 🛠  Manual setup - manually setup your project to automate your tasks</span><br><span class="line">?</span><br></pre></td></tr></table></figure><p>在提问了你的 <code>Apple ID</code>，<code>Team</code> 的问题之后，fastlane 会自动检测当前目录下项目的 <code>App Name</code> 和 <code>App Identifier</code>。如果检测的不对，选择 <code>n</code> 自行输入。</p><p>接下来会问你这个 app 是否需要在 iTC 和 ADC 中创建(上一步中如果选择 <code>y</code> 会自动检测是否需要创建)，fastlane 会调用 <code>produce</code> 进行初始化，如果现在还不想创建，也可以之后再运行 <code>produce init</code> 进行这个流程。如果不执行 <code>produce</code> 的流程，<code>deliver</code> 的流程也会被掠过，当然之后也可以 <code>deliver init</code> 运行完全一样的流程。</p><p>在执行 <code>deliver init</code> 的过程中，会同步 iTC 中的所有语言的元数据和截图，并按照目录结构组织好。目录结构应该类似下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fastlane</span><br><span class="line">├── Appfile</span><br><span class="line">├── Deliverfile</span><br><span class="line">├── Fastfile</span><br><span class="line">├── metadata</span><br><span class="line">│   ├── copyright.txt</span><br><span class="line">│   ├── en-US</span><br><span class="line">│   │   ├── description.txt</span><br><span class="line">│   │   ├── keywords.txt</span><br><span class="line">│   │   ├── marketing_url.txt</span><br><span class="line">│   │   ├── name.txt</span><br><span class="line">│   │   ├── privacy_url.txt</span><br><span class="line">│   │   ├── release_notes.txt</span><br><span class="line">│   │   └── support_url.txt</span><br><span class="line">│   ├── primary_category.txt</span><br><span class="line">│   ├── primary_first_sub_category.txt</span><br><span class="line">│   ├── primary_second_sub_category.txt</span><br><span class="line">│   ├── secondary_category.txt</span><br><span class="line">│   ├── secondary_first_sub_category.txt</span><br><span class="line">│   ├── secondary_second_sub_category.txt</span><br><span class="line">│   └── zh-Hans</span><br><span class="line">│       ├── description.txt</span><br><span class="line">│       ├── keywords.txt</span><br><span class="line">│       ├── marketing_url.txt</span><br><span class="line">│       ├── name.txt</span><br><span class="line">│       ├── privacy_url.txt</span><br><span class="line">│       ├── release_notes.txt</span><br><span class="line">│       └── support_url.txt</span><br><span class="line">└── screenshots</span><br><span class="line">    ├── README.txt</span><br><span class="line">    ├── en-US</span><br><span class="line">    │   ├── 一堆png图片</span><br></pre></td></tr></table></figure><p>这里肯定会被创建的是 <code>Appfile</code> 和 <code>Fastfile</code>。如果 <code>Deliverfile</code>，<code>screenshots</code> 和 <code>metadata</code> 目录没被创建，可以运行 <code>deliver init</code> 来创建。</p><ul><li>Fastfile =&gt; 用来定义所有的 lane 任务 <a href="https://github.com/fastlane/fastlane/tree/master/fastlane/docs#fastfile" target="_blank" rel="noopener">Fastfile帮助</a></li><li>Appfile =&gt; 是用来存储一些公共信息的，比如 <code>app_identifier</code>，<code>apple_id</code>，<code>team_id</code>，<code>itc_team_id</code>等。<a href="https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Appfile.md" target="_blank" rel="noopener">Appfile帮助</a></li><li>Deliverfile =&gt; <code>deliver</code> 的配置文件 <a href="https://github.com/fastlane/fastlane/blob/master/deliver/Deliverfile.md" target="_blank" rel="noopener">Deliverfile帮助</a></li></ul><p><strong>PS</strong>:</p><ol><li>这里有个小问题，iTC 和 ADC 中的 <code>Team ID</code> 是不一样的，在 <code>fastlane init</code> 中只会自动在 Appfile 里写入 ADC 的 <code>team_id</code>，所以在这个过程中会不停的问你 iTC 的 <code>Team ID</code>，所以在创建完 Appfile 后，手动在里面添加 <code>itc_team_id</code>。</li><li>这个问答对不同的项目可能有各种各样的分支。我已经用不同的项目试过很多次了，但是可能还不是全部，所以你还需要见招拆招。</li><li>在这里可以安心的输入密码，所有的密码都加密保存在系统的 Keychain 里。</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/fastlane/QQ20180807-133643@2x.png" alt=""></p><p>fastlane 可以通过配置  .env 文件、Appfile、Deliverfile、Fastfile 来完成各种工作。</p><p>其中 Fastfile 是最核心的用来控制流程走向的配置文件，.env 和 Appfile 可以辅助 Fastfile 来设置一些参数，Deliverfile 可用于配置提交 iTunesConnect 的一些参数。</p><p>需要查看，样例配置可直接前往<a href="http://devhy.com/2018/01/23/26-fastlane-usage/#%E4%B8%8B%E8%BD%BD%E6%A0%B7%E4%BE%8B%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">下载样例配置</a></p><h4 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a>Appfile</h4><p>Appfile是用来配置一些类似于 AppleID、BundleID 参数(参数是 fastlane 已经定义好的，新增的并没有用，如果想新增变量需要使用 .env 方式)，可以在 Fastfile 中使用，AppleID、BundleID 等其实会被一些 actions 直接调用，并不需要写出来传递。</p><h5 id="普通配置方式"><a href="#普通配置方式" class="headerlink" title="普通配置方式"></a>普通配置方式</h5><p>直接在 Appfile 里填写 app_identifier、apple_id、team_id 等，然后根据 lane 的不同可以设置成不同。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认配置</span></span><br><span class="line">app_identifier <span class="string">"com.xxxxxxxxxx.test"</span></span><br><span class="line">apple_id <span class="string">"xxxxxxxxxx@xxxx.com"</span></span><br><span class="line">team_id <span class="string">"xxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果lane是ent换成Dev的配置</span></span><br><span class="line">for_lane <span class="symbol">:ent</span> <span class="keyword">do</span></span><br><span class="line">  app_identifier <span class="string">"com.xxxxxxxxxx.testDev"</span></span><br><span class="line">  apple_id <span class="string">"xxxxxxxxxx@xxxx.com"</span></span><br><span class="line">  TEAM_ID <span class="string">"xxxxxxxxxx"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="使用-env-配置方式"><a href="#使用-env-配置方式" class="headerlink" title="使用 .env 配置方式"></a>使用 .env 配置方式</h5><p><a href="https://docs.fastlane.tools/advanced/#environment-variables" target="_blank" rel="noopener">.env</a> 这个文件的作用是作为环境变量的配置文件，在 fastlane init 进行初始化后并不会自动生成，如果需要可以自己创建。</p><p>执行时默认会读取 <code>.env</code> 和 <code>.env.default</code> 文件里的配置。通过执行 <code>fastlane [lane-name] --env [envName]</code> 来指定使用配置文件 <code>.env.[envName]</code>，读取顺序是 <code>.env -&gt; .env.default -&gt; .env.&lt;envName&gt;</code>，相同的变量名会被后面的覆盖。</p><p>如我建了文件 .env.myDev，里面写了一些参数，那在执行的时候使用 <code>fastlane [lane-name] --env myDev</code> 即可，想在 Appfile、Deliverfile、Fastfile 等调用，直接使用 <code>ENV[&#39;keyName&#39;]</code> 即可</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .env.myDev文件</span></span><br><span class="line"><span class="comment"># bundle id</span></span><br><span class="line">App_Identifier = <span class="string">"com.xxxxxxxxxx.testDev"</span></span><br><span class="line"><span class="comment"># 开发者账号</span></span><br><span class="line">Apple_Id = <span class="string">"xxxxxxxxxx@xxxx.com"</span></span><br><span class="line"><span class="comment"># 开发者TeamId</span></span><br><span class="line">Team_Id  = <span class="string">"xxxxxxxxxx"</span></span><br><span class="line"><span class="comment"># project的target scheme名称</span></span><br><span class="line">Scheme   = <span class="string">"xxxxxxxxxx"</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Appfile使用.env方式直接读取变量即可</span></span><br><span class="line">app_identifier ENV[<span class="string">'App_Identifier'</span>]</span><br><span class="line">apple_id  ENV[<span class="string">'Apple_Id'</span>]</span><br><span class="line">team_id ENV[<span class="string">'Team_Id'</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：因为是 .env 文件是.开头文件，默认是在 finder 中隐藏的，需要通过执行一下命令来显示</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置隐藏文件可见</span></span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles TRUE</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启finder服务以生效</span></span><br><span class="line">killall Finder</span><br></pre></td></tr></table></figure><h5 id="配置方式对比"><a href="#配置方式对比" class="headerlink" title="配置方式对比"></a>配置方式对比</h5><ul><li>普通配置方式：简单易懂，但不能自定义变量，且每个 lane 想不一样都要写一个 for_lane</li><li>.env 配置方式：功能性强，但配置起来稍微麻烦一点</li></ul><h4 id="Fastfile"><a href="#Fastfile" class="headerlink" title="Fastfile"></a>Fastfile</h4><p>Fastfile 是对流程进行控制的核心文件，需要设定支持的平台和在一些环节里需要做的事情，是我们脚本的入口，所有的事件驱动都是在这个文件来调度的。</p><h5 id="Lane"><a href="#Lane" class="headerlink" title="Lane"></a><a href="https://github.com/fastlane/fastlane/tree/master/lane" target="_blank" rel="noopener">Lane</a></h5><p>有了 <code>Fastfile</code>，就可以添加自己的发布流程了。打开Fastfile文件(这里我用Sublime 设定语法为Ruby)，如果不出意外的话你生成的Fastfile和我应该差不多。这里我就不贴出来了。</p><p>最开始定义了</p><ul><li><code>fastlane_version</code> =&gt; 指定fastlane最小版本</li><li><code>default_platform</code> =&gt; 指定当前平台，可选 <code>ios,android,mac</code></li></ul><p>在 <code>platform</code> 中就是需要修改的重点。先忽略 <code>before_all</code>，<code>after_all</code>，<code>error</code> 这些方法，这里的 <code>lane</code> 就是一组任务，上传到 Firim 的任务如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:to_firim</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 如果你用 pod install 注意参数 -&gt; 否则会出错</span></span><br><span class="line">  cocoapods(<span class="symbol">use_bundle_exec:</span> <span class="literal">false</span>)</span><br><span class="line">  <span class="comment"># 如果你没有申请adhoc证书，sigh会自动帮你申请，并且添加到Xcode里</span></span><br><span class="line">  sigh(<span class="symbol">adhoc:</span> <span class="literal">true</span>)</span><br><span class="line">  <span class="comment"># 以下两个action来自fastlane-plugin-versioning，</span></span><br><span class="line">  <span class="comment"># 第一个递增 Build，第二个设定Version。</span></span><br><span class="line">  <span class="comment"># 如果你有多个target，就必须指定target的值，否则它会直接找找到的第一个plist修改</span></span><br><span class="line">  <span class="comment"># 在这里我建议每一个打的包的Build都要不一样，这样crash了拿到日志，可以对应到ipa上</span></span><br><span class="line">  increment_build_number_in_plist(<span class="symbol">target:</span> [target_name])</span><br><span class="line">  increment_version_number_in_plist(</span><br><span class="line">    <span class="symbol">target:</span> [target_name],</span><br><span class="line">    <span class="symbol">version_number:</span> <span class="string">'7.1.3'</span></span><br><span class="line">    )</span><br><span class="line">  <span class="comment"># gym用来编译ipa</span></span><br><span class="line">  gym(</span><br><span class="line">    <span class="symbol">output_directory:</span> <span class="string">'./firim'</span>,</span><br><span class="line">    <span class="symbol">export_options:</span> &#123;</span><br><span class="line">      <span class="symbol">method:</span> <span class="string">"ad-hoc"</span>, <span class="comment"># 这可以不指定</span></span><br><span class="line">      <span class="symbol">thinning:</span> <span class="string">"&lt;none&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    )</span><br><span class="line">  <span class="comment"># 上传ipa到fir.im服务器，在fir.im获取firim_api_token</span></span><br><span class="line">  firim(<span class="symbol">firim_api_token:</span> [firim_api_token])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="Sigh"><a href="#Sigh" class="headerlink" title="Sigh"></a><a href="https://github.com/fastlane/fastlane/tree/master/sigh" target="_blank" rel="noopener">Sigh</a></h5><p>如果你不确定证书目前是否可用，可以用 Sigh 自动生成获取证书。Sigh 会自动根据 Appfile 里设置的 <code>app_identifier</code>从 ADC (苹果开发者中心)生成证书，并下载到项目根目录下(不是 fastlane 目录)，下载后自动安装。你可以通过指定 <code>output_path</code> 指定证书下载位置。</p><p>PS：建议不要把这个文件夹同步到项目的 git 中( Fastlane 提供了 <code>match</code> 专门管理所有证书)。可以在 .gitignore 中可以忽略这个文件夹。</p><p>Sigh 常用的配置项：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>adhoc</td><td>bool</td><td>获取adhoc证书</td><td>fasle</td></tr><tr><td>development</td><td>bool</td><td>更新开发证书，不更新<code>production</code>证书</td><td>false</td></tr><tr><td>force</td><td>bool</td><td>强制更新证书，不管证书是否在ADC中存在</td><td>false</td></tr></tbody></table><p>iOS 里 code 打包证书有 4 种，adhoc，inhouse，appstore，development 证书。</p><table><thead><tr><th></th><th>价格</th><th>AppStore 证书</th><th>In-House 证书</th><th>AdHoc 证书</th><th>Development 证书</th></tr></thead><tbody><tr><td>企业帐户</td><td>$299</td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>公司账号</td><td>$99</td><td>√</td><td></td><td>√</td><td>√</td></tr><tr><td>个人账户</td><td>$99</td><td>√</td><td></td><td>√</td><td>√</td></tr></tbody></table><p>其中 <code>In-House</code> 的方式打包的ipa安装没有设备的限制。<code>AdHoc</code> 打包的 ipa 必须提前把设备的 UDID 添加到证书中，并且有 100 台设备限制。</p><p>所以如果你不指定 <code>adhoc</code> 为 <code>true</code>，Sigh 会识别帐户类型，企业帐户默认生成 <code>In-House</code> 证书，公司账号和个人帐户默认生成 AppStore 证书。</p><h5 id="Gym"><a href="#Gym" class="headerlink" title="Gym"></a><a href="https://github.com/fastlane/fastlane/tree/master/gym" target="_blank" rel="noopener">Gym</a></h5><p>Gym 常用配置项：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>scheme</td><td>string</td><td>指定需要编译的scheme</td><td></td></tr><tr><td>clean</td><td>bool</td><td>是否在编译前clean</td><td>false</td></tr><tr><td>output_directory</td><td>string</td><td>导出目录</td><td><code>./</code></td></tr><tr><td>output_name</td><td>string</td><td>导出ipa名字</td><td>[app_name].ipa</td></tr><tr><td>export_options</td><td>hash/string</td><td>这里指定Xcode API的外部配置文件地址，或者配置hash，见下文</td><td></td></tr><tr><td>export_method</td><td>string</td><td>打包方式，可选项<code>app-store</code> <code>ad-hoc`</code>package<code></code>enterprise<code>development</code>developer-id`</td><td>如果在fastlane中使用了sigh，这个值会从上下文获取</td></tr><tr><td>include_bitcode</td><td>bool</td><td>是否开启<code>bitcode</code></td><td>Xcode API 默认值为true</td></tr><tr><td>include_symbols</td><td>bool</td><td>是否生成符号表</td><td>Xcode API 默认值为true</td></tr></tbody></table><p>Xcode7 之后，Xcode API 允许我们指定一个 <code>plist</code> 文件作为额外的配置文件。gym 默认会帮你创建这个文件，你可以直接指定配置。更多关于 plist 可配置项，执行 <code>xcodebuild -help</code> 查看 <code>Available keys for -exportOptionsPlist</code>。</p><p><code>export_method</code>， <code>include_symbols</code>，和 <code>include_bitcode</code>  这些参数都是 <code>exportOptionsPlist</code> 的配置，对应 <code>method</code>，<code>uploadSymbols</code> 和 <code>uploadBitcode</code>。</p><p>Gym 可以指定配置文件 <a href="https://github.com/fastlane/fastlane/tree/master/gym#gymfile" target="_blank" rel="noopener"><code>Gymfile</code></a>。 </p><p>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gym init</span><br></pre></td></tr></table></figure><h4 id="Multi-Target"><a href="#Multi-Target" class="headerlink" title="Multi-Target"></a>Multi-Target</h4><p>如果我们需要配置多个 target 进行打包的话，我们可以使用 <a href="https://link.juejin.im?target=https%3A%2F%2Fdocs.fastlane.tools%2Fadvanced%2F%23environment-variables" target="_blank" rel="noopener">环境变量</a>，来进行配置。假如我们现在有两个 <code>target</code>，<code>targetA</code> 和 <code>targetB</code>，则我们需要创建两个 <code>.env</code> 文件，例如 <code>.env.targetA</code>，<code>.env.targetB</code>，放在 <code>Fastfile</code> 文件同级目录下</p><p>在 <code>.env</code> 文件里面我们可以配置一些不同的内容（非公共），比如 <code>app_identifier</code>，<code>release_notes</code> 等等。截图如下：</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/fastlane/QQ20180807-142523@2x.png" alt=""></p><p>在 <code>Appfile</code>，<code>Deliverfile</code>，<code>Fastfile</code> 等文件，我们都可以直接使用 <code>.env</code> 文件里面的内容。</p><p>Appfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Appfile</span><br><span class="line"></span><br><span class="line">#The bundle identifier of your app</span><br><span class="line">app_identifier ENV[&apos;APP_IDENTIFIER&apos;]</span><br><span class="line"></span><br><span class="line"># Your Apple email address</span><br><span class="line">apple_id ENV[&apos;APPLE_ID&apos;] </span><br><span class="line"></span><br><span class="line"># Developer Portal Team ID</span><br><span class="line">team_id ENV[&apos;TEAM_ID&apos;]</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Deliverfile，<strong>请在设置 release_nores、support_url、private_url 等配置的时候，采用 hash 的方式写。</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app_identifier</span></span><br><span class="line">app_identifier ENV[<span class="string">'APP_IDENTIFIER'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户名,Apple ID电子邮件地址</span></span><br><span class="line">username ENV[<span class="string">'APPLE_ID'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 团队ID</span></span><br><span class="line">team_id ENV[<span class="string">'TEAM_ID'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 团队name</span></span><br><span class="line">team_name ENV[<span class="string">'TEAM_NAME'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># copyright</span></span><br><span class="line">copyright ENV[<span class="string">'COPYRIGHT'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字</span></span><br><span class="line">keywords(</span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'KEYWORDS'</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新版本修改记录</span></span><br><span class="line">release_notes(</span><br><span class="line"><span class="comment"># 中国</span></span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'RELEASE_NOTES'</span>],</span><br><span class="line"><span class="comment"># 澳大利亚</span></span><br><span class="line"><span class="string">'en-au'</span> =&gt; ENV[<span class="string">'RELEASE_NOTES_AU'</span>],</span><br><span class="line"><span class="comment"># 美国</span></span><br><span class="line"><span class="string">'en-us'</span> =&gt; ENV[<span class="string">'RELEASE_NOTES_US'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持网址</span></span><br><span class="line">support_url(</span><br><span class="line"><span class="comment"># 中国</span></span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'SUPPORT_URL'</span>],</span><br><span class="line"><span class="comment"># 澳大利亚</span></span><br><span class="line"><span class="string">'en-au'</span> =&gt; ENV[<span class="string">'SUPPORT_URL_AU'</span>],</span><br><span class="line"><span class="comment"># 美国</span></span><br><span class="line"><span class="string">'en-us'</span> =&gt; ENV[<span class="string">'SUPPORT_URL_US'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐私政策网址 国家代码 https://www.cnblogs.com/Mien/archive/2008/08/22/1273950.html</span></span><br><span class="line">privacy_url(</span><br><span class="line"><span class="comment"># 中国</span></span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'PRIVACY_URL'</span>],</span><br><span class="line"><span class="comment"># 澳大利亚</span></span><br><span class="line"><span class="string">'en-au'</span> =&gt; ENV[<span class="string">'PRIVACY_URL_AU'</span>],</span><br><span class="line"><span class="comment"># 美国</span></span><br><span class="line"><span class="string">'en-us'</span> =&gt; ENV[<span class="string">'PRIVACY_URL_US'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传完成后提交新版本进行审查</span></span><br><span class="line">submit_for_review <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过HTML报告文件验证</span></span><br><span class="line">force <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用iTC的分阶段发布功能 灰度发布</span></span><br><span class="line">phased_release <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用审核小组的联系信息 app 审核信息</span></span><br><span class="line">app_review_information(</span><br><span class="line">  <span class="symbol">first_name:</span> <span class="string">"xx"</span>,</span><br><span class="line">  <span class="symbol">last_name:</span> <span class="string">"xx"</span>,</span><br><span class="line">  <span class="symbol">phone_number:</span> <span class="string">"+86 18888888888"</span>,</span><br><span class="line">  <span class="symbol">email_address:</span> <span class="string">"xxxx"</span>,</span><br><span class="line">  <span class="symbol">demo_user:</span> <span class="string">"test1@test.com"</span>,</span><br><span class="line">  <span class="symbol">demo_password:</span> <span class="string">"test123"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="Deliver"><a href="#Deliver" class="headerlink" title="Deliver"></a><a href="https://github.com/fastlane/fastlane/tree/master/deliver" target="_blank" rel="noopener">Deliver</a></h4><p>Deliver 可以完全管理与 iTC 的交互。其中包括：</p><ul><li>上传和下载多语言截图</li><li>上传和下载多语言元数据</li><li>上传二进制文件</li></ul><p>还记得上面<a href="https://whlsxl.github.io/fastlane1/#init" target="_blank" rel="noopener">初始化</a>的时候初始化的 <code>metadata</code>，<code>screenshots</code> 目录么？iTC 中的所有的元数据信息都被保存在 <code>metadata</code> 中，所有的截图信息都被保存在 <code>screenshots</code> 中。</p><p>metadata：</p><ul><li>可以很容易的管理对应目录下的文件和 iTC 后台的表单项，在执行 <code>deliver</code> 时会自动被传到 iTC。</li><li>在 <code>metadata</code> 目录下的文件，如 <code>copyright.txt</code>，是没有本地化的，在二层目录中的文件都是需要对应不同语言的表单项。</li><li>如果你不想修改某些项的信息，直接把对应的文件删除即可。</li><li>所有这些表单项也可以在 <code>Deliverfile</code> 中指定，<code>Deliverfile</code> 中指定的项优先级比文件高</li></ul><p>screenshots：</p><ul><li>如果不想更改截图，可以把整个截图目录删除</li><li>如果不使用 <code>snapshot</code> (自动化截图)，也可以自己截图放到对应目录下，比一张一张上传 iTC 快的多。截图在iTC 中的排列顺序就是本地文件名的「字母表顺序」(在目录中右击，按文件名排序)。<code>deliver</code>会识别图片分辨率，上传到对应设备中。</li></ul><p>如果要通过 <code>deliver</code> 修改元数据或截图，你必须提供所有 iTC 中有的语言。比如后台中有「简体中文」和「英文」，你也必须提供对应的 <code>zh-Hans</code> 和 <code>en-US</code> 文件，否则 <code>deliver</code> 会报缺少语言的错误。可以在 iTC 后台提交的版本中删除语言。</p><p>Deliver 常用配置项：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>ipa</td><td>string</td><td><code>ipa</code>地址</td><td>如果使用<code>gym</code>，可以通过上下文获取</td></tr><tr><td>metadata_path</td><td>string</td><td>指定<code>metadata</code>目录地址</td><td>如果在<code>fastlane</code>中<code>./fastlane/metadata</code>，如果作为独立的命令行应用<code>./metadata</code></td></tr><tr><td>screenshots_path</td><td>string</td><td>指定<code>screenshots</code>目录地址</td><td>如果在<code>fastlane</code>中<code>./fastlane/screenshots</code>，如果作为独立的命令行应用<code>./screenshots</code></td></tr><tr><td>skip_binary_upload</td><td>bool</td><td>跳过二进制文件上传，适用于只想改<code>metadata</code></td><td>false</td></tr><tr><td>skip_screenshots</td><td>bool</td><td>跳过截图上传，如果截图没有变化，开启这项节约时间</td><td>false</td></tr><tr><td>skip_metadata</td><td>bool</td><td>跳过元数据上传</td><td>false</td></tr><tr><td>force</td><td>bool</td><td><code>deliver</code>会在上传时汇总信息生成HTML也，等待你审核。跳过这项审核此项设为<code>true</code></td><td>false</td></tr><tr><td>submit_for_review</td><td>bool</td><td>上传完成是否自动提交审核</td><td>false</td></tr><tr><td>automatic_release</td><td>bool</td><td>审核通过是否自动释放</td><td>false</td></tr><tr><td>price_tier</td><td>int</td><td>App价格级别。<strong>注意：这项提交当时就会生效</strong>，所以更改价格还是在后天手动操作</td><td></td></tr><tr><td>submission_information</td><td>hash</td><td>这是在iTC上点击提交之后的问答表格，<a href="https://github.com/fastlane/fastlane/blob/master/spaceship/lib/spaceship/tunes/app_submission.rb#L18-L69" target="_blank" rel="noopener">可选项</a></td><td></td></tr><tr><td>app_review_information</td><td>hash</td><td>提供审核时的信息，<a href="https://github.com/fastlane/fastlane/blob/master/deliver/Deliverfile.md#app_review_information" target="_blank" rel="noopener">详情</a></td><td></td></tr><tr><td>app_icon</td><td>string</td><td>指定<code>icon</code>图片地址，必须为<code>png</code>格式</td></tr></tbody></table><ul><li><p>submission_information =&gt;</p><ul><li><p>前缀 <code>export_compliance</code> =&gt; 对应「出口合规信息」，没有特殊情况都选 <code>false</code> 就可以。</p></li><li><p>前缀 <code>content_rights</code> =&gt; 问你是否包含，显示，访问第三方内容(这项我没在我提交过程中找到)，没有特殊情况也都选 <code>false</code> 就可以。</p></li><li><p>前缀 <code>add_id_info</code> =&gt; 可就关键了，对应「广告标识符」，如果你在 App 中使用了 <code>IDFA</code>。你必须在这给个理由，而不能直接选 <code>false</code>。</p><p>下图等价下表，App 中投放了广告。</p></li></ul></li></ul><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/fastlane/submission_information.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">submission_information(&#123;</span><br><span class="line">  export_compliance_available_on_french_store: &quot;false&quot;,</span><br><span class="line">  export_compliance_contains_proprietary_cryptography: &quot;false&quot;,</span><br><span class="line">  export_compliance_contains_third_party_cryptography: &quot;false&quot;,</span><br><span class="line">  export_compliance_is_exempt: &quot;false&quot;,</span><br><span class="line">  export_compliance_uses_encryption: &quot;false&quot;,</span><br><span class="line">  export_compliance_app_type: nil,</span><br><span class="line">  export_compliance_encryption_updated: &quot;false&quot;,</span><br><span class="line">  export_compliance_compliance_required: &quot;false&quot;,</span><br><span class="line">  export_compliance_platform: &quot;ios&quot;,</span><br><span class="line">  content_rights_contains_third_party_content: &quot;false&quot;,</span><br><span class="line">  content_rights_has_rights: &quot;false&quot;,</span><br><span class="line">  add_id_info_limits_tracking: &quot;true&quot;,</span><br><span class="line">  add_id_info_serves_ads: &quot;true&quot;,</span><br><span class="line">  add_id_info_tracks_action: &quot;false&quot;,</span><br><span class="line">  add_id_info_tracks_install: &quot;false&quot;,</span><br><span class="line">  add_id_info_uses_idfa: &quot;true&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>deliver</code> 的 <code>CLI</code> 工具：</p><ul><li>下载 iTC 上的截图 <code>deliver download_screenshots</code></li><li><p>下载 iTC 上的元数据  <code>deliver download_metadata</code></p><p>配置完以上的设置，最后只需要一条命令发布</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane ios deploy</span><br></pre></td></tr></table></figure><h2 id="系统级-lane"><a href="#系统级-lane" class="headerlink" title="系统级 lane"></a>系统级 lane</h2><p><code>fastlane</code> 默认有 lane。</p><ul><li><code>before_all</code>，就是在执行一次脚本之前首先执行的代码，我们可以在这里面执行一些公共的东西，比如<code>git_pull</code>，<code>cocoapods</code>。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before_all <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 检出到 Developer 分支</span></span><br><span class="line">  sh <span class="string">'git checkout Developer'</span></span><br><span class="line">  git_pull</span><br><span class="line">  cocoapods(<span class="symbol">repo_update:</span> <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p><code>after_all</code>， 成功结束之后，处理共有的后置逻辑。</p></li><li><p><code>before_each</code>，每次执行 lane 之前都会执行一次。</p></li><li><p><code>after_each</code>，每次执行 lane 之后都会执行一次。</p></li><li><p><code>error</code>，在执行上述情况任意环境报错都会中止并执行一次。</p></li></ul><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><table><thead><tr><th>执行顺序</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>before_all</td><td>在执行 lane 之前只执行一次。</td></tr><tr><td>2</td><td>before_each</td><td>每次执行 lane 之前都会执行一次。</td></tr><tr><td>3</td><td>lane</td><td>自定义的任务。</td></tr><tr><td>4</td><td>after_each</td><td>每次执行 lane 之后都会执行一次。</td></tr><tr><td>5</td><td>after_all</td><td>在执行 lane 成功结束之后执行一次。</td></tr><tr><td>6</td><td>error</td><td>在执行上述情况任意环境报错都会中止并执行一次。</td></tr></tbody></table><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul><li>出现 <code>Command timed out after 10 seconds on try 1 of 4, trying again...</code>，在 <code>fastlane</code> 文件开头加上：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV[<span class="string">"FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"</span>] = <span class="string">"180"</span></span><br><span class="line">ENV[<span class="string">"FASTLANE_XCODE_LIST_TIMEOUT"</span>] = <span class="string">"180"</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Fastlane 的插件是一个或者一组 <code>action</code> 的打包，单独发布在 fastlane 之外。<a href="https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Plugins.md" target="_blank" rel="noopener">Fastlane Plugin 指南</a></p><p>自从 16 年 5 月份推出插件系统以来，现在已经有很多第三方的插件可以使用。查看所有插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane search_plugins</span><br></pre></td></tr></table></figure><p>这里介绍两个下文会用到的插件：</p><ol><li><p>fastlane-plugin-versioning =&gt; 用来修改 build 版本号和 version 版本号。</p><p>Fastlane 内嵌的 action <code>increment_build_number</code>使用的是苹果提供的 <code>agvtool</code>，<code>agvtool</code> 在更改 Build 的时候会改变所有target的版本号。这时如果你在一个工程里有多个产品的话，每次编译，所有的Build都要加1，最后就不知道高到哪里去了。</p><p>有了 <code>fastlane-plugin-versioning</code> 不仅可以指定 target 增加 Build，而且可以按照「<a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>」规范增加 Version，当然也可以直接设定 Version。</p><p>PS：最开始写 iOS 时不知道怎么定义 Build。现在我一般都直接定义成纯数字，比如 100 起,每次编译的时候让他自动加一。</p></li><li><p><a href="https://github.com/whlsxl/firim/tree/master/fastlane-plugin-firim" target="_blank" rel="noopener">fastlane-plugin-firim</a> =&gt; 直接把 AdHoc 或者 InHouse 打包的 ipa 上传到 fir.im，供测试下载。</p></li></ol><p>安装上面的插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastlane add_plugin [name] # 安装方法</span><br><span class="line">fastlane add_plugin versioning</span><br><span class="line">fastlane add_plugin firim</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/5a7b10bb6fb9a0636263bfd5" target="_blank" rel="noopener">iOS 持续交付之 Fastlane</a></p><p><a href="http://devhy.com/2018/01/23/26-fastlane-usage/" target="_blank" rel="noopener">和重复劳动说再见-使用fastlane进行iOS打包</a></p><p><a href="https://whlsxl.github.io/fastlane1/" target="_blank" rel="noopener">小团队的自动化发布－Fastlane带来的全自动化发布</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://docs.fastlane.tools/img/fastlane_text.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://fastlane.tools/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="fastlane" scheme="https://blog.yuhanle.com/categories/fastlane/"/>
    
    
      <category term="fastlane" scheme="https://blog.yuhanle.com/tags/fastlane/"/>
    
  </entry>
  
  <entry>
    <title>梦想虽晚，“码”不停蹄</title>
    <link href="https://blog.yuhanle.com/2018/07/16/dream-late-code-nostop/"/>
    <id>https://blog.yuhanle.com/2018/07/16/dream-late-code-nostop/</id>
    <published>2018-07-16T05:59:43.000Z</published>
    <updated>2018-07-17T01:22:21.725Z</updated>
    
    <content type="html"><![CDATA[<p>以梦为马，不负韶华。</p><p>我羡慕他们的故事，佩服他们的成就，相信很多人会跟我一样为他们的成功喝彩，毕竟这都是些励志的典型，而我在默默呐喊的同时，还有种淡淡的甜蜜，小小的幸福感，因为我也选择了这条路，我会这条路上走很远，这是属于我们的故事，有他，有她，不知道有天会不会有我。</p><p>梦想很遥远，可我们愿马不停蹄的前行，为了梦想而奋斗总是痛苦的，又总是快乐的，我知道，可我来了，这种感觉很幸福。</p><center><br>传送门：<a href="https://latehorse.github.io/" target="_blank" rel="noopener">晚码工作室</a><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以梦为马，不负韶华。&lt;/p&gt;
&lt;p&gt;我羡慕他们的故事，佩服他们的成就，相信很多人会跟我一样为他们的成功喝彩，毕竟这都是些励志的典型，而我在默默呐喊的同时，还有种淡淡的甜蜜，小小的幸福感，因为我也选择了这条路，我会这条路上走很远，这是属于我们的故事，有他，有她，不知道有天会不
      
    
    </summary>
    
      <category term="晚码" scheme="https://blog.yuhanle.com/categories/%E6%99%9A%E7%A0%81/"/>
    
    
      <category term="晚码" scheme="https://blog.yuhanle.com/tags/%E6%99%9A%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>数据序列化框架在 Swift 日常开发中的应用</title>
    <link href="https://blog.yuhanle.com/2018/07/05/json-analysis-in-swift/"/>
    <id>https://blog.yuhanle.com/2018/07/05/json-analysis-in-swift/</id>
    <published>2018-07-05T01:00:00.000Z</published>
    <updated>2018-07-07T01:36:08.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/10498756/42311471-7fec973a-8070-11e8-80cb-cf2719b0ab7a.png" alt="image"></p><p>到了 Swift 年代，第三方库 SwiftyJSON 和 ObjectMapper 都曾经作为 JSON 转换的中流砥柱，只是这两者还是免不了“手动指定字段和JSON字典映射关系”的工作。于是阿里想了个黑科技（<a href="https://github.com/alibaba/HandyJSON" target="_blank" rel="noopener">HandyJSON</a>），通过分析Swift数据结构在内存中的布局，自动分析出映射关系，进一步降低开发者使用的成本。</p><p>如今我们就有多个选择：ObjectMapper、HandyJSON、SwiftyJSON、MJExtension 等</p><p>其实我们在日常开发中，对于 JSON 数据的处理有两大需求：</p><ol><li>json 和 model 互相转换（Android Studio有 Gson format 插件，但Xcode没有类似功能）</li><li>服务端返回的 json 里可能有 null，但是 Swift 语言的空是用 nil 表示，需要空值处理(对象 Optional 类型)</li></ol><h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h2><h3 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h3><p>先看 <a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a> ： Model 类必须实现 Mappable 协议，即实现 init 和 mapping 函数；适合跟 Alamofire 配合。但是 mapping 函数实现起来过于臃肿耗时，只能借助<a href="https://github.com/quicktype/quicktype-xcode" target="_blank" rel="noopener">插件</a>来快速完成。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ObjectMapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonOBM</span>: <span class="title">Mappable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>!</span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span>!</span><br><span class="line">    <span class="keyword">var</span> location: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> three_day_forecast: [<span class="type">ForecastOBM</span>]?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;</span><br><span class="line">        username    &lt;- <span class="built_in">map</span>[<span class="string">"username"</span>]</span><br><span class="line">        age         &lt;- <span class="built_in">map</span>[<span class="string">"age"</span>]</span><br><span class="line">        weight      &lt;- <span class="built_in">map</span>[<span class="string">"weight"</span>]</span><br><span class="line">        sex         &lt;- <span class="built_in">map</span>[<span class="string">"sex"</span>]</span><br><span class="line">        location    &lt;- <span class="built_in">map</span>[<span class="string">"location"</span>]</span><br><span class="line">        three_day_forecast &lt;- <span class="built_in">map</span> [<span class="string">"three_day_forecast"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForecastOBM</span>: <span class="title">Mappable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> conditions: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> day: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;</span><br><span class="line">        conditions      &lt;- <span class="built_in">map</span>[<span class="string">"conditions"</span>]</span><br><span class="line">        day             &lt;- <span class="built_in">map</span>[<span class="string">"day"</span>]</span><br><span class="line">        temperature     &lt;- <span class="built_in">map</span>[<span class="string">"temperature"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://dotnet.ctolib.com/j2s.html" target="_blank" rel="noopener">j2s 是一个 macOS app 能够将 JSON 对象转成 Swift 结构体</a></p><h3 id="HandyJSON"><a href="#HandyJSON" class="headerlink" title="HandyJSON"></a>HandyJSON</h3><p>再看 <a href="https://github.com/alibaba/handyjson" target="_blank" rel="noopener">HandyJSON</a>， 写起来比较方便，类和结构体要求继承于 HandyJSON、枚举要继承于 HandyJSONEnum。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HandyJSON</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonHJ</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>!</span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span>!</span><br><span class="line">    <span class="keyword">var</span> locatoin: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> three_day_forecast: [<span class="type">ForecastHJ</span>]?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForecastHJ</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> conditions: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> day: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比ObjectMapper使用上要简单， 不用写mapping函数那么多代码了。</p><h3 id="SwiftyJSON"><a href="#SwiftyJSON" class="headerlink" title="SwiftyJSON"></a>SwiftyJSON</h3><p>看 <a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener">SwiftyJSON</a>：取字段值使用比较方便， 但是然并卵？ SwiftyJSON 不支持转 Model，如果你只是想要解析某几个字段，那么 SwiftyJSON 是不二选择， 而且适用于 Alamofire。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonString: <span class="type">String</span> = <span class="string">"&#123;\"username\":\"yuhanle\",\"age\":18,\"weight\":65.4,\"sex\":1,\"location\":\"Toronto, Canada\",\"three_day_forecast\":[&#123;\"conditions\":\"Partly cloudy\",\"day\":\"Monday\",\"temperature\":20&#125;,&#123;\"conditions\":\"Showers\",\"day\":\"Tuesday\",\"temperature\":22&#125;,&#123;\"conditions\":\"Sunny\",\"day\":\"Wednesday\",\"temperature\":28&#125;]&#125;"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dataFromString = jsonString.data(using: .utf8, allowLossyConversion: <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSON</span>(data: dataFromString!)</span><br><span class="line">    <span class="built_in">print</span>(json[<span class="string">"username"</span>], json[<span class="string">"weight"</span>], json[<span class="string">"three_day_forecast"</span>][<span class="number">0</span>][<span class="string">"conditions"</span>])</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"Error: <span class="subst">\(error.domain)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MJExtension"><a href="#MJExtension" class="headerlink" title="MJExtension"></a>MJExtension</h3><p>最后看下一下 <a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a>，作为一个从 ObjC 年代就开始流程的转换框架，在如今使用的人仍然很多，但是对于 Swift 的集成却不是特别友好，官方 issue 列表中经常都会有申请支持 swift 的呼声！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MJExtension</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonMJ</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> weight = <span class="number">0.0</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> sex = <span class="literal">false</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> location: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> three_day_forecast: [<span class="type">ForecastMJ</span>]?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForecastMJ</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> conditions: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> day: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> temperature = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管在支持上不是特别友好，但是在自定义 Model 的过程中，应该是最轻松的一款，但是在升级 Swift 4 之后，需要在属性前添加 @objc 才可以正常使用，否则转换失败。具体情况可参考：<a href="https://github.com/CoderMJLee/MJExtension/issues/582" target="_blank" rel="noopener">Swift 4 字典转模型失败</a></p><p>另外还有一种情况，就是关于整型属性，需要给定初试值，也就是说，MJExtension 无法序列化/反序列化整型。解决办法很简单， 就是赋个默认值， 即将Optional整型变为整型就可以。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?   <span class="comment">// 请注意：MJExtension不能解析Optional Int类型</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span> <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行耗时"><a href="#运行耗时" class="headerlink" title="运行耗时"></a>运行耗时</h2><p>我们准备了一小段 JSON 数据，循环解析 10000 次，来分析几大框架的运行耗时：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"yuhanle"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">"weight"</span>: <span class="number">65.4</span>,</span><br><span class="line">    <span class="attr">"sex"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"Toronto, Canada"</span>,</span><br><span class="line">    <span class="attr">"three_day_forecast"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"conditions"</span>: <span class="string">"Partly cloudy"</span>,</span><br><span class="line">            <span class="attr">"day"</span>: <span class="string">"Monday"</span>,</span><br><span class="line">            <span class="attr">"temperature"</span>: <span class="number">20</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"conditions"</span>: <span class="string">"Showers"</span>,</span><br><span class="line">            <span class="attr">"day"</span>: <span class="string">"Tuesday"</span>,</span><br><span class="line">            <span class="attr">"temperature"</span>: <span class="number">22</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"conditions"</span>: <span class="string">"Sunny"</span>,</span><br><span class="line">            <span class="attr">"day"</span>: <span class="string">"Wednesday"</span>,</span><br><span class="line">            <span class="attr">"temperature"</span>: <span class="number">28</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 HandyJSON 为例，在开始处理数据和结束时，记录时间差，时间差的结果每次会有波动</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxCount = <span class="number">10000</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testHandyJSON</span><span class="params">(json: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> people: <span class="type">PersonHJ</span> = <span class="type">PersonHJ</span>()</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;maxCount &#123;</span><br><span class="line">        people = <span class="type">PersonHJ</span>.deserialize(from: json)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> executionTime = <span class="type">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"HandyJSON deserialize time totals: "</span>, executionTime)</span><br><span class="line"></span><br><span class="line">    start = <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;maxCount &#123;</span><br><span class="line">        res = people.toJSONString()!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executionTime = <span class="type">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"HandyJSON toJSONString time totals: "</span>, executionTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终记录得到的结果对比图</p><table><thead><tr><th><strong>测试项</strong></th><th><strong>JSON -&gt; MODEL</strong></th><th><strong>MODEL -&gt; JSON</strong></th></tr></thead><tbody><tr><td>HandyJSON</td><td>3.0839329957962</td><td>4.97446703910828</td></tr><tr><td>ObjeceMapper</td><td>1.40153098106384</td><td>1.2123589515686</td></tr><tr><td>SwiftJSON</td><td>不支持</td><td>不支持</td></tr><tr><td>MJExtension</td><td>0.417935013771057</td><td>0.418874025344849</td></tr></tbody></table><p><img src="https://user-images.githubusercontent.com/10498756/42310902-2010687e-806f-11e8-9365-c3d1a3958677.png" alt="image"></p><p>结果有点出乎意料，HandyJSON 的黑魔法纵然很强大，这也导致了耗时的问题，相比较而言，不太友好的  MJExtension 速度最快。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于应用开发来说，JSON 数据序列化和反序列号的操作必不可少，上述分析的效率和性能问题，也应该多考虑，选择合适的框架很重要，学习和踩坑也是并存的。</p><p>另外，Swift 支持 Codable 协议，对这个需求的处理也有很大的支持！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://medium.com/@jasonyuh/%E5%BA%94%E8%AF%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8codable-f99d6ac5810" target="_blank" rel="noopener">应该什么时候使用Codable</a></li><li><a href="http://www.cnblogs.com/yajunLi/p/7121950.html" target="_blank" rel="noopener">Swift实现JSON转Model - HandyJSON使用讲解</a></li><li><a href="https://blog.csdn.net/brycegao321/article/details/75349045" target="_blank" rel="noopener">iOS JSON序列化/反序列化哪家强？</a></li><li><a href="https://medium.com/@wenchenx/swift-4-codable-%E8%AE%93%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%8A%E5%BE%97%E6%9B%B4%E7%B0%A1%E5%96%AE-73e55042f077" target="_blank" rel="noopener">Swift 4 Codable 讓序列化變得更簡單</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/10498756/42311471-7fec973a-8070-11e8-80cb-cf2719b0ab7a.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;到了 Sw
      
    
    </summary>
    
      <category term="swift" scheme="https://blog.yuhanle.com/categories/swift/"/>
    
    
      <category term="swift" scheme="https://blog.yuhanle.com/tags/swift/"/>
    
      <category term="JSON" scheme="https://blog.yuhanle.com/tags/JSON/"/>
    
      <category term="HandyJSON" scheme="https://blog.yuhanle.com/tags/HandyJSON/"/>
    
  </entry>
  
  <entry>
    <title>Vue 知识点</title>
    <link href="https://blog.yuhanle.com/2018/07/04/vue-tips/"/>
    <id>https://blog.yuhanle.com/2018/07/04/vue-tips/</id>
    <published>2018-07-04T01:00:00.000Z</published>
    <updated>2018-07-07T01:34:52.264Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇枯燥的知识总结，希望在有需要的时候能够找到它！</p><a id="more"></a><h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h2><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p><h3 id="通过对路由route的判断来设置-active-name，open-names"><a href="#通过对路由route的判断来设置-active-name，open-names" class="headerlink" title="通过对路由route的判断来设置 active-name，open-names"></a>通过对路由route的判断来设置 active-name，open-names</h3><p>在使用 <code>menu</code> 组件时，我们需要根据路由的 path 来默认选中某一个 tab，下面给出的就是根据 fullpath 来设置默认 tab 的好方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Menu ref=&quot;left_menu&quot; :theme=&quot;theme2&quot; width=&quot;auto&quot; active-name=&quot;currentPage&quot; :open-names=&quot;openedSubmenuArr&quot; accordion @on-select=&quot;changeMenu&quot;&gt;</span><br><span class="line">……(省略代码)</span><br><span class="line">&lt;/Menu&gt;</span><br><span class="line">……(省略代码)</span><br><span class="line">created() &#123;</span><br><span class="line">    console.log(&quot;router detect:&quot;, this.$route);</span><br><span class="line">    let path = this.$route.fullPath.match(/^\/(.*)\//);</span><br><span class="line">    this.currentPage = this.$route.name;</span><br><span class="line">    this.openedSubmenuArr = [].concat(path);</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.$refs.left_menu.updateOpened();</span><br><span class="line">        this.$refs.left_menu.updateActiveName()</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要有默认子路由，那父路由的名字-name-得去掉"><a href="#要有默认子路由，那父路由的名字-name-得去掉" class="headerlink" title="要有默认子路由，那父路由的名字 name 得去掉"></a>要有默认子路由，那父路由的名字 name 得去掉</h3><p>开发过程中，在配置路由阶段，可能会遇到一下警告提示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vue-router] Named Route <span class="string">'my'</span> has a <span class="keyword">default</span> child route.</span><br><span class="line"><span class="function">When navigating to <span class="keyword">this</span> named <span class="title">route</span> <span class="params">(:to=<span class="string">"&#123;name: 'my'"</span>)</span>, the <span class="keyword">default</span> child route will not be rendered.</span></span><br><span class="line"><span class="function">Remove the name from <span class="keyword">this</span> route and use the name of the <span class="keyword">default</span> child route <span class="keyword">for</span> named links instead.</span></span><br></pre></td></tr></table></figure><p>虽然仅仅是警告，不影响功能和显示，但是依然要解决它，避免新的问题产生。警告提示的大概意思是 <strong><code>要有默认子路由，那父路由的名字name得去掉</code></strong>，也就是说在 子路由 里如有有默认路由的话，父路由不需要设置 <code>name</code> 字段。具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/admin'</span>, <span class="comment">// =&gt; 注意父路由此处不设置 name 字段</span></span><br><span class="line">      component: Admin,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/'</span>,  <span class="comment">// =&gt; 默认路由</span></span><br><span class="line">          redirect: <span class="string">'/admin/index'</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>很多情况下，我们需要在访问某个页面之前，先做一次关于 session 的检查，如果不存在 session 的话，跳转至认证页面，就需要使用如下这个钩子函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (store.getters.token.length === <span class="number">0</span> &amp;&amp; to.path !== <span class="string">'/login'</span>) &#123;</span><br><span class="line">    next(<span class="string">'/login'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也有很多情况下，比如在加载页面过程中，顶部加载进度条，我们可以根据钩子，在开始加载时加入进度显示，路由结束时隐藏就行。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>在很多人看来，前端开发的痛点，就是状态管理，页面之间传值会导致代码的高度耦合，在接触 Vue 的过程中，自然是要了解 Vuex 的使用。类似于 redux 和 Mobx 以及 Flux 的概念，具体使用细节只要按照官方文档和教程操作就行。以下记录中间需要注意和了解的知识点：</p><h3 id="一个小示例"><a href="#一个小示例" class="headerlink" title="一个小示例"></a>一个小示例</h3><p>我们先从一个小示例开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着，我们可以在业务方，通过 Action 的 dispatch 方法来调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&apos;increment&apos;, ...)</span><br></pre></td></tr></table></figure><p>另外一点需要注意的是，组合 Action 的时候，官方不建议使用异步，但是根据实测结果，异步调用目前没有发现什么问题。</p><p>来看一个更加实际的购物车示例，涉及到<strong>调用异步 API</strong> 和<strong>分发多重 mutation</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="mapState-amp-mapGetters"><a href="#mapState-amp-mapGetters" class="headerlink" title="mapState &amp; mapGetters"></a>mapState &amp; mapGetters</h3><p>作为 Vuex 的辅助方法，可以简化我们在业务中对 store 的引用，不必再写很多繁琐的映射。这里有一点需要在意的是：</p><p>如果你有使用 modules 使用多个模块，在调用 state 的时候，需要使用 <code>store.state.xxx.yyy</code>，其中 <code>xxx</code> 是模块名，也可以自定义模块名，<code>yyy</code> 就是 state 中定义的字段名；而在使用 getters 的时候，不管存在多少 modules，都是直接使用 <code>store.getters.yyy</code> 的方式来获取。</p><p>另外，Vuex 不仅仅提供状态同步和保存，更多时候可以作为 filter 来过滤处理脏数据，业务方无需关心原始数据，通过接口和参数，获取到自己想要的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇枯燥的知识总结，希望在有需要的时候能够找到它！&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://blog.yuhanle.com/categories/Vue/"/>
    
    
      <category term="知识点" scheme="https://blog.yuhanle.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>RAC 在 MVVM 中的常见用法</title>
    <link href="https://blog.yuhanle.com/2018/05/13/rac-in-mvvm/"/>
    <id>https://blog.yuhanle.com/2018/05/13/rac-in-mvvm/</id>
    <published>2018-05-13T01:00:00.000Z</published>
    <updated>2018-08-06T07:44:01.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>在 iOS 开发中，或多或少都会见过 RAC 的身影，它为提高开发效率而生，在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。如果你还没有接触 RAC，建议你工作之余稍作研究，并尝试体验一下。</p><p>关于 RAC 的解释，官方的说，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>（其简称为RAC）是由 GitHub 开源的一个应用于 iOS 和 OS X 开发的新框架，其具有 <a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">函数式编程</a> 和 <a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">响应式编程</a> 的特性。</p><p>这是摘自花瓣网工程师博客的一幅图，可以直观的看到各个类之间的关系</p><p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/rac/FRP_ReactiveCocoa_large.png" alt=""></p><p>接下来，我们就结合 RAC 中的类以及实际使用场景，来描述一下他的基本用法：</p><ul><li>RACSignal</li><li>RACSubject</li><li>RACSequence</li><li>RACMulticastConnection</li><li>RACCommand</li><li>RAC 常用宏</li><li>RAC-bind</li><li>RAC-过滤</li><li>RAC-映射</li><li>RAC-组合</li></ul><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p><strong>信号类</strong>，Signal 是 RAC 中的核心概念。当数据改变时，信号内部就会收到数据，然后发出。<strong>但是默认一个信号是冷信号</strong>，当一个信号没有订阅者（Subscriber）时它什么也不干，就像我们的函数，当一个函数写好之后并没有被调用它也什么都不会干。信号可以通过以下三种方式发送事件给订阅者。</p><p>详细介绍参考：<a href="https://draveness.me/racdelegateproxy" target="_blank" rel="noopener">从代理到 RACSignal</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="comment">// 3.发送信号</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"ws"</span>];</span><br><span class="line">    <span class="comment">// 4.取消信号</span></span><br><span class="line">    <span class="comment">// 如果信号想要被取消，就必须返回一个RACDisposable</span></span><br><span class="line">    <span class="comment">// 信号什么时候被取消：</span></span><br><span class="line">    <span class="comment">// 1.自动取消，当一个信号的订阅者被销毁的时候机会自动取消订阅，</span></span><br><span class="line">    <span class="comment">// 2.手动取消，</span></span><br><span class="line">    <span class="comment">// block什么时候调用：一旦一个信号被取消订阅就会调用</span></span><br><span class="line">    <span class="comment">// block作用：当信号被取消时用于清空一些资源</span></span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取消订阅"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 订阅信号</span></span><br><span class="line"><span class="comment">// subscribeNext</span></span><br><span class="line"><span class="comment">// 把nextBlock保存到订阅者里面</span></span><br><span class="line"><span class="comment">// 只要订阅信号就会返回一个取消订阅信号的类</span></span><br><span class="line">RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">// block的调用时刻：只要信号内部发出数据就会调用这个block</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>信号类的作用：</p><ol><li>只要有数据改变就会把数据包装成信号传递出去</li><li>只要有数据改变就会有信号发出</li><li>数据发出，并不是信号类发出，信号类不能发送数据</li></ol><p>实现思路：</p><ol><li><p>当一个信号被订阅，创建订阅者，并把 nextBlock 保存到订阅者里面</p></li><li><p>创建的时候会返回 [RACDynamicSignal createSignal:didSubscribe];</p></li><li><p>调用 RACDynamicSignal 的 didSubscribe</p></li><li><p>发送信号 [subscriber sendNext:value];</p></li><li><p>拿到订阅者的 nextBlock 调用</p></li></ol><h4 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h4><p>RACSubject 在使用中我们可以完全代替代理/通知，来简化代码。</p><p><strong>(可变的信号）：</strong> 可以连接RAC代码与非RAC代码，可以接收和主动发送信号。看了很多介绍都不推荐使用。目前我只把他当作代理使用了一下。</p><p>详细介绍参考：<a href="https://draveness.me/racsubject" target="_blank" rel="noopener">『可变』的热信号 RACSubject</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建信号</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 订阅信号</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">// block:当有数据发出的时候就会调用</span></span><br><span class="line">    <span class="comment">// block:处理数据</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发送信号</span></span><br><span class="line">[subject sendNext:value];</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>RACSubject 和 RACReplaySubject 的区别</li><li>RACSubject 必须要先订阅信号之后才能发送信号， 而 RACReplaySubject 可以先发送信号后订阅.</li><li>RACSubject 代码中体现为：先走TwoViewController的 sendNext，后走 ViewController 的 subscribeNext 订阅</li><li>RACReplaySubject 代码中体现为：先走 ViewController 的 subscribeNext 订阅，后走 TwoViewController 的sendNext 可按实际情况各取所需。</li></ol><h4 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h4><p>详细介绍参考：<a href="https://draveness.me/racsequence" target="_blank" rel="noopener">Pull-Driven 的数据流 RACSequence</a></p><p>使用场景： 可以快速高效的遍历数组和字典。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:path];</span><br><span class="line">    [dictArr.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>也可以使用宏</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"key"</span>:@<span class="number">1</span>, <span class="string">@"key2"</span>:@<span class="number">2</span>&#125;;</span><br><span class="line">[dict.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    <span class="built_in">NSString</span> *key = x[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *value = x[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// RACTupleUnpack宏：专门用来解析元组</span></span><br><span class="line">    <span class="comment">// RACTupleUnpack 等会右边：需要解析的元组 宏的参数，填解析的什么样数据</span></span><br><span class="line">    <span class="comment">// 元组里面有几个值，宏的参数就必须填几个</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *key, <span class="built_in">NSString</span> *value) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, key, value);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h4><p>当有多个订阅者，但是我们只想发送一个信号的时候怎么办？这时我们就可以用 RACMulticastConnection，来实现。</p><p>详细介绍参考：<a href="https://draveness.me/racconnection" target="_blank" rel="noopener">用于多播的 RACMulticastConnection</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通写法, 这样的缺点是：每订阅一次信号就得重新创建并发送请求，很不友好</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="comment">// didSubscribeblock 中的代码都统称为副作用</span></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"发送请求啦"</span>);</span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"ws"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐做法。 使用RACMulticastConnection，无论有多少个订阅者，无论订阅多少次，只发送一个</span></span><br><span class="line"><span class="comment">// 1.发送请求，用一个信号内包装，不管有多少个订阅者，只想发一次请求</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"发送请求啦"</span>);</span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"ws"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//2. 创建连接类</span></span><br><span class="line">RACMulticastConnection *connection = [signal publish];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//3. 连接。只有连接了才会把信号源变为热信号</span></span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure><h4 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h4><p>RACCommand：RAC 中用于处理事件的类，可以把事件如何处理，事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程，比如看事件有没有执行完毕，详细介绍参考：<a href="https://draveness.me/raccommand" target="_blank" rel="noopener">优雅的 RACCommand</a></p><p><code>RACCommand</code> 是一个在 ReactiveCocoa 中比较复杂的类，大多数使用 ReactiveCocoa 的人，尤其是初学者并不会经常使用它。</p><p>在很多情况下，虽然使用 <code>RACSignal</code> 和 <code>RACSubject</code> 就能解决绝大部分问题，但是 <code>RACCommand</code> 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。</p><p>使用场景：监听按钮点击，异步网络请求</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通做法</span></span><br><span class="line"><span class="comment">// RACCommand: 处理事件</span></span><br><span class="line"><span class="comment">// 不能返回空的信号</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">//block调用，执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input); <span class="comment">// input 为执行命令传进来的参数</span></span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"执行命令产生的数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何拿到执行命令中产生的数据呢？</span></span><br><span class="line"><span class="comment">// 订阅命令内部的信号</span></span><br><span class="line"><span class="comment">// ** 方式一：直接订阅执行命令返回的信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">RACSignal *signal =[command execute:@<span class="number">2</span>]; </span><br><span class="line">    <span class="comment">// 这里其实用到的是replaySubject 可以先发送命令再订阅</span></span><br><span class="line">    <span class="comment">// 在这里就可以订阅信号了</span></span><br><span class="line">    [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般做法</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">//block调用，执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input); <span class="comment">// input 为执行命令传进来的参数</span></span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"执行命令产生的数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line"><span class="comment">// 注意：这里必须是先订阅才能发送命令</span></span><br><span class="line"><span class="comment">// executionSignals：信号源，信号中信号，signalofsignals:信号，发送数据就是信号</span></span><br><span class="line">[command.executionSignals subscribeNext:^(RACSignal *x) &#123;</span><br><span class="line">    [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">[command execute:@<span class="number">2</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级做法</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">// block调用：执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input);</span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"发送信号"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="comment">// switchToLatest获取最新发送的信号，只能用于信号中信号。</span></span><br><span class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">[command execute:@<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switchToLatest--用于信号中信号</span></span><br><span class="line"><span class="comment">// 创建信号中信号</span></span><br><span class="line">RACSubject *signalofsignals = [RACSubject subject];</span><br><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line">[signalofsignals subscribeNext:^(RACSignal *x) &#123;</span><br><span class="line">   [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// switchToLatest: 获取信号中信号发送的最新信号</span></span><br><span class="line">[signalofsignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[signalofsignals sendNext:signalA];</span><br><span class="line">[signalA sendNext:@<span class="number">4</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听事件有没有完成</span></span><br><span class="line"><span class="comment">// 注意：当前命令内部发送数据完成，一定要主动发送完成</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">// block调用：执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input);</span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"执行命令产生的数据"</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *** 发送完成 **</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 监听事件有没有完成</span></span><br><span class="line">[command.executing subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123; </span><br><span class="line">        <span class="comment">// 正在执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"当前正在执行%@"</span>, x);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行完成/没有执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行完成/没有执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">[command execute:@<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><h4 id="RAC-常用宏"><a href="#RAC-常用宏" class="headerlink" title="RAC 常用宏"></a>RAC 常用宏</h4><p>RAC 有许多强大而方便的宏。如下代码所示</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RAC: 把一个对象的某个属性绑定一个信号，只要发出信号，就会把信号的内容给对象的属性赋值</span></span><br><span class="line"><span class="comment">// 给 label 的 text 属性绑定了文本框改变的信号</span></span><br><span class="line">RAC(<span class="keyword">self</span>.label, text) = <span class="keyword">self</span>.textField.rac_textSignal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上述同样功能</span></span><br><span class="line">[<span class="keyword">self</span>.textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">self</span>.label.text = x;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* KVO</span></span><br><span class="line"><span class="comment">* RACObserveL: 快速的监听某个对象的某个属性改变</span></span><br><span class="line"><span class="comment">* 返回的是一个信号，对象的某个属性改变的信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[RACObserve(<span class="keyword">self</span>.view, center) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例 textField 输入的值赋值给label，监听 label 文字改变</span></span><br><span class="line">RAC(<span class="keyword">self</span>.label, text) = <span class="keyword">self</span>.textField.rac_textSignal;</span><br><span class="line">[RACObserve(<span class="keyword">self</span>.label, text) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"label的文字变化"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 循环引用问题</span></span><br><span class="line"><span class="comment">* 使用 @weakify(self) 和 @strongify(self) 来避免循环引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.view);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">_signal = signal;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 元祖</span></span><br><span class="line"><span class="comment">* 快速包装一个元组</span></span><br><span class="line"><span class="comment">* 把包装的类型放在宏的参数里面，就会自动包装</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RACTuple *tuple = RACTuplePack(@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 宏的参数类型要和元祖中元素类型一致，右边为要解析的元祖</span></span><br><span class="line">RACTupleUnpack_(<span class="built_in">NSNumber</span> *num1, <span class="built_in">NSNumber</span> *num2, <span class="built_in">NSNumber</span> * num3) = tuple;</span><br><span class="line"><span class="comment">// 4.元祖</span></span><br><span class="line"><span class="comment">// 快速包装一个元组</span></span><br><span class="line"><span class="comment">// 把包装的类型放在宏的参数里面，就会自动包装</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %@ %@"</span>, num1, num2, num3);</span><br></pre></td></tr></table></figure><h4 id="RAC-bind"><a href="#RAC-bind" class="headerlink" title="RAC-bind"></a>RAC-bind</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建信号</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"><span class="comment">// 2.绑定信号</span></span><br><span class="line">RACSignal *bindSignal = [subject bind:^RACStreamBindBlock&#123;</span><br><span class="line">    <span class="comment">// block调用时刻：只要绑定信号订阅就会调用。</span></span><br><span class="line">    <span class="keyword">return</span> ^RACSignal *(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">        <span class="comment">// 一般在这个block中做事 ，发数据的时候会来到这个block。</span></span><br><span class="line">        <span class="comment">// 只要源信号（subject）发送数据，就会调用block</span></span><br><span class="line">        <span class="comment">// block作用：处理源信号内容</span></span><br><span class="line">        <span class="comment">// value:源信号发送的内容，</span></span><br><span class="line">        value = @<span class="number">3</span>; <span class="comment">// 如果在这里把 value 的值改了，那么订阅绑定信号的值的 x 就变了</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"接受到源信号的内容：%@"</span>, value);</span><br><span class="line">        <span class="comment">// 返回信号，不能为nil,如果非要返回空---则empty或 alloc init。</span></span><br><span class="line">        <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:value]; <span class="comment">// 把返回的值包装成信号</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.订阅绑定信号</span></span><br><span class="line">[bindSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到绑定信号处理完的信号:%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 4.发送信号</span></span><br><span class="line">[subject sendNext:<span class="string">@"123"</span>];</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>bind（绑定）的使用思想和 Hook 的一样 —&gt; 都是拦截 API 从而可以对数据进行操作，而影响返回数据</li></ol><h4 id="RAC-过滤"><a href="#RAC-过滤" class="headerlink" title="RAC-过滤"></a>RAC-过滤</h4><p>有时候我们想要过滤一些信号，这时候我们便可以用 RAC 的过滤方法。过滤方法有好多种，如下代码，从不同情况下进行了分析。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳跃 ： 如下，skip传入 2 跳过前面两个值</span></span><br><span class="line"><span class="comment">// 实际用处： 在实际开发中比如 后台返回的数据前面几个没用，我们想跳跃过去，便可以用skip</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject skip:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// distinctUntilChanged: -- 如果当前的值跟上一次的值一样，就不会被订阅到</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject distinctUntilChanged] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>]; <span class="comment">// 不会订阅到</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// take: 可以屏蔽一些值，去掉前面几个值---这里 take 为2 则只拿到前两个值</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject take:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>]; <span class="comment">// 不会订阅到</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//takeLast:和take的用法一样，不过他取的是最后的几个值，如下，则取的是最后两个值</span></span><br><span class="line"><span class="comment">//注意点:takeLast 一定要调用sendCompleted，告诉他发送完成了，这样才能取到最后的几个值</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject takeLast:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>]; <span class="comment">// 不会订阅到</span></span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br><span class="line">[subject sendCompleted];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// takeUntil: 给 takeUntil 传的是哪个信号，那么当这个信号发送信号或 sendCompleted，就不能再接受源信号的内容</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">RACSubject *subject2 = [RACSubject subject];</span><br><span class="line">[[subject takeUntil:subject2] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject2 sendNext:@<span class="number">3</span>];  <span class="comment">// 1</span></span><br><span class="line">[subject2 sendCompleted]; <span class="comment">// 或2</span></span><br><span class="line">[subject sendNext:@<span class="number">4</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ignore: 忽略掉一些值</span></span><br><span class="line"><span class="comment">// ignore:忽略一些值</span></span><br><span class="line"><span class="comment">// ignoreValues:表示忽略所有的值</span></span><br><span class="line"><span class="comment">// 1.创建信号</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"><span class="comment">// 2.忽略一些值</span></span><br><span class="line">RACSignal *ignoreSignal = [subject ignore:@<span class="number">2</span>]; <span class="comment">// ignoreValues:表示忽略所有的值</span></span><br><span class="line"><span class="comment">// 3.订阅信号</span></span><br><span class="line">[ignoreSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 4.发送数据</span></span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般和文本框一起用，添加过滤条件</span></span><br><span class="line"><span class="comment">// 只有当文本框的内容长度大于 5，才获取文本框里的内容</span></span><br><span class="line">[[<span class="keyword">self</span>.textField.rac_textSignal filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="comment">// value 源信号的内容</span></span><br><span class="line">    <span class="keyword">return</span> [value length] &gt; <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 返回值 就是过滤条件。只有满足这个条件才能获取到内容</span></span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="RAC-映射"><a href="#RAC-映射" class="headerlink" title="RAC-映射"></a>RAC-映射</h4><p>RAC的映射在实际开发中有什么用呢？比如我们想要拦截服务器返回的数据，给数据拼接特定的东西或想对数据进行操作从而更改返回值，类似于这样的情况下，我们便可以考虑用 RAC 的映射，实例代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)map &#123;</span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 绑定信号</span></span><br><span class="line">    RACSignal *bindSignal = [subject map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">// 返回的类型就是你需要映射的值</span></span><br><span class="line">        <span class="comment">// 这里将源信号发送的“123” 前面拼接了 ws：</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ws:%@"</span>, value]; </span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 订阅绑定信号</span></span><br><span class="line">    [bindSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [subject sendNext:<span class="string">@"123"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)flatMap &#123;</span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 绑定信号</span></span><br><span class="line">    RACSignal *bindSignal = [subject flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">// block：只要源信号发送内容就会调用</span></span><br><span class="line">        <span class="comment">// value: 就是源信号发送的内容</span></span><br><span class="line">        <span class="comment">// 返回信号用来包装成修改内容的值</span></span><br><span class="line">        <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flattenMap 中返回的是什么信号，订阅的就是什么信号</span></span><br><span class="line">    <span class="comment">// (那么 x 的值等于 value 的值，如果我们操纵 value 的值那么 x 也会随之而变)</span></span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    [bindSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    [subject sendNext:<span class="string">@"123"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)flattenMap2 &#123;</span><br><span class="line">    <span class="comment">// flattenMap 主要用于信号中的信号</span></span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    RACSubject *signalofSignals = [RACSubject subject];</span><br><span class="line">    RACSubject *signal = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    <span class="comment">//方式1</span></span><br><span class="line">    [signalofSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    [signalofSignals.switchToLatest];</span><br><span class="line">    <span class="comment">// 方式3</span></span><br><span class="line">    RACSignal *bignSignal = [signalofSignals flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">//value: 就是源信号发送内容</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;];</span><br><span class="line">    [bignSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 方式4 也是开发中常用的</span></span><br><span class="line">    [[signalofSignals flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [signalofSignals sendNext:signal];</span><br><span class="line">    [signal sendNext:<span class="string">@"123"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RAC-组合"><a href="#RAC-组合" class="headerlink" title="RAC-组合"></a>RAC-组合</h4><p>把多个信号聚合成你想要的信号</p><p>使用场景：当多个输入框都有值的时候，按钮状态可点击</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把输入框输入值的信号都聚合成按钮是否能点击的信号</span></span><br><span class="line">- (<span class="keyword">void</span>)combineLatest &#123;</span><br><span class="line">    RACSignal *combinSignal = [RACSignal combineLatest:@[<span class="keyword">self</span>.accountField.rac_textSignal, <span class="keyword">self</span>.pwdField.rac_textSignal] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *pwd)&#123; </span><br><span class="line">        <span class="comment">//reduce里的参数一定要和combineLatest数组里的一一对应。</span></span><br><span class="line">    <span class="comment">// block: 只要源信号发送内容，就会调用，组合成一个新值。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, account, pwd);</span><br><span class="line">    <span class="keyword">return</span> @(account.length &amp;&amp; pwd.length);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line">[combinSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">self</span>.loginBtn.enabled = [x boolValue];</span><br><span class="line">&#125;];    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这样写有些麻烦，可以直接用RAC宏</span></span><br><span class="line">    RAC(<span class="keyword">self</span>.loginBtn, enabled) = combinSignal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)zipWith &#123;</span><br><span class="line">    <span class="comment">// zipWith:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时</span></span><br><span class="line">    <span class="comment">// 并且把两个信号的内容合并成一个元祖，才会触发压缩流的next事件。</span></span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSubject *signalA = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSubject *signalB = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 压缩成一个信号</span></span><br><span class="line">    <span class="comment">// **-zipWith-**: 当一个界面多个请求的时候，要等所有请求完成才更新UI</span></span><br><span class="line">    <span class="comment">// 等所有信号都发送内容的时候才会调用</span></span><br><span class="line">    RACSignal *zipSignal = [signalA zipWith:signalB];</span><br><span class="line">    [zipSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="comment">//所有的值都被包装成了元组</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x); </span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号 交互顺序，元组内元素的顺序不会变，跟发送的顺序无关，</span></span><br><span class="line">    <span class="comment">// 而是跟压缩的顺序有关 [signalA zipWith:signalB] --- 先是 A 后是 B</span></span><br><span class="line">    [signalA sendNext:@<span class="number">1</span>];</span><br><span class="line">    [signalB sendNext:@<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何一个信号请求完成都会被订阅到</span></span><br><span class="line"><span class="comment">// merge: 多个信号合并成一个信号，任何一个信号有新值就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)merge &#123;</span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSubject *signalA = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSubject *signalB = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 组合信号</span></span><br><span class="line">    RACSignal *mergeSignal = [signalA merge:signalB];</span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    [mergeSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 发送信号---交换位置则数据结果顺序也会交换</span></span><br><span class="line">    [signalB sendNext:<span class="string">@"下部分"</span>];</span><br><span class="line">    [signalA sendNext:<span class="string">@"上部分"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// then 使用需求：有两部分数据：想让上部分先进行网络请求但是过滤掉数据，然后进行下部分的，拿到下部分数据</span></span><br><span class="line">- (<span class="keyword">void</span>)then &#123;</span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"上部分数据"</span>];</span><br><span class="line">        [subscriber sendCompleted]; <span class="comment">// 必须要调用sendCompleted方法！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"下部分数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 创建组合信号</span></span><br><span class="line">    <span class="comment">// then;忽略掉第一个信号的所有值</span></span><br><span class="line">    RACSignal *thenSignal = [signalA then:^RACSignal *&#123;</span><br><span class="line">        <span class="comment">// 返回的信号就是要组合的信号</span></span><br><span class="line">        <span class="keyword">return</span> signalsB;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    [thenSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// concat 使用需求：有两部分数据：想让上部分先执行，完了之后再让下部分执行（都可获取值）</span></span><br><span class="line">- (<span class="keyword">void</span>)concat &#123;</span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"上部分数据"</span>];</span><br><span class="line">        [subscriber sendCompleted]; <span class="comment">// 必须要调用sendCompleted方法！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"下部分数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat: 按顺序去链接</span></span><br><span class="line">    <span class="comment">//**-注意-**：concat，第一个信号必须要调用sendCompleted</span></span><br><span class="line">    <span class="comment">// 创建组合信号</span></span><br><span class="line">    RACSignal *concatSignal = [signalA concat:signalsB];</span><br><span class="line">    <span class="comment">// 订阅组合信号</span></span><br><span class="line">    [concatSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>究其本质核心就是各种 signals，也就是bind（绑定），处理相关事物的时候首先想到的就是绑定，基本大多数操作也都是围绕着信号进行的，以上不仅仅是 RAC 的基本用法，在 MVVM 中也是同样适用，只是把业务和逻辑通过 ViewModel 分离解耦，更大程度的利用了 RAC 在开发中的高效优势。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://halfrost.com/tag/reactivecocoa/" target="_blank" rel="noopener">函数响应式编程(FRP)从入门到”放弃”</a></li><li><a href="http://blog.harrisonxi.com/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html" target="_blank" rel="noopener">iOS使用RAC实现MVVM的正经姿势</a></li><li><a href="https://draveness.me/tag/RAC/" target="_blank" rel="noopener">『状态』驱动的世界：ReactiveCocoa 系列</a></li><li><a href="http://chaoxn.com/2015/11/12/ReactiveCocoa%E4%B8%8EMVVM/" target="_blank" rel="noopener">ReactiveCocoa学习总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;p&gt;在 iOS 开发中，或多或少都会见过 RAC 的身影，它为提高开发效率而生，在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。如
      
    
    </summary>
    
      <category term="rac" scheme="https://blog.yuhanle.com/categories/rac/"/>
    
    
      <category term="rac" scheme="https://blog.yuhanle.com/tags/rac/"/>
    
  </entry>
  
  <entry>
    <title>代码中的缩进线</title>
    <link href="https://blog.yuhanle.com/2018/04/24/line-of-sight-in-code/"/>
    <id>https://blog.yuhanle.com/2018/04/24/line-of-sight-in-code/</id>
    <published>2018-04-24T01:00:00.000Z</published>
    <updated>2018-07-05T01:24:58.518Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_CBjBs9EzL8q1AL6XvjjpJg.png" alt="我在2016年伦敦Golang英国会议上谈论代码缩进线"></p><p>在近期伦敦举行的 <a href="https://www.youtube.com/watch?v=yeetIgNeIkc" target="_blank" rel="noopener">Golang 英国会议</a> 上，我在<a href="https://www.youtube.com/watch?v=yeetIgNeIkc" target="_blank" rel="noopener">地道的Go 语言窍门</a> 交流（<a href="http://go-talks.appspot.com/github.com/matryer/present/idiomatic-go-tricks/main.slide#1" target="_blank" rel="noopener">幻灯片</a>）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。</p><a id="more"></a><blockquote><p>缩进线是“观察者无障碍视线的直线”</p></blockquote><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_nXXRSHi_1kmgorkcDHyc1Q.png" alt="代码中的缩进线：左图的缩进是错误处理和边缘情况的快乐路径"></p><p>良好的代码缩进线不仅对你的功能没有任何影响，还可以帮助其他需要的人阅读你的代码。其他程序员（包括你未来的自己）可以浏览一个专栏并且理解代码的预期流程。如果他们不得不在脑子里分析 <code>if</code> 语句，若没有良好的缩进线，将会使这个任务变得非常艰难。</p><blockquote><p>大多数人关注编写代码的代价（比如“这需要多长时间才能完成？”）但是维护代码的成本要高得多 - 特别是在成熟的项目中。 让功能明显，清晰，简单易懂才是至关重要的。</p></blockquote><p>良好缩进线的建议：</p><ul><li>让<a href="https://en.wikipedia.org/wiki/Happy_path" target="_blank" rel="noopener">快乐路径</a>居左侧对齐，这样你就可以快速扫描一列来查看预期的执行流程</li><li>不要隐藏缩进大括号中代码逻辑</li><li>尽早的退出 <code>function</code></li><li>避免 <code>else return</code>，考虑翻转 <code>if</code> 语句</li><li>把 <code>return</code> 声明作为最后一行</li><li>提取 <code>function</code> 和 <code>method</code> 以保持结构小巧和可读</li><li>如果你需要大缩进的代码，考虑当做一个 <code>function</code> 分解出来</li></ul><p>当然，会有很多很好的理由来打破所有这些规则 - 但是采用这种风格作为默认规则，我们发现我们的代码变得更具可读性。</p><h2 id="避免-else-return"><a href="#避免-else-return" class="headerlink" title="避免 else return"></a>避免 <code>else return</code></h2><p>编写具有良好视觉效果的代码的关键是保持 <code>else</code> 结构小巧，或者如果可以的话，完全避免它们。 看下这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if something.OK() &#123;</span><br><span class="line">    something.Lock()</span><br><span class="line">    defer something.Unlock()</span><br><span class="line">    err := something.Do()</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        stop := StartTimer()</span><br><span class="line">        defer stop()</span><br><span class="line">        log.Println(&quot;working...&quot;)</span><br><span class="line">        doWork(something)</span><br><span class="line">        &lt;-something.Done() // wait for it</span><br><span class="line">        log.Println(&quot;finished&quot;)</span><br><span class="line">        return nil</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return errors.New(&quot;something not ok&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代表了我们最初如何思考我们的功能在做什么（“如果某件事情没问题，那么就做，如果没有错误，那么做这些事情”等等），但是它变得很难遵循。</p><p>上面的代码很难遵循’快乐路径’（执行顺利进行的路线）。它在第二行开始缩进并从那里继续。 当我们检查来自 <code>something.Do()</code> 的错误返回时，我们进一步缩进。 事实上，语句“ <code>return nil</code> ”在代码中间完全丢失。</p><p><code>else</code> 结构在 Go 和其他语言中作为单一行返回很常见，因为它们要处理中止或退出函数。 我认为他们不能保证缩进我们的其他代码。</p><h2 id="翻转-if-语句"><a href="#翻转-if-语句" class="headerlink" title="翻转 if 语句"></a>翻转 if 语句</h2><p>如果我们要翻译 <code>if</code> 语句<em>（如果你喜欢</em> ， <em>就把它们</em>翻<em>过来）</em> ，你可以看到代码变得更加可读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if !something.OK() &#123;  // flipped</span><br><span class="line">    return errors.New(&quot;something not ok&quot;)</span><br><span class="line">&#125;</span><br><span class="line">something.Lock()</span><br><span class="line">defer something.Unlock()</span><br><span class="line">err := something.Do()</span><br><span class="line">if err != nil &#123;       // flipped</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop := StartTimer()</span><br><span class="line">defer stop()</span><br><span class="line"></span><br><span class="line">log.Println(&quot;working...&quot;)</span><br><span class="line">doWork(something)</span><br><span class="line">&lt;-something.Done() // wait for it</span><br><span class="line">log.Println(&quot;finished&quot;)</span><br><span class="line">return nil</span><br></pre></td></tr></table></figure><p>在此代码中，我们正在尽早退出，退出代码与正常代码不同。而且，</p><ul><li>快乐路径沿着左侧向下保持，</li><li>我们缩进只是为了处理错误和边缘情况，</li><li>我们的 <code>retutn</code> 声明“ <code>return nil</code> ”在最后一行，并且，</li><li>我们有更少的缩进代码块。</li></ul><h2 id="促进大型条件块的功能"><a href="#促进大型条件块的功能" class="headerlink" title="促进大型条件块的功能"></a>促进大型条件块的功能</h2><p>如果你不能避免一个笨重的 <code>else</code> 结构或臃肿的选择切换的情况（我明白了，有时候你不能），那么就考虑把每个结构分解成它自己的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func processValue(v interface&#123;&#125;) error &#123;</span><br><span class="line">    switch val := v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        return processString(val)</span><br><span class="line">    case int:</span><br><span class="line">        return processInt(val)</span><br><span class="line">    case bool:</span><br><span class="line">        return processBool(val)</span><br><span class="line">    default:</span><br><span class="line">        return fmt.Errorf(&quot;unsupported type %T&quot;, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比读取大量的处理代码更容易阅读。</p><h2 id="分享你的经验"><a href="#分享你的经验" class="headerlink" title="分享你的经验"></a>分享你的经验</h2><p>如果你同意我的观点，请考虑分享这篇文章 - 随着越来越多的人注册，更好的（更一致的）Go 代码将会出现。</p><p>你有一些难以阅读的代码吗？ 为什么不在 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=https://twitter.com/matryer&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgR995EkjexZDOQl9LYu8Sl7eq3TA" target="_blank" rel="noopener">Twitter @matryer</a> 上分享它，可以看看我们是否可以找到一个更清洁，更简单的版本。</p><h2 id="致谢…"><a href="#致谢…" class="headerlink" title="致谢…"></a>致谢…</h2><p>评论家<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=http://dave.cheney.net/&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgTC1jmfDNNabAZ1iX8dJSOjyuddw" target="_blank" rel="noopener">戴夫切尼</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=http://twitter.com/dahernan&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhm04bLuew6j4VCw3ACIxtPeMMmxA" target="_blank" rel="noopener">大卫埃尔南德斯</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=https://twitter.com/goinggodotnet&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhi57B943koWpS6pe4_aRslBMy-7mw" target="_blank" rel="noopener">威廉肯尼迪</a> 。</p><hr><p>via: <a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p><p>作者：<a href="https://medium.com/@matryer" target="_blank" rel="noopener">Mat Ryer</a>  译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a>  校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/12928" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p><p>本文由 GCTT 原创翻译，<a href="https://studygolang.com/articles/12928" target="_blank" rel="noopener">Go语言中文网</a> 首发。也想加入译者行列，为开源做一些自己的贡献么？欢迎加入 <a href="https://studygolang.com/gctt" target="_blank" rel="noopener">GCTT</a>！<br>翻译工作和译文发表仅用于学习和交流目的，翻译工作遵照 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-SA 协议规定</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。<br>欢迎遵照 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-SA 协议规定</a> 转载，敬请在正文中标注并保留原文/译文链接和作者/译者等信息。<br>文章仅代表作者的知识和看法，如有不同观点，请楼下排队吐槽</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_CBjBs9EzL8q1AL6XvjjpJg.png&quot; alt=&quot;我在2016年伦敦Golang英国会议上谈论代码缩进线&quot;&gt;&lt;/p&gt;
&lt;p&gt;在近期伦敦举行的 &lt;a href=&quot;https://www.youtube.com/watch?v=yeetIgNeIkc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 英国会议&lt;/a&gt; 上，我在&lt;a href=&quot;https://www.youtube.com/watch?v=yeetIgNeIkc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地道的Go 语言窍门&lt;/a&gt; 交流（&lt;a href=&quot;http://go-talks.appspot.com/github.com/matryer/present/idiomatic-go-tricks/main.slide#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;幻灯片&lt;/a&gt;）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>记录一次简单的逆向</title>
    <link href="https://blog.yuhanle.com/2018/04/24/a-simple-iosre/"/>
    <id>https://blog.yuhanle.com/2018/04/24/a-simple-iosre/</id>
    <published>2018-04-24T01:00:00.000Z</published>
    <updated>2018-07-05T01:14:52.554Z</updated>
    
    <content type="html"><![CDATA[<p>由于爱奇艺会员到期，于是产生逆向APP 的想法，尚未找到解决办法。</p><h2 id="安装MonkeyDev"><a href="#安装MonkeyDev" class="headerlink" title="安装MonkeyDev"></a>安装MonkeyDev</h2><p>原有iOSOpenDev的升级，非越狱插件开发集成神器！</p><a id="more"></a><ul><li>可以使用Xcode开发CaptainHook Tweak、Logos Tweak 和 Command-line Tool，在越狱机器开发插件，这是原来iOSOpenDev功能的迁移和改进。</li><li>只需拖入一个砸壳应用，自动集成class-dump、restore-symbol、Reveal、Cycript和注入的动态库并重签名安装到非越狱机器。</li><li>支持调试自己编写的动态库和第三方App</li><li>支持通过CocoaPods第三方应用集成SDK以及非越狱插件，简单来说就是通过CocoaPods搭建了一个非越狱插件商店。</li></ul><p>安装教程可参考：<a href="https://github.com/AloneMonkey/MonkeyDev/wiki" target="_blank" rel="noopener">安装</a></p><h2 id="准备砸壳安装包"><a href="#准备砸壳安装包" class="headerlink" title="准备砸壳安装包"></a>准备砸壳安装包</h2><p>一般从某助手上下载的越狱版本，就是已经砸壳的，当然也可以自行通过 <a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a> 工具实现。</p><h2 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>class-dump</strong> 是一个工具，它利用了 Objective-C 语言的运行时特性，将存储在 Mach-O 文件中的头文件信息提取出来，并生成对应的 .h 文件。</p><h3 id="安装-class-dump"><a href="#安装-class-dump" class="headerlink" title="安装 class-dump"></a>安装 class-dump</h3><p>到 <a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">class-dump 官网</a> 进行下载，目前最新的版本为 3.5。</p><p>在个人目录下新建一个 <code>bin</code> 目录，并将其添加到 PATH 路径中，然后将下载后的 class-dump-3.5.dmg 里面的 class-dump 可执行文件复制到该 <code>bin</code> 目录下，赋予可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/bin</span><br><span class="line">$ vim ~/.bash_profile</span><br><span class="line"># 编辑 ~/.bash_profile 文件，并添加如下一行</span><br><span class="line">export PATH=$HOME/bin/:$PATH</span><br><span class="line"></span><br><span class="line"># 将 class-dump 拷贝到 bin 目录后执行下面命令</span><br><span class="line">$ chmod +x ~/bin/class-dump</span><br></pre></td></tr></table></figure><h3 id="使用-class-dump"><a href="#使用-class-dump" class="headerlink" title="使用 class-dump"></a>使用 class-dump</h3><p>到最后一步，以爱奇艺为例，使用 class-dump 来将微信的头文件导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ class-dump -H iQiYiPhoneVideo.app -o Payload/</span><br></pre></td></tr></table></figure><p>这样，所有的头文件就都被导出到了 <code>.Payload/</code> 目录下了。</p><p><img src="https://user-images.githubusercontent.com/10498756/39162346-a7f6fcb8-47a7-11e8-92d1-8a0e0f910036.png" alt="image"></p><h2 id="头文件分析"><a href="#头文件分析" class="headerlink" title="头文件分析"></a>头文件分析</h2><p>可以借助 FLEX 工具来查看APP 的层级和数据以及接口声明，可以快速定位我们要修改的位置</p><h3 id="安装-FLEX"><a href="#安装-FLEX" class="headerlink" title="安装 FLEX"></a>安装 FLEX</h3><p><a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a> 官方仓库，通过Cocoapods 安装依赖即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">'https://github.com/AloneMonkey/MonkeyDevSpecs.git'</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'9.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'antrees'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span></span><br><span class="line">  <span class="comment"># use_frameworks!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pods for antrees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'antreesDylib'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span></span><br><span class="line">  <span class="comment"># use_frameworks!</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 注意是安装到动态库 而不是APP</span></span><br><span class="line">  <span class="comment"># Pods for antreesDylib</span></span><br><span class="line">  pod <span class="string">'FLEX'</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>紧接着在程序启动以后，添加FLEX 的显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CHConstructor&#123;</span><br><span class="line">    NSLog(INSERT_SUCCESS_WELCOME);</span><br><span class="line">    </span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidFinishLaunchingNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">        [[FLEXManager sharedManager] showExplorer];</span><br><span class="line">#ifndef __OPTIMIZE__</span><br><span class="line">        CYListenServer(6666);</span><br><span class="line">        CycriptManager* manager = [CycriptManager sharedInstance];</span><br><span class="line">        [manager startDownloadCycript:NO];</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h3><p>我们可以通过这个FLipboard 来实现操作，具体效果如下</p><table><thead><tr><th style="text-align:center">主页</th><th style="text-align:center">菜单</th><th style="text-align:center">视图</th><th style="text-align:center">选择</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162331-94ee0fee-47a7-11e8-8a97-aec72ffba1b7.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162363-c0e9febe-47a7-11e8-8569-21ddef9f1f9c.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162378-d06b42b2-47a7-11e8-9687-a2e909151ea5.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162397-e1bfddca-47a7-11e8-8088-ac88bc83cf6b.png" alt="image"></td></tr></tbody></table><h3 id="小实战"><a href="#小实战" class="headerlink" title="小实战"></a>小实战</h3><p>比如，我们想去掉Tab 栏那个可恶的泡泡（截图部分已处理），我是非常讨厌那个功能，感觉很鸡肋，体验极差。</p><p>此时我们可以通过<code>select</code> 功能点击底部菜单栏，然后进入到视图查看层级关系，最终找到对应的实例，如下图所示</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">主页</th><th style="text-align:center">视图1</th><th style="text-align:center">视图2</th></tr></thead><tbody><tr><td style="text-align:center">处理前</td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162415-fa9508ca-47a7-11e8-9c25-55e8a1ccde35.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162445-178f1100-47a8-11e8-9d41-1b8c6bf3286a.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162508-7baa0f0a-47a8-11e8-92a6-1c71f6e0b48a.png" alt="image"></td></tr><tr><td style="text-align:center">处理后</td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162331-94ee0fee-47a7-11e8-8a97-aec72ffba1b7.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162490-531e8548-47a8-11e8-91aa-e3f0d9a3034f.png" alt="image"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/10498756/39162508-7baa0f0a-47a8-11e8-92a6-1c71f6e0b48a.png" alt="image"></td></tr></tbody></table><p>代码实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CHDeclareClass(TabbarView)</span><br><span class="line"></span><br><span class="line">CHOptimizedMethod0(self, NSArray*, TabbarView, tabbarImageArray)&#123;</span><br><span class="line">    //get origin value</span><br><span class="line">    NSMutableArray* originArray = CHSuper(0, TabbarView, tabbarImageArray).mutableCopy;</span><br><span class="line">    </span><br><span class="line">    [originArray removeLastObject];</span><br><span class="line">    </span><br><span class="line">    //change the value</span><br><span class="line">    return originArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHOptimizedMethod0(self, NSArray*, TabbarView, tabbarTitleArray)&#123;</span><br><span class="line">    //get origin value</span><br><span class="line">    NSMutableArray* originArray = CHSuper(0, TabbarView, tabbarTitleArray).mutableCopy;</span><br><span class="line">    </span><br><span class="line">    [originArray removeLastObject];</span><br><span class="line">    </span><br><span class="line">    //change the value</span><br><span class="line">    return originArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHConstructor &#123;</span><br><span class="line">    CHLoadLateClass(TabbarView);</span><br><span class="line">    CHHook0(TabbarView, tabbarImageArray);</span><br><span class="line">    CHHook0(TabbarView, tabbarTitleArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://user-images.githubusercontent.com/10498756/39162834-08506cf0-47aa-11e8-9712-0c86beddf7b3.png" alt="image"></p><p>通过<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a> 大大降低了逆向开发的门槛，使得逆向变得更加有趣和更具规范性。通过逆向，可以实现很多意想不到的功能，给你不断的惊喜！</p><p>下面是本次实践的代码示例，会员和去广告相关功能暂未实现，正在寻求其他思路~</p><p><a href="https://github.com/yuhanle/SimpleiOSRE" target="_blank" rel="noopener">SimpleiOSRE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于爱奇艺会员到期，于是产生逆向APP 的想法，尚未找到解决办法。&lt;/p&gt;
&lt;h2 id=&quot;安装MonkeyDev&quot;&gt;&lt;a href=&quot;#安装MonkeyDev&quot; class=&quot;headerlink&quot; title=&quot;安装MonkeyDev&quot;&gt;&lt;/a&gt;安装MonkeyDev&lt;/h2&gt;&lt;p&gt;原有iOSOpenDev的升级，非越狱插件开发集成神器！&lt;/p&gt;
    
    </summary>
    
      <category term="iOSRE" scheme="https://blog.yuhanle.com/categories/iOSRE/"/>
    
    
      <category term="iOSRE" scheme="https://blog.yuhanle.com/tags/iOSRE/"/>
    
  </entry>
  
  <entry>
    <title>为什么我选择认识 Flutter ？</title>
    <link href="https://blog.yuhanle.com/2018/04/18/why-select-flutter/"/>
    <id>https://blog.yuhanle.com/2018/04/18/why-select-flutter/</id>
    <published>2018-04-18T01:00:00.000Z</published>
    <updated>2018-06-28T09:22:07.850Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/10498756/38983320-a1888c34-43f6-11e8-8003-a38e7230b2fd.jpeg" alt="1_uq4-35mu2_32qvpnyqyt9q"></p><h2 id="Flutter-是什么"><a href="#Flutter-是什么" class="headerlink" title="Flutter 是什么"></a>Flutter 是什么</h2><p>Flutter 移动应用程序 SDK 是为开发人员提供一种创建快捷、美观的应用程序的新方式，从而摆脱过去那种千篇一律的 app，尝试过 Flutter 的人都会真的爱上它。<br><a id="more"></a></p><p>与任何新系统一样，用户想知道 Flutter 有什么与众不同之处，“Flutter 有什么新的或者令人兴奋的东西吗？”，这是一个合理的问题，本文将从技术的角度回答 Flutter 有什么东西让人兴奋，而且给出它为什么让人兴奋的原因。</p><h3 id="Flutter-的优势"><a href="#Flutter-的优势" class="headerlink" title="Flutter 的优势"></a>Flutter 的优势</h3><ul><li>响应式视图的优点，不需要 JavaScript 的桥接器</li><li>快速，流畅，可预测 ; 代码将 AOT 编译为本机（ARM）代码</li><li>开发人员完全控制 UI 组件和布局</li><li>配有美观，可定制的 UI 组件</li><li>强大的开发者工具，惊人的热重新加载</li><li>性能更好，兼容性更好，开发起来更有乐趣</li></ul><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>目前Flutter只能在Mac和Linux(64位)上工作，使用windows的同学可能要借助虚拟机来进行学习。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><table><thead><tr><th>android</th><th>iOS</th></tr></thead><tbody><tr><td><img src="https://user-images.githubusercontent.com/10498756/38983248-7b0b07c6-43f6-11e8-9ec7-48fad12f6554.png" alt="screenshot_1524033161"></td><td><img src="https://user-images.githubusercontent.com/10498756/38983259-83079246-43f6-11e8-96fd-99752cc17a0b.png" alt="simulator screen shot - iphone x - 2018-04-18 at 14 32 39"></td></tr></tbody></table><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Flutter-SDK"><a href="#安装Flutter-SDK" class="headerlink" title="安装Flutter SDK"></a>安装Flutter SDK</h3><p>这一步其实很简单，就是将Flutter在github上的源码整个clone下来，在适当的目录执行👇命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/flutter/flutter.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`/flutter/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flutter doctor</span></span><br></pre></td></tr></table></figure><p>👆这个命令会告诉你你的flutter还缺少什么依赖，输出如下：</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flutter</span></span><br></pre></td></tr></table></figure><p>第一次运行flutter它会自动下载一些依赖，并且进行自动编译。随后再次运行flutter就会跳过这些步骤</p><h3 id="安装-Android-studio"><a href="#安装-Android-studio" class="headerlink" title="安装 Android studio"></a>安装 Android studio</h3><p>官方指引完成即可</p><h3 id="安装Flutter"><a href="#安装Flutter" class="headerlink" title="安装Flutter"></a>安装Flutter</h3><p>偏好设置中安装插件</p><h3 id="安装Dart"><a href="#安装Dart" class="headerlink" title="安装Dart"></a>安装Dart</h3><p>偏好设置中安装插件</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create &#123;projectName&#125;</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//工程根目录下执行</span><br><span class="line">flutter packages get</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    <span class="keyword">new</span> Center(</span><br><span class="line">      child: <span class="keyword">new</span> Text(</span><br><span class="line">        <span class="string">'Hello, world!'</span>,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.dart 同样作为程序的入口文件，需要实现main 函数</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://docs.flutter.io/index.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488206&amp;idx=1&amp;sn=ed6a81769f37324b947b9a0a97fbe522&amp;source=41#wechat_redirect" target="_blank" rel="noopener">为什么说Flutter 是革命性的</a></li><li><a href="http://www.infoq.com/cn/articles/why-flutter-uses-dart" target="_blank" rel="noopener">为什么Flutter会选择 Dart ？</a></li><li><a href="https://www.zhihu.com/question/50156415" target="_blank" rel="noopener">如何评价 Google 的 Fuchsia、Android、iOS 跨平台应用框架 Flutter？</a></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>Android license status unknown.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hi everyone,</span><br><span class="line">type $flutter upgrade</span><br><span class="line">type $flutter doctor --android-licenses</span><br><span class="line">It might say some licenses are not accepted(something like that)</span><br><span class="line">you will be asked 'Do you want to review the licenses'?</span><br><span class="line">typey&lt;press enter&gt;</span><br><span class="line"></span><br><span class="line">accept all the licenses review.</span><br><span class="line"></span><br><span class="line">now check flutter again with $flutter doctor</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/10498756/38983320-a1888c34-43f6-11e8-8003-a38e7230b2fd.jpeg&quot; alt=&quot;1_uq4-35mu2_32qvpnyqyt9q&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flutter-是什么&quot;&gt;&lt;a href=&quot;#Flutter-是什么&quot; class=&quot;headerlink&quot; title=&quot;Flutter 是什么&quot;&gt;&lt;/a&gt;Flutter 是什么&lt;/h2&gt;&lt;p&gt;Flutter 移动应用程序 SDK 是为开发人员提供一种创建快捷、美观的应用程序的新方式，从而摆脱过去那种千篇一律的 app，尝试过 Flutter 的人都会真的爱上它。&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://blog.yuhanle.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://blog.yuhanle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Mac 搭建 nginx+rtmp 推流服务器</title>
    <link href="https://blog.yuhanle.com/2018/03/12/live-broadcast-rtmp/"/>
    <id>https://blog.yuhanle.com/2018/03/12/live-broadcast-rtmp/</id>
    <published>2018-03-12T01:00:00.000Z</published>
    <updated>2018-07-05T01:19:00.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直播协议选择"><a href="#直播协议选择" class="headerlink" title="直播协议选择"></a>直播协议选择</h2><p>国内常见公开的直播协议有几个：RTMP、HLS、HDL（HTTP-FLV）、RTP，我们来逐一介绍。</p><p><strong>RTMP协议：</strong></p><p>是Adobe的专利协议，现在大部分国外的CDN已不支持。在国内流行度很高。原因有几个方面：</p><a id="more"></a><p>1、开源软件和开源库的支持稳定完整。如斗鱼主播常用的OBS软件，开源的librtmp库，服务端有nginx-rtmp插件。</p><p>2、播放端安装率高。只要浏览器支持FlashPlayer就能非常简易的播放RTMP的直播，协议详解可以Google了解。相对其他协议而言，RTMP协议初次建立连接的时候握手过程过于复杂（底层基于TCP，这里说的是RTMP协议本身的交互），视不同的网络状况会带来给首开带来100ms以上的延迟。基于RTMP的直播一般内容延迟在2~5秒。</p><p><img src="http://blog.ucloud.cn/wp-content/uploads/2016/05/640-1.jpeg" alt="1"></p><p><strong>HTTP-FLV 协议：</strong></p><p>即使用HTTP协议流式的传输媒体内容。相对于RTMP，HTTP更简单和广为人知，而且不担心被Adobe的专利绑架。内容延迟同样可以做到2~5秒，打开速度更快，因为HTTP本身没有复杂的状态交互。所以从延迟角度来看，HTTP-FLV要优于RTMP。</p><p><strong>HLS 协议：</strong></p><p>即Http Live Streaming，是由苹果提出基于HTTP的流媒体传输协议。HLS有一个非常大的优点：<strong>HTML5可以直接打开播放；这个意味着可以把一个直播链接通过微信等转发分享</strong>，不需要安装任何独立的APP，有浏览器即可，所以流行度很高。<strong>社交直播APP，HLS可以说是刚需，</strong>下来我们分析下其原理 。</p><p>基于HLS的直播流URL是一个m3u8的文件，里面包含了最近若干个小视频TS（一种视频封装格式，这里就不扩展介绍）文件，如 <a href="http://www.ucloud.cn/helloworld.m3u8" target="_blank" rel="noopener">http://www.ucloud.cn/helloworld.m3u8 </a> 是一个直播留链接，其内容如下：</p><p><img src="http://blog.ucloud.cn/wp-content/uploads/2016/05/2-1.jpg" alt="2"></p><p>假设列表里面的包含5个TS文件，每个TS文件包含5秒的视频内容，那么整体的延迟就是25秒。当然可以缩短列表的长度和单个TS文件的大小来降低延迟，极致来说可以缩减列表长度为1，1秒内容的m3u8文件，但是极易受网络波动影响造成卡顿。</p><p>通过公网的验证，目前按同城网络可以做到比较好的效果是5~7秒的延迟，也是综合流畅度和内容延迟的结果。那么HTML5是否可以有更低延迟直接打开的直播流技术呢？ 我们在最后会探讨这个问题。</p><p><strong>RTP 协议：</strong></p><p>即Real-time Transport Protocol，用于Internet上针对多媒体数据流的一种传输层协议。</p><p>实际应用场景下经常需要RTCP（RTP Control Protocol）配合来使用，可以简单理解为RTCP传输交互控制的信令，RTP传输实际的媒体数据。</p><p><strong>RTP在视频监控、视频会议、IP电话上有广泛的应用</strong>，因为视频会议、IP电话的一个重要的使用体验：内容实时性强。</p><p>对比与上述3种或实际是2种协议，RTP和它们有一个重要的区别就是默认是使用UDP协议来传输数据，而RTMP和HTTP是基于TCP协议传输。为什么UDP 能做到如此实时的效果呢？关于TCP和UDP差别的分析文章一搜一大把，这里不在赘述，简单概括：</p><p><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；</strong></p><p><strong>TCP：流式，需要建立连接，复杂，可靠**</strong> ，有序。**</p><p>实时音视频流的场景不需要可靠保障，因此也不需要有重传的机制，实时的看到图像声音，网络抖动时丢了一些内容，画面模糊和花屏，完全不重要。TCP为了重传会造成延迟与不同步，如某一截内容因为重传，导致1秒以后才到，那么整个对话就延迟了1秒，随着网络抖动，延迟还会增加成2秒、3秒，如果客户端播放是不加以处理将严重影响直播的体验。</p><p><strong>总结一下：</strong>在直播协议的选择中，如果选择是RTMP或HTTP-FLV则意味着有2~5秒的内容延迟，但是就打开延迟开，HTTP-FLV 要优于RTMP。HLS则有5~7秒的内容延迟。选择RTP进行直播则可以做到1秒内的直播延迟。但就目前所了解，各大CDN厂商没有支持基于RTP直播的，所以目前国内主流还是RTMP或HTTP-FLV。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h3><p>确认是否已经安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man brow</span><br></pre></td></tr></table></figure><p>如果出现下面的代码,证明已经安装过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME  </span><br><span class="line">       brew - The missing package manager for macOS  </span><br><span class="line">  </span><br><span class="line">SYNOPSIS  </span><br><span class="line">       brew --version  </span><br><span class="line">       brew command [--verbose|-v] [options] [formula] ...</span><br></pre></td></tr></table></figure><p>安装命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>如果已经安装过，而想要卸载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure><p>如果不想重装,升级一下brow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><p>执行克隆命令，github 的项目(<a href="https://github.com/denji/homebrew-nginx" target="_blank" rel="noopener">https://github.com/denji/homebrew-nginx</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap denji/nginx</span><br></pre></td></tr></table></figure><p>注意brew tap homebrew/nginx报下面的错误，homebrew/nginx已经启用.</p><p> 报错：Error: homebrew/nginx was deprecated. This tap is now empty as all its formulae were migrated.</p><p>执行安装命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx-full --with-rtmp-module</span><br></pre></td></tr></table></figure><p>至此nginx和rtmp模块就安装好了，下面开始来配置nginx的rtmp模块</p><p>接下来看一下nginx安装在什么地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info nginx-full</span><br></pre></td></tr></table></figure><p>nginx安装所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/opt/nginx-full/bin/nginx</span><br></pre></td></tr></table></figure><p>nginx配置文件所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="运行-NGINX"><a href="#运行-NGINX" class="headerlink" title="运行 NGINX"></a>运行 NGINX</h3><p>启动nginx,执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>浏览器地址栏输入：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><p><img src="http://img.blog.csdn.net/20180309112217266" alt="img"></p><p>出现以上界面,说明安装成功.</p><p>如果终端上提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use)</span><br></pre></td></tr></table></figure><p>则表示8080端口被占用了, 查看端口PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:8080</span><br></pre></td></tr></table></figure><p>kill掉占用8080端口的PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 9663（这里替换成占用8080端口的PID）</span><br></pre></td></tr></table></figure><p>重新执行nginx…</p><h4 id="nginx常用方法"><a href="#nginx常用方法" class="headerlink" title="nginx常用方法:"></a>nginx常用方法:</h4><p>重新加载配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>重新加载日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reopen</span><br></pre></td></tr></table></figure><p>停止 nginx:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure><p>有序退出 nginx:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="配置-RTMP"><a href="#配置-RTMP" class="headerlink" title="配置 RTMP"></a>配置 RTMP</h3><p>修改nginx.conf这个配置文件，配置rtmp</p><p>复制nginx配置文件所在位置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>执行上面命令直接编辑,或者直接前往当前文件用记事本打开.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;  </span><br><span class="line"> ​  ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在http节点后面加上rtmp配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;  </span><br><span class="line">  server &#123;  </span><br><span class="line">    listen 2016;  </span><br><span class="line">    application rtmplive &#123;  </span><br><span class="line">    live on;  </span><br><span class="line">    record off;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑完成之后,执行一下重新加载配置文件命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>重启nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/opt/nginx-full/bin/nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="安装-FFmpeg-工具"><a href="#安装-FFmpeg-工具" class="headerlink" title="安装 FFmpeg 工具"></a>安装 FFmpeg 工具</h3><p>注:ffmepg转码工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure><p>安装完成之后</p><p>安装一个支持rtmp协议的视频播放器，Mac下可以用VLC</p><p>本地下载一个视频文件路径为 /Users/yuhanle/Downloads/test.mp4</p><p>执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i /Users/yuhanle/Downloads/test.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>然后打开 VLC 中 的 file – Open Network, 直接输入代码中的 url:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>然后进行播放</p><h2 id="FFmpeg-推流"><a href="#FFmpeg-推流" class="headerlink" title="FFmpeg 推流"></a>FFmpeg 推流</h2><p>1、桌面录制或者分享</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i &quot;1&quot; -vcodec libx264 -preset ultrafast -acodec libfaac -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>2、桌面+麦克风</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i &quot;1:0&quot; -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><p>3、桌面+麦克风，并且还要摄像头拍摄到自己</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; \-f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; \-c:v libx264 -preset ultrafast \-filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:2016/rtmplive/room</span><br></pre></td></tr></table></figure><h2 id="LFLiveKit"><a href="#LFLiveKit" class="headerlink" title="LFLiveKit"></a>LFLiveKit</h2><p><img src="https://camo.githubusercontent.com/34026396e449a30121c9fe86707423305663462f/68747470733a2f2f7261772e6769746875622e636f6d2f4c616946656e67694f532f4c464c6976654b69742f6d61737465722f73616d706c65732f49636f6e2e706e67" alt=""></p><p>LaiFeng IOS Live Kit,H264 and AAC Hard coding，support GPUImage Beauty， rtmp transmission，weak network lost frame，Dynamic switching rate</p><p>通过集成 <a href="https://github.com/LaiFengiOS/LFLiveKit" target="_blank" rel="noopener">LFLiveKit</a>，我们可以使用手机录制并推送至直播间地址，然后使用播放端直接播放视频。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.ucloud.cn/archives/699" target="_blank" rel="noopener">关于直播，所有的技术细节都在这里了（二）</a><br><a href="http://blog.ucloud.cn/?p=694" target="_blank" rel="noopener">关于直播，所有的技术细节都在这里了（一）</a><br><a href="http://blog.csdn.net/zcvbnh/article/details/79495285" target="_blank" rel="noopener">Mac 搭建 nginx+rtmp 服务器-带你出坑</a><br><a href="http://www.voidcn.com/article/p-abhhplih-p.html" target="_blank" rel="noopener">在Mac系统上搭建iOS手机推流服务器相关总结</a><br><a href="http://9dic.com/ios/2016/07/15/install-nginx+rtmp-on-mac/" target="_blank" rel="noopener">Mac搭建nginx+rtmp服务器 推流</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;直播协议选择&quot;&gt;&lt;a href=&quot;#直播协议选择&quot; class=&quot;headerlink&quot; title=&quot;直播协议选择&quot;&gt;&lt;/a&gt;直播协议选择&lt;/h2&gt;&lt;p&gt;国内常见公开的直播协议有几个：RTMP、HLS、HDL（HTTP-FLV）、RTP，我们来逐一介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTMP协议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是Adobe的专利协议，现在大部分国外的CDN已不支持。在国内流行度很高。原因有几个方面：&lt;/p&gt;
    
    </summary>
    
      <category term="live" scheme="https://blog.yuhanle.com/categories/live/"/>
    
    
      <category term="live" scheme="https://blog.yuhanle.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>如何在 GitHub Pages 上部署 vue-cli 项目</title>
    <link href="https://blog.yuhanle.com/2018/03/06/deploy-the-vue-cli-project-on-github-pages/"/>
    <id>https://blog.yuhanle.com/2018/03/06/deploy-the-vue-cli-project-on-github-pages/</id>
    <published>2018-03-06T01:55:34.000Z</published>
    <updated>2018-08-04T00:03:47.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-在-GitHub-上创建与本地项目同名的远程仓库"><a href="#1-在-GitHub-上创建与本地项目同名的远程仓库" class="headerlink" title="1. 在 GitHub 上创建与本地项目同名的远程仓库"></a>1. 在 GitHub 上创建与本地项目同名的远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接在GitHub 上新建一个远程仓库</span><br></pre></td></tr></table></figure><h3 id="2-将本地项目-push-到远程"><a href="#2-将本地项目-push-到远程" class="headerlink" title="2. 将本地项目 push 到远程"></a>2. 将本地项目 push 到远程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git cmt -m &apos;create project&apos;</span><br><span class="line">$ git remote add origin git@github.com:yuhanle/resume.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="3-将-dist-下的所有文件夹-push-到-gh-pages"><a href="#3-将-dist-下的所有文件夹-push-到-gh-pages" class="headerlink" title="3. 将 dist 下的所有文件夹 push 到 gh-pages"></a>3. 将 dist 下的所有文件夹 push 到 gh-pages</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br><span class="line">$ git checkout -b gh-pages</span><br><span class="line">$ git add -f dist</span><br><span class="line">$ git commit -m &apos;create project&apos;</span><br><span class="line">$ git subtree push --prefix dist origin gh-pages</span><br></pre></td></tr></table></figure><p>这些步骤做完之后在 gh-pages 分支展示项目了，比如<br><a href="https://yuhanle.github.io/resume/" target="_blank" rel="noopener">https://yuhanle.github.io/resume/</a></p><h3 id="4-资源路径错误问题"><a href="#4-资源路径错误问题" class="headerlink" title="4. 资源路径错误问题"></a>4. 资源路径错误问题</h3><ol><li>在 <code>npm run build</code> 之前要将 <code>config/index.js</code> 里边 <code>build</code> 配置里边的 <code>assetsPublicPath: &#39;/&#39;</code> 改成 <code>assetsPublicPath: &#39;./&#39;</code></li><li>将 <code>webpack.prod.conf.js</code> 中的 <code>removeAttributeQuotes</code> 改为 <code>false</code></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/cc053119f119" target="_blank" rel="noopener">如何在 GitHub Pages 上部署 vue-cli 项目</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;h3 id=&quot;1-在-GitHub-上创建与本地项目同名的远程仓库&quot;&gt;&lt;a href=&quot;#1-在-GitHub-上创建与本地项目同名的远程仓库&quot; class=&quot;headerlink&quot; title=&quot;1. 在 GitHub 上创建与本地项目同名的远程仓库&quot;&gt;&lt;/a&gt;1. 在 GitHub 上创建与本地项目同名的远程仓库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;直接在GitHub 上新建一个远程仓库&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-将本地项目-push-到远程&quot;&gt;&lt;a href=&quot;#2-将本地项目-push-到远程&quot; class=&quot;headerlink&quot; title=&quot;2. 将本地项目 push 到远程&quot;&gt;&lt;/a&gt;2. 将本地项目 push 到远程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git cmt -m &amp;apos;create project&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote add origin git@github.com:yuhanle/resume.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push -u origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="BIGFE" scheme="https://blog.yuhanle.com/categories/BIGFE/"/>
    
    
      <category term="vue" scheme="https://blog.yuhanle.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Go 实现对 HTTP 对象的查找</title>
    <link href="https://blog.yuhanle.com/2018/02/24/seeking-around-in-an-http-object/"/>
    <id>https://blog.yuhanle.com/2018/02/24/seeking-around-in-an-http-object/</id>
    <published>2018-02-24T01:00:00.000Z</published>
    <updated>2018-07-05T01:14:33.978Z</updated>
    
    <content type="html"><![CDATA[<p>已发布：<a href="https://studygolang.com/articles/12638" target="_blank" rel="noopener">https://studygolang.com/articles/12638</a></p><h1 id="Go-实现对-HTTP-对象的查找"><a href="#Go-实现对-HTTP-对象的查找" class="headerlink" title="Go 实现对 HTTP 对象的查找"></a>Go 实现对 HTTP 对象的查找</h1><p>想象一下，在 <code>HTTP</code> 服务器上有一个巨大的 <code>ZIP</code> 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行  <code>unzip -l https://example.com/giant.zip</code> 的操作来查看压缩包的内容呢？</p><p>这并不是一个为了用 <code>Go</code> 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 <a href="https://bulkdata.uspto.gov/data/patent/officialgazette/2017/" target="_blank" rel="noopener">美国专利和商标局（USPTO）</a> 下载大量专利。或者，我认为，能够从这些 <code>tar</code> 文件中获取 <a href="https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/" target="_blank" rel="noopener">1790 年发布的一些专利图像</a> 有多酷？</p><p>去看看。那里有数百个巨大的 <code>ZIP</code> 和 <code>tarfiles</code> 值得探索！</p><a id="more"></a><p>在 <code>ZIP</code> 文件中最后的位置，有一个目录。因此在本地磁盘上，<code>“unzip -l”</code> 就像“寻求最终结果，找到 <code>TOC</code>，解析并打印它”一样简单。事实上，我们可以知道 <code>Go</code> 是如何处理的，因为在 <a href="https://godoc.org/archive/zip#NewReader" target="_blank" rel="noopener"><code>zip.NewReader</code> 函数</a> 需要传入一个文件路径。至于 <code>TAR</code> 文件，它们被设计用于磁带流式传输和内存稀少的时候，因此它们的目录在文件本身之间交错排列。</p><p>但我们不在本地，要从 <code>URL</code> 中读取内容对我们来说很有挑战。该怎么办？从哪里开始？</p><p>我们有几件事需要考虑，然后我们可以规划接下来的方向。寻找和读取 <code>HTTP</code> 文件也就是要找到和读取 <code>Range</code> 标头。那么，<code>USPTO</code> 服务器是否支持 <code>Range</code> 头呢？这很容易检查，使用 <code>curl</code> 和 <code>HTTP HEAD</code> 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -I https://bulkdata.uspto.gov/data/patent/officialgazette/2017/e-OG20170103_1434-1.zip</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 11 Dec 2017 21:10:26 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 03 Jan 2017 11:58:45 GMT</span><br><span class="line">ETag: "afb8ac8-5452f63e0a82f"</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 184257224</span><br><span class="line">X-Frame-Options: DENY</span><br><span class="line">Content-Type: application/zip</span><br></pre></td></tr></table></figure><p>请注意那里的 <code>“Accept-Ranges”</code> 标头，它表示我们可以向它发送字节范围。<code>Range</code> 头允许您像随机访问读取操作系统的一样操作 <code>HTTP</code>。（例如 <a href="https://godoc.org/io#ReaderAt" target="_blank" rel="noopener">io.ReaderAt</a> 接口）</p><p>因此理论上可以选择从 <code>Web</code> 服务器下载其中包含元数据（目录）的文件部分来决定下载哪些字节。</p><p>现在我们需要写一个处理 <code>ZIP</code> 文件格式的方法，它可以让我们使用具有 <code>Range</code> 头部的 <code>HTTP</code> 的 <code>GET</code> 请求，只读取元数据的方式，实现替换“读取下一个目录头文件”的某个部分。这就是 <code>Go</code> 的 <a href="https://golang.org/pkg/archive/zip" target="_blank" rel="noopener"><code>archive/zip</code></a> 和 <a href="https://godoc.org/archive/tar" target="_blank" rel="noopener"><code>archive/tar</code></a> 包的实现！</p><p>正如我们前面所说，<a href="https://godoc.org/archive/zip#NewReader" target="_blank" rel="noopener">zip.NewReader</a> 正在琢磨什么位置开始查找。然而，当我们看看 <code>TAR</code> 时，我们发现了一个问题。<code>tar.NewReader</code> 方法需要一个 <code>io.Reader</code>。<code>io.Reader</code> 的问题在于，它不会让我们随机访问资源，就像<code>io.ReaderAt</code> 一样。它是这样实现的，因为它使 <code>tar</code> 包更具适应性。特别是，您可以将 <code>Go tar</code> 包直接挂接到 <code>compress/gzip</code> 包并读取 <code>tar.gz</code> 文件 - 只要您按顺序读取它们，而不是像我们希望的那样跳过。</p><p>那么该怎么办？使用源码。环顾四周，找找<a href="https://github.com/golang/go/blob/c007ce824d9a4fccb148f9204e04c23ed2984b71/src/archive/tar/reader.go#L88" target="_blank" rel="noopener">下一个方法</a>。这就是我们期望它能够找到下一个元数据的地方。在几行代码内，对于 <a href="https://github.com/golang/go/blob/c007ce824d9a4fccb148f9204e04c23ed2984b71/src/archive/tar/reader.go#L407" target="_blank" rel="noopener"><code>skipUnread</code></a> 函数， 我们发现一个有趣的调用。在那里，我们发现一些非常有趣的东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skipUnread skips any unread bytes in the existing file entry, as well as any alignment padding.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *Reader)</span> <span class="title">skipUnread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nr := tr.numBytes() + tr.pad <span class="comment">// number of bytes to skip</span></span><br><span class="line">  tr.curr, tr.pad = <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> sr, ok := tr.r.(io.Seeker); ok &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := sr.Seek(nr, os.SEEK_CUR); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _, tr.err = io.CopyN(ioutil.Discard, tr.r, nr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: This is from Go 1.4, which had a simpler skipUnread than go 1.9 does.</span></span><br></pre></td></tr></table></figure><p>这里表示：”如果 <code>io.Reader</code> 实际上也能够搜索，那么我们不是直接读取和丢弃，而是直接找到正确的地方。“找到了！我们只需要将 <code>tar</code> 文件传给 <code>io.Reader</code>。<code>NewReader</code> 也满足 <a href="https://golang.org/pkg/io/#Seeker" target="_blank" rel="noopener"><code>io.Seeker</code></a>的功能（因此，它是一个<a href="https://golang.org/pkg/io/#ReadSeeker" target="_blank" rel="noopener"><code>io.ReadSeeker</code></a>）。</p><p>所以，现在请查看包 <a href="https://godoc.org/github.com/jeffallen/seekinghttp" target="_blank" rel="noopener"><code>github.com/jeffallen/seekinghttp</code></a>，就像它的名字所暗示的那样，它是一个用于在 <code>HTTP</code> 对象（<a href="https://github.com/jeffallen/seekinghttp" target="_blank" rel="noopener"><code>Github</code> 上的源代码</a> 中查找的软件包。</p><p>这个软件包不仅<a href="https://github.com/jeffallen/seekinghttp/blob/master/seekinghttp.go#L26" target="_blank" rel="noopener">实现</a>了 <code>io.ReadSeeker</code>，还实现了 <code>io.ReaderAt</code>。</p><p>为什么？因为，正如我上面提到的，读取 <code>ZIP</code> 文件需要一个 <code>io.ReaderAt</code>。它还需要传递给它的文件的长度，以便它可以查看目录文件的末尾。<code>HTTP HEAD</code> 方法可以很好地获取 <code>HTTP</code> 对象的 <code>Content-Length</code>，而不需要下载整个文件。</p><p>用于远程获取 <code>tar</code> 和 <code>zip</code> 文件目录的命令行工具位于 <code>remote-archive-ls</code> 中。打开 <code>“-debug”</code> 选项用来查看日志。<strong>将 <code>Go</code> 的标准库作为 <code>TAR</code> 或 <code>ZIP</code> 阅读器“回调”到我们的代码中，并在这里请求几个字节，这里有几个字节是很有趣的。</strong> </p><p>在我第一次运行这个程序后不久，我发现了一个严重的缺陷。这是一个示例运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./remote-archive-ls -debug <span class="string">'https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/grant_pdf_17900731_18641101.tar'</span></span></span><br><span class="line">2017/12/12 00:07:38 got read len 512</span><br><span class="line">2017/12/12 00:07:38 ReadAt len 512 off 0</span><br><span class="line">2017/12/12 00:07:38 Start HTTP GET with Range: bytes=0-511</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 512</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=512-1023</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 1024</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=1024-1535</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 1536</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=1536-2047</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 2048</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=2048-2559</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/us-patent-image.xml</span><br><span class="line">2017/12/12 00:07:39 got seek 0 1</span><br><span class="line">2017/12/12 00:07:39 got seek 982 1</span><br><span class="line">2017/12/12 00:07:39 got read len 42</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 42 off 3542</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=3542-3583</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 3584</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=3584-4095</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/00000001.pdf</span><br><span class="line">2017/12/12 00:07:39 got seek 0 1</span><br><span class="line">2017/12/12 00:07:39 got seek 320840 1</span><br><span class="line">2017/12/12 00:07:39 got read len 184</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 184 off 324936</span><br><span class="line">...etc...</span><br></pre></td></tr></table></figure><p>你能看到问题吗？这是很多 <code>HTTP</code> 事务！ <code>TAR reader</code> 正在一次一点点地完成 <code>TAR</code> 流，发出一小串 <code>bit</code>。所有这些短的 <code>HTTP</code> 事务在服务器上都很难实现，并且对于吞吐量来说很糟糕，因为每个 <code>HTTP</code> 事务都需要多次往返服务器。</p><p>当然，解决方案是缓存。<strong>读取TAR读取器要求的前 512 个字节，而不是读取其中的 10 倍，以便接下来的几个读取将直接从缓存中获取。</strong>如果读取超出了缓存的范围，我们假设其他读取也将进入该区域，并删除整个当前缓存，以便用当前偏移量的 10 倍填充它。</p><p><code>TAR</code> 阅读器发送<strong>大量小读数</strong>的事实指出了有关缓冲的一些非常重要的事情。将 <a href="https://godoc.org/os#Open" target="_blank" rel="noopener"><code>os.Open</code></a> 的结果直接发送给 <code>tar</code>。<code>NewReader</code> 不是很聪明，尤其是如果你打算跳过文件寻找元数据。尽管 <code>* os.File</code> 实现了 <code>io.ReadSeeker</code>，我们现在知道 <code>TAR</code> 将会向内核发出大量的<strong>小系统调用</strong>。该解决方案与上面的解决方案非常相似，可能是使用 <a href="https://godoc.org/bufio" target="_blank" rel="noopener"><code>bufio</code></a> 包来缓冲 <code>* os.File</code>，以便 <code>TAR</code> 发出的小数据将从 <code>RAM</code> 中取出，而不是转到操作系统。但请注意：它真的是解决方案吗？<code>bufio.Reader</code> 是否真的实现了 <code>io</code>？<code>ReadSeeker</code> 和 <code>io.ReadAt</code> 就像我们需要的一样？ <strong>（破坏者：它没有;也许你们有读者想告诉我们如何使用下一个的替代品 <code>bufio</code> 加速 <code>Go</code> 的 <code>tar</code>？</strong></p><p>我希望你喜欢通过标准库和 <code>HTTP</code>，看看如何与标准库一起工作，以帮助它实现更多的功能，以便它可以帮助你完成你的工作这个小小的旅程。当你实现 <code>io.Reader</code> 和朋友时，你有机会走到你所调用的库的幕后，并从他们的作者从未期望的地方给他们提供数据！</p><hr><p>via：<a href="https://blog.gopheracademy.com/advent-2017/seekable-http/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2017/seekable-http/</a></p><p>作者：<a href="https://github.com/jeffallen" target="_blank" rel="noopener">Jeff R. Allen</a><br>译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a><br>校对：<a href="https://github.com/Unknwon" target="_blank" rel="noopener">Unknwon</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已发布：&lt;a href=&quot;https://studygolang.com/articles/12638&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://studygolang.com/articles/12638&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Go-实现对-HTTP-对象的查找&quot;&gt;&lt;a href=&quot;#Go-实现对-HTTP-对象的查找&quot; class=&quot;headerlink&quot; title=&quot;Go 实现对 HTTP 对象的查找&quot;&gt;&lt;/a&gt;Go 实现对 HTTP 对象的查找&lt;/h1&gt;&lt;p&gt;想象一下，在 &lt;code&gt;HTTP&lt;/code&gt; 服务器上有一个巨大的 &lt;code&gt;ZIP&lt;/code&gt; 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行  &lt;code&gt;unzip -l https://example.com/giant.zip&lt;/code&gt; 的操作来查看压缩包的内容呢？&lt;/p&gt;
&lt;p&gt;这并不是一个为了用 &lt;code&gt;Go&lt;/code&gt; 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 &lt;a href=&quot;https://bulkdata.uspto.gov/data/patent/officialgazette/2017/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美国专利和商标局（USPTO）&lt;/a&gt; 下载大量专利。或者，我认为，能够从这些 &lt;code&gt;tar&lt;/code&gt; 文件中获取 &lt;a href=&quot;https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1790 年发布的一些专利图像&lt;/a&gt; 有多酷？&lt;/p&gt;
&lt;p&gt;去看看。那里有数百个巨大的 &lt;code&gt;ZIP&lt;/code&gt; 和 &lt;code&gt;tarfiles&lt;/code&gt; 值得探索！&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>iOS 真机调试如何安装 WebDriverAgent</title>
    <link href="https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/"/>
    <id>https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/</id>
    <published>2018-01-03T10:30:47.000Z</published>
    <updated>2018-07-05T01:18:16.306Z</updated>
    
    <content type="html"><![CDATA[<p>近期，微信<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">跳一跳外挂</a>火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/wda.png" alt="WDA 工作原理"> </p><p>其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 <a href="https://testerhome.com/topics/7220" target="_blank" rel="noopener">WebDriverAgent · TesterHome</a>，下面就按照这篇教程，各个击破真机调试WDA 的问题：</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/WebDriverAgent.git</span><br></pre></td></tr></table></figure><p>切换到WDA 根目录，运行初始化脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd WebDriverAgent</span><br><span class="line">./Scripts/bootstrap.sh</span><br></pre></td></tr></table></figure><p>以上脚本是安装依赖库，同时使用npm 打包响应的js 文件。感兴趣的同学可以浏览脚本文件，同级目录下还有一个<code>build.sh</code>，也可以直接执行该脚本来编译安装WDA。当然，初次接触，希望一步步操作的话会好一些。</p><p>如果中途出现错误，需要先解决，否则接下来的操作都无法进行。</p><h1 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h1><p>接下来，通过Xcode 打开<code>WebDriverAgent.xcodeproj</code> 这个文件。</p><p>可以先尝试编译一下，方便定位目前存在的问题，使用组合键或者通过鼠标操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command + b</span><br></pre></td></tr></table></figure><p>这个时候，肯定会有提示配置证书的问题，真机调试证书是必须设置的。可以设置个人开发者免费证书，或者其他付费证书。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/WX20180103-141257.png" alt=""></p><p>然后选择<code>WebDriverAgentRunner</code> 这个Target 和 真机设备，执行测试。组合键<code>command+u</code>，或从菜单栏Product 中通过鼠标操作</p><blockquote><p>一切正常的话，手机上会出现一个无图标的WebDriverAgent应用，启动之后，马上又返回到桌面。这是很正常的不要奇怪。</p></blockquote><p>应用教程中的原话，上述现象正常，但是也有可能会在控制台报错，从而无法打印出ip 地址。</p><p>当把所有的流程重新捋一遍，你会发现，根本发现不了哪一步做错了，我遇到的情况就是，一直停留在控制台的那里，不会出现奇迹。经过一番搜索，发现<a href="https://testerhome.com/topics/9666" target="_blank" rel="noopener">有个帖子</a>里的警告提示，我决定放手一搏！</p><blockquote><p>你们以为这样就能运行吗？</p><p>并不是！<br>最关键一步来了：</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>重要的话要说三遍！</p></blockquote><p>反正是在保证数据线连接的情况下，重启一下手机，然后重新build 就成功看到ip 地址！而且在以后操作中，这种情况还会复现，所以重启手机吧，不用浪费无辜的时间研究~</p><p>通过上面给出的IP和端口，加上<code>/status</code>合成一个url地址。例如<code>http://10.0.0.1:8100/status</code>，然后浏览器打开。如果出现一串JSON输出，说明WDA安装成功了。</p><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><p>有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上。关于这个问题，我是通过端口转发才看到效果，所以你也应该会遇到同样的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install imobiledevice</span><br><span class="line">$ iproxy 8100 8100 [4c47766e78f9d84e1da55b07d69f2747e9fb4f71]</span><br></pre></td></tr></table></figure><p>使用iproxy –help 可以查到更具体的用法。 这时通过访问<code>http://localhost:8100/status</code> 确认WDA是否运行成功。</p><p>而inspector的地址是<code>http://localhost:8100/inspector</code>， inspector是用来查看UI的图层，方便写测试脚本用。</p><blockquote><p>注：端口转发后，域名不再是IP 地址，而是你的本机IP或者使用<code>localhost</code>+ 端口号</p></blockquote><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>完成上述操作以后，可以随意开启应用内的某个应用，就能看到如下效果。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/WX20180103-143535.png" alt=""></p><p>这里结合 <a href="https://testerhome.com/topics/7840" target="_blank" rel="noopener">Appium Desktop</a> 一起食用，效果更佳~</p><p>Good luck!!!</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>相信你会对这个感兴趣，通过WDA 做自动化测试，恩！</p><p>接下来演示一下怎么用ATX打开iPhone自带的计时器，开始然后退出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/local/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> atx</span><br><span class="line"></span><br><span class="line">d = atx.connect(<span class="string">"http://localhost:8100"</span>)</span><br><span class="line">d.start_app(<span class="string">"com.apple.mobiletimer"</span>)</span><br><span class="line">d(text=<span class="string">u'计时器'</span>).click()</span><br><span class="line">d(text=<span class="string">u'开始计时'</span>).click()</span><br><span class="line">d(text=<span class="string">u'取消'</span>).click()</span><br><span class="line">d.stop_app()</span><br></pre></td></tr></table></figure><p>执行以上代码即可体验</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>最后墙裂推荐基于Python自动化框架地址 <a href="https://github.com/NetEaseGame/ATX" target="_blank" rel="noopener">https://github.com/NetEaseGame/ATX</a></p><p>Xcode问题多多，愿WDA与你同在。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://testerhome.com/topics/7220" target="_blank" rel="noopener">ATX 文档 - iOS 真机如何安装 WebDriverAgent</a></p><p><a href="https://testerhome.com/topics/8820#reply47" target="_blank" rel="noopener">Macaca App Inspector 2.0 发布</a></p><p><a href="https://testerhome.com/topics/7840" target="_blank" rel="noopener">Appium Desktop 简单介绍 —— xcodebuild failed with code 65 解决</a></p><p><a href="https://testerhome.com/topics/9666" target="_blank" rel="noopener">WebDriverAgent 天坑记</a></p><p><a href="https://testerhome.com/topics/7324" target="_blank" rel="noopener">启动 WebDriverAgent 后再启动 appium，运行脚本一直卡在 Waiting for WebDriverAgent to start on device</a></p><p><a href="https://testerhome.com/topics/6331" target="_blank" rel="noopener">ATX 支持 iOS10 手机测试 方法说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，微信&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跳一跳外挂&lt;/a&gt;火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/wda.png&quot; alt=&quot;WDA 工作原理&quot;&gt; &lt;/p&gt;
&lt;p&gt;其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 &lt;a href=&quot;https://testerhome.com/topics/7220&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebDriverAgent · TesterHome&lt;/a&gt;，下面就按照这篇教程，各个击破真机调试WDA 的问题：&lt;/p&gt;
&lt;h1 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h1&gt;&lt;p&gt;首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地&lt;/p&gt;
    
    </summary>
    
      <category term="UI Auto Test" scheme="https://blog.yuhanle.com/categories/UI-Auto-Test/"/>
    
    
      <category term="WDA" scheme="https://blog.yuhanle.com/tags/WDA/"/>
    
      <category term="UI Test" scheme="https://blog.yuhanle.com/tags/UI-Test/"/>
    
  </entry>
  
  <entry>
    <title>Electron 入门指南</title>
    <link href="https://blog.yuhanle.com/2017/12/16/electron-abc/"/>
    <id>https://blog.yuhanle.com/2017/12/16/electron-abc/</id>
    <published>2017-12-16T06:48:05.000Z</published>
    <updated>2018-07-05T01:17:21.429Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/electron.jpeg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>目前，使用前端技术开发桌面应用越来越成熟，所以前端同学也可以参与桌面应用的开发。目前类似的工具有electron，NW.js等。刚好最近在学习Vue，简单做了些入门页面，B/S 的方式虽然能够跨平台使用，但是对于不折腾会死的周末来说，尝试着踩坑才是最充实的。</p><a id="more"></a><p>这里我们简单介绍下 <a href="https://electron.org.cn/" target="_blank" rel="noopener">Electron</a>的使用。</p><p>Electron 中文网上对于他的功能描述的很直观，也很吸引众多开发者的探索。</p><center><br><h4>比你想象的更容易</h4><br></center><blockquote><p>如果您能够搭建一个网站，那么您就可以搭建一个桌面应用。 Electron是这样一个框架，它可以帮助您使用JavaScript/Html/Css等网站相关技术，非常快速而容易地搭建一个原生应用。这样，您就可以聚焦于您的业务系统本身了，然后把剩下的那些难题交给我们好了。</p></blockquote><h2 id="如何开发"><a href="#如何开发" class="headerlink" title="如何开发"></a>如何开发</h2><p>简单来说，Electron 是基于Node.js 和Chromium 做的一个工具，通过将前端页面加壳的方式，实现桌面开发，并且支持跨平台。</p><p>他是一个工具，除了官方文档上的基础配置，开发相关的只是主要是是前端业务相关，对于工具的使用看文档，论坛交流和更多Demo 的学习足够。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一个最简单的Electron 项目包含三个文件，package.json, index.html, main,js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- package.json Node.js 项目的配置文件</span><br><span class="line">|-- index.html 桌面应用的业务</span><br><span class="line">|-- main.js 应用的启动入口文件</span><br></pre></td></tr></table></figure><p>其中，核心的文件是index.html 和main.js。</p><p>回到最近写的小工具，目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-- voicepkgtool </span><br><span class="line">||-- config webpack配置文件</span><br><span class="line">|||-- dev.env.js </span><br><span class="line">|||-- index.js</span><br><span class="line">||-- dist 发布</span><br><span class="line">||-- node_modules</span><br><span class="line">||-- samples Node.js Server</span><br><span class="line">||-- src 源码目录</span><br><span class="line">||-- main.js Electron 应用入口</span><br><span class="line">||-- package.json配置文件</span><br></pre></td></tr></table></figure><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>推荐查阅官网的教程<a href="https://electron.org.cn/vue/index.html" target="_blank" rel="noopener">Electron-vue</a></p><p>我们这个简单的Web 项目部署以后，希望可以通过Electron 打包跨屏体运行，所以只需要简单几步配置就搞定！</p><h3 id="安装Electron"><a href="#安装Electron" class="headerlink" title="安装Electron"></a>安装Electron</h3><p>在使用前，需要先安装相关模块，然后在项目中引入使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 核心模块</span><br><span class="line">npm install electron -s</span><br><span class="line">// 打包模块 | 也可以使用electron-builder</span><br><span class="line">npm install electron-packager -s</span><br></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>在执行Electron 相关命令并启动应用时，需要一个入口文件，就是上面提到的main.js，文件包含整个应用的生命周期回调，同时也用来存放应用相关配置信息。</p><p>以下便是我们为目前这个小项目编辑的main.js 文件，API 可以参考官方教程。</p><p>注释也可以清楚的了解每一行的含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;)</span><br><span class="line">// Module to control application life.</span><br><span class="line">const app = electron.app</span><br><span class="line">// Module to create native browser window.</span><br><span class="line">const BrowserWindow = electron.BrowserWindow</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line"></span><br><span class="line">// Keep a global reference of the window object, if you don&apos;t, the window will</span><br><span class="line">// be closed automatically when the JavaScript object is garbage collected.</span><br><span class="line">let mainWindow</span><br><span class="line"></span><br><span class="line">function createWindow () &#123;</span><br><span class="line">  // Create the browser window.</span><br><span class="line">  mainWindow = new BrowserWindow(&#123;width: 800, height: 600&#125;)</span><br><span class="line"></span><br><span class="line">  // and load the index.html of the app.</span><br><span class="line">  mainWindow.loadURL(url.format(&#123;</span><br><span class="line">    pathname: path.join(__dirname, &apos;dist/index.html&apos;),</span><br><span class="line">    protocol: &apos;file:&apos;,</span><br><span class="line">    slashes: true</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  // Open the DevTools.</span><br><span class="line">  // mainWindow.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">  // Emitted when the window is closed.</span><br><span class="line">  mainWindow.on(&apos;closed&apos;, function () &#123;</span><br><span class="line">    // Dereference the window object, usually you would store windows</span><br><span class="line">    // in an array if your app supports multi windows, this is the time</span><br><span class="line">    // when you should delete the corresponding element.</span><br><span class="line">    mainWindow = null</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This method will be called when Electron has finished</span><br><span class="line">// initialization and is ready to create browser windows.</span><br><span class="line">// Some APIs can only be used after this event occurs.</span><br><span class="line">app.on(&apos;ready&apos;, createWindow)</span><br><span class="line"></span><br><span class="line">// Quit when all windows are closed.</span><br><span class="line">app.on(&apos;window-all-closed&apos;, function () &#123;</span><br><span class="line">  // On OS X it is common for applications and their menu bar</span><br><span class="line">  // to stay active until the user quits explicitly with Cmd + Q</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(&apos;activate&apos;, function () &#123;</span><br><span class="line">  // On OS X it&apos;s common to re-create a window in the app when the</span><br><span class="line">  // dock icon is clicked and there are no other windows open.</span><br><span class="line">  if (mainWindow === null) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// In this file you can include the rest of your app&apos;s specific main process</span><br><span class="line">// code. You can also put them in separate files and require them here.</span><br></pre></td></tr></table></figure><h3 id="编辑脚本"><a href="#编辑脚本" class="headerlink" title="编辑脚本"></a>编辑脚本</h3><p>入口文件的路径，我们需要通过键值对的方式，新增在package.json 文件里，同时可以在Scripts 里添加启动、编译以及打包的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;voicepkgtool&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A Vue.js project&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;shibo.wen@ti-link.com.cn&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;,// 入口文件路径 不可缺少 否则执行时会报错</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;electron .&quot;,// 启动应用</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --env.dev&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack -p --progress --hide-modules&quot;,</span><br><span class="line">    &quot;build:all&quot;: &quot;electron-packager . voicepkgtool --platform=all --arch=all -version=0.0.1 --icon=app.ico --out=Staging --version-string.ProductName=Telar Converter --version-string.ProductVersion=0.5.0&quot;,</span><br><span class="line">    &quot;package&quot;: &quot;electron-packager ./ voicepkgtool --all --out ./ --version 0.0.1 --overwrite&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;axios&quot;: &quot;^0.17.1&quot;,</span><br><span class="line">    &quot;checksum&quot;: &quot;^0.1.1&quot;,</span><br><span class="line">    &quot;electron&quot;: &quot;^1.7.9&quot;,</span><br><span class="line">    &quot;electron-packager&quot;: &quot;^10.1.0&quot;,</span><br><span class="line">    &quot;element-ui&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;file-saver&quot;: &quot;^1.3.3&quot;,</span><br><span class="line">    &quot;jszip&quot;: &quot;^3.1.5&quot;,</span><br><span class="line">    &quot;qs&quot;: &quot;^6.5.1&quot;,</span><br><span class="line">    &quot;querystring&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.5.2&quot;,</span><br><span class="line">    &quot;vue-simple-uploader&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;webpack-merge&quot;: &quot;^4.1.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;=6&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;autoprefixer&quot;: &quot;^6.6.0&quot;,</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^6.4.0&quot;,</span><br><span class="line">    &quot;babel-preset-vue-app&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^0.27.0&quot;,</span><br><span class="line">    &quot;file-loader&quot;: &quot;^0.10.1&quot;,</span><br><span class="line">    &quot;html-webpack-plugin&quot;: &quot;^2.24.1&quot;,</span><br><span class="line">    &quot;postcss-loader&quot;: &quot;^1.3.3&quot;,</span><br><span class="line">    &quot;rimraf&quot;: &quot;^2.5.4&quot;,</span><br><span class="line">    &quot;style-loader&quot;: &quot;^0.13.2&quot;,</span><br><span class="line">    &quot;url-loader&quot;: &quot;^0.5.8&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^2.4.1&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^2.4.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>一个跨屏台的应用就展现在桌面上。</p><h3 id="构建打包"><a href="#构建打包" class="headerlink" title="构建打包"></a>构建打包</h3><p>进阶教程参考<a href="https://electron.org.cn/build.html" target="_blank" rel="noopener">Electron构建打包</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">electron-packager . --overwrite --platform=darwin --arch=x64 --out=out --icon=assets/app-icon/mac/app.icns --osx-sign.identity=&apos;Developer ID Application: GitHub&apos; --extend-info=assets/mac/info.plist</span><br><span class="line"></span><br><span class="line">electron-packager . --overwrite --platform=win32 --arch=ia32 --out=out --icon=assets/app-icon/win/app.ico</span><br><span class="line"></span><br><span class="line">electron-packager . --overwrite --platform=linux --arch=x64 --out=out</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="Electron-不支持XP-系统"><a href="#Electron-不支持XP-系统" class="headerlink" title="Electron 不支持XP 系统"></a>Electron 不支持XP 系统</h3><p>如果有考虑在XP 系统上使用，不用考虑了</p><p>参考：<a href="https://js3.org/question/43" target="_blank" rel="noopener">https://js3.org/question/43</a></p><h3 id="安装包大小"><a href="#安装包大小" class="headerlink" title="安装包大小"></a>安装包大小</h3><p>一般情况下，通过packager或者builder打包完毕后，exe、dll、asr等文件总和的大小为100M左右。而通过builder制作的nsis安装包，一般为32M左右。通过innosetup生成的安装包，一般为31M左右。总体来说，体积较大。但是您通过一系列的手段可以有效的减少它的体积，到一个可接受的范围。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><p>浏览器窗口的开发工具仅能调试渲染器的进程脚本（比如 web 页面）。为了提供一个可以调试主进程 的方法，Electron 提供了 –debug 和 –debug-brk 开关。</p><p>使用如下的命令行开关来调试 Electron 的主进程：</p><p>–debug=[port]</p><p>当这个开关用于 Electron 时，它将会监听 V8 引擎中有关 port 的调试器协议信息。 默认的 port 是 5858。</p><p>–debug-brk=[port]</p><p>就像 –debug 一样，但是会在第一行暂停脚本运行。</p><h2 id="Electron-常见问题"><a href="#Electron-常见问题" class="headerlink" title="Electron 常见问题"></a>Electron 常见问题</h2><p>如何解决下载源的时候timeout问题<br>对于国内的网络用户，请切换npm源为淘宝的cnpm源，切换方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br><span class="line">npm config set electron_mirror http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><p>另外，对于文件构建时的timeout问题，需要您下载对应的文件到本地缓存文件夹。具体的下载切换办法，可以点击这里查看：<a href="https://js3.org/article/7" target="_blank" rel="noopener">https://js3.org/article/7</a></p><p>更多问题参考：<a href="https://electron.org.cn/doc/faq.html" target="_blank" rel="noopener">Electron 常见问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/electron.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;目前，使用前端技术开发桌面应用越来越成熟，所以前端同学也可以参与桌面应用的开发。目前类似的工具有electron，NW.js等。刚好最近在学习Vue，简单做了些入门页面，B/S 的方式虽然能够跨平台使用，但是对于不折腾会死的周末来说，尝试着踩坑才是最充实的。&lt;/p&gt;
    
    </summary>
    
      <category term="BIGFE" scheme="https://blog.yuhanle.com/categories/BIGFE/"/>
    
    
      <category term="electron" scheme="https://blog.yuhanle.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>Xcode9.2 编译在iOS8.1 系统上图片显示异常</title>
    <link href="https://blog.yuhanle.com/2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/"/>
    <id>https://blog.yuhanle.com/2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/</id>
    <published>2017-12-09T01:52:47.000Z</published>
    <updated>2018-07-31T01:34:00.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最新消息"><a href="#最新消息" class="headerlink" title="最新消息"></a>最新消息</h2><blockquote><p>目前 xcode 9.3 已经解决了该问题</p></blockquote><blockquote><p>Asset Catalog<br>Known Issues<br>When using Xcode 9.2 to create apps that deploy to iOS 8 and later, images in the asset catalog may be corrupted when viewed on devices running iOS 8.3 and earlier. (35379713)<br>Workaround: Build the app using Xcode 9.1, or use Xcode 9.2 and set the deployment target to iOS 8.4 or later.</p></blockquote><hr><p>趁着下载 <code>Xcode 9.1</code> 的空隙，在周末的早晨记录一下这个坑，希望能解决相同遭遇同行的困惑。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/0342bcd3280e6eaafcd3e99e0f4bc362.jpg" alt=""></p><h2 id="始因"><a href="#始因" class="headerlink" title="始因"></a>始因</h2><p>昨天刚发布了适配 <code>iPhone X</code> 的最新版本，之所以使用 <code>Xcode 9.2</code> 打包，是因为早期的适配，通过 <code>Xcode 8.2</code> 打包，安装到 <code>iPhone X</code> 上显示的效果是没有适配。</p><a id="more"></a><p>这个也是无法解释的，我们开发使用的 <code>Xcode 9</code>，在适配过程中没有遇到该问题，总是升级就对了。</p><p>刚好最近苹果爹发布了 <code>Xcode 9.2</code>，就索性升级到最新版本。</p><p>持续化集成就是方便，代码提交以后，喝杯咖啡的工具，就上传成功，等待审核。</p><p>也就是在昨天中午，收到审核通过的提醒，很奇怪，这个时候应该是他们休息的时间。</p><p>然后，就非常肯定，因为在适配的过程中，特意找了两个 <code>iPhone X</code> 的用户帮助测试体验。随着审核通过，就很快发布出去。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>大概下午3点钟，距离发布版本只过了 3 个小时左右。收到客服妹子的一个大写的问号。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/WX20171209-100043@2x.png" alt=""></p><p>这一瞬间，整个人都是懵的，慌忙让用户重启 <code>APP</code>，重启系统，升级系统，最后被用户拒绝掉。</p><p>既然是必现的问题，不能将问题推到升级系统上，该解决还是要尽快解决的。</p><p>接着就开始着手另外一个项目，晚上回到家开始思考，问题存在的版本近期究竟改了什么内容。同时也下载了 <code>iOS8.1</code> 的模拟器，使用最新版本的 <code>Xcode</code> 运行看了下效果，确实如此是复现的。</p><p>所以，要马上改变态度，和客服同志搞好关系，早点认错才能走得更远。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/WX20171209-101223@2x.png" alt=""></p><h2 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h2><h3 id="1-删掉LaunchScreen-sb-文件"><a href="#1-删掉LaunchScreen-sb-文件" class="headerlink" title="1. 删掉LaunchScreen.sb 文件"></a>1. 删掉LaunchScreen.sb 文件</h3><p>为了适配 <code>iPhone X</code> 的启动图，同时在启动后使用启动图做了简单的效果，决定使用 <code>LaunchImage</code> 的方式设置启动图。</p><p>在更改代码后，尝试了一下修改结果，依然是非正常的。</p><p>效果如下，丝毫没有改变：</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator Screen Shot - iPhone 6 - 2017-12-09 at 10.17.01.png" alt=""></p><h3 id="2-Xcode-版本升级"><a href="#2-Xcode-版本升级" class="headerlink" title="2. Xcode 版本升级"></a>2. Xcode 版本升级</h3><p>这次的改动比较小，所以在排除上述的改动后，直接想到的就是可能就是这个问题，但是很少会怀疑苹果爹会挖这么大的坑，让开发者跳进去。</p><p>不管如何，降级版本试试就知道是不是这个原因。</p><table><thead><tr><th>Xcode9.2</th><th>Xcode9.1</th></tr></thead><tbody><tr><td><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator Screen Shot - iPhone 6 - 2017-12-09 at 10.17.01.png" alt="修改前"></td><td><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator%20Screen%20Shot%20-%20iPhone%206%20-%202017-12-09%20at%2010.51.55.png" alt="修改后"></td></tr></tbody></table><p>通过上述对比，确定问题就处在 <code>Xcode</code> 版本上。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-等苹果爹更新"><a href="#1-等苹果爹更新" class="headerlink" title="1. 等苹果爹更新"></a>1. 等苹果爹更新</h3><p>如果苹果爹一直没注意到这个问题，或者没有人提，谁知道还要等多久？<br>关于此问题，我已经向苹果爹提交了 <code>bug</code>，期待后续修复：</p><p><a href="https://bugreport.apple.com/web/?problemID=35948702" target="_blank" rel="noopener">ProblemID=35948702</a></p><h3 id="2-先降级-Xcode"><a href="#2-先降级-Xcode" class="headerlink" title="2. 先降级 Xcode"></a>2. 先降级 Xcode</h3><p>确切的说，这是目前最快捷的一个方式，保证没有问题</p><h3 id="3-改变图片资源存储"><a href="#3-改变图片资源存储" class="headerlink" title="3. 改变图片资源存储"></a>3. 改变图片资源存储</h3><p>图片不要放在 <code>asset</code> 里面，方法放在<code>bundle</code> 里面就没问题。不知道是 <code>Xcode9.2</code> <code>bug</code> 还是没设置相关属性</p><h3 id="4-资源问题优化"><a href="#4-资源问题优化" class="headerlink" title="4. 资源问题优化"></a>4. 资源问题优化</h3><p>换成9.1，不过我发现 @2x, @3x 这三个图标都填满的就没这 <code>BUG</code>，只放一个才有</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cocoachina.com/bbs/read.php?tid=1729079" target="_blank" rel="noopener">Xcode9.2 运行iOS8.1图片异常</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最新消息&quot;&gt;&lt;a href=&quot;#最新消息&quot; class=&quot;headerlink&quot; title=&quot;最新消息&quot;&gt;&lt;/a&gt;最新消息&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;目前 xcode 9.3 已经解决了该问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Asset Catalog&lt;br&gt;Known Issues&lt;br&gt;When using Xcode 9.2 to create apps that deploy to iOS 8 and later, images in the asset catalog may be corrupted when viewed on devices running iOS 8.3 and earlier. (35379713)&lt;br&gt;Workaround: Build the app using Xcode 9.1, or use Xcode 9.2 and set the deployment target to iOS 8.4 or later.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;趁着下载 &lt;code&gt;Xcode 9.1&lt;/code&gt; 的空隙，在周末的早晨记录一下这个坑，希望能解决相同遭遇同行的困惑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yuhanle/blogbag/raw/master/uploads/images/0342bcd3280e6eaafcd3e99e0f4bc362.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;始因&quot;&gt;&lt;a href=&quot;#始因&quot; class=&quot;headerlink&quot; title=&quot;始因&quot;&gt;&lt;/a&gt;始因&lt;/h2&gt;&lt;p&gt;昨天刚发布了适配 &lt;code&gt;iPhone X&lt;/code&gt; 的最新版本，之所以使用 &lt;code&gt;Xcode 9.2&lt;/code&gt; 打包，是因为早期的适配，通过 &lt;code&gt;Xcode 8.2&lt;/code&gt; 打包，安装到 &lt;code&gt;iPhone X&lt;/code&gt; 上显示的效果是没有适配。&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="https://blog.yuhanle.com/categories/tools/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>升级 macOS High Sierra 后与 Cocoapods 的兼容问题</title>
    <link href="https://blog.yuhanle.com/2017/12/06/macos-high-sierra-with-cocoapods/"/>
    <id>https://blog.yuhanle.com/2017/12/06/macos-high-sierra-with-cocoapods/</id>
    <published>2017-12-06T03:42:36.000Z</published>
    <updated>2018-07-05T01:19:13.989Z</updated>
    
    <content type="html"><![CDATA[<p>当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？</p><p>最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚</p><p>不过在使用 Cocoapods 的时候还是遇到了问题：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">06-Dec-2017 09:28:38/Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-1550561307052749322.sh: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory</span><br><span class="line">06-Dec-2017 11:24:58env: ruby_executable_hooks: No such file or directory</span><br><span class="line">06-Dec-2017 11:30:11/Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-5355633338674781643.sh: line 7: pod: command not found</span><br><span class="line">06-Dec-2017 11:31:27env: ruby_executable_hooks: No such file or directory</span><br></pre></td></tr></table></figure><p>看起来是 Cocoapods 依赖的 Ruby 版本问题，Google 一下，发现已经有人在 Cocoapods 的 repo 下提了这个 <a href="https://github.com/CocoaPods/CocoaPods/issues/6778" target="_blank" rel="noopener">issue</a>，下面也有开发者给出了解决方案：重新安装 Cocoapods. </p><p>Pod 命令需要用到 2.0 版本的 Ruby 解释器 <code>/System/Library/Frameworks/Ruby.framework/Versions/2.0</code>，而 <code>macOS High Sierra</code> 将系统的 Ruby 解释器升级到了 <code>2.3</code> <code>/System/Library/Frameworks/Ruby.framework/Versions/2.3</code>，因此执行 pod 命令的时候由于找不到 Ruby 解释器而报错。</p><p>于是按照提示重装 Cocoapods：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>安装完成后继续执行 pod install，又报了同样的错误。我决定继续重装一次 Cocoapods，不过这次加上 –verbose 参数，看看安装过程中做了哪些操作。log 太长我就不贴了，不过注意到最后输出的 pod 命令位置似乎跟上面执行 which pod 输出有点不一样，它是 /usr/bin/pod，而 which pod 的输出是 /usr/local/bin/pod，再看一下我的 $PATH 路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/Users/tianyi/.rvm/gems/ruby-2.4.1/bin:/Users/tianyi/.rvm/gems/ruby-2.4.1@global/bin:/Users/tianyi/.rvm/rubies/ruby-2.4.1/bin:/Users/tianyi/.rvm/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin:/Users/tianyi/.jenv/shims:/Users/tianyi/.jenv/bin:/opt/subversion/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Server.app/Contents/ServerRoot/usr/bin:/Applications/Server.app/Contents/ServerRoot/usr/sbin:/usr/local/go/bin:/Users/tianyi/bin:/Users/tianyi/goProject/bin:/usr/local/go/bin:/usr/local/Cellar/nginx/1.12.0/bin:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>可以看到在我的 $PATH 环境变量里，/usr/local/bin 的优先级是高于 /usr/bin 的，因此当这两个地方都存在一个名叫 pod 的命令时，系统优先执行 /usr/local/bin/pod，于是错误就这么产生了。因此我直接删除 /usr/local/bin/pod 文件，再执行 pod install –verbose，这一次果然安装成功了。</p><p>这个问题应该是由于 Cocoapods 改变了安装路径导致的，记得 macOS 启用 System Integrity Protection 之后 Cocoapods 的安装路径也修改过，这次应该也是类似的问题吧，由于 $PATH 这个环境变量的问题，导致老版本的 pod 命令优先被执行。</p><p>事情至此还未结局</p><p>本地执行pod 指令已经没问题了，但是我们通过Bamboo 集成，使用脚本打包，却一直重复前面的错误无法自拔。</p><p>重启bamboo 服务，依然不能解决问题</p><p>尝试着使用重启治百病的手段，电脑关机重启试试看！</p><p>祈祷中…🙏</p><p>2017年12月6日午时三刻更</p><p>说了你可能不相信，重启电脑后，一切问题都好了~</p><p>更新</p><p>解决macOS Sierra下注册机无法运行的问题</p><p>很多软件都不兼容了<br>「安全性与隐私」设置中「任何来源」选项消失<br>几乎所有注册机都用不了</p><p>恢复任何来源选项<br>ps：如果系统升级前就已经选择了任何来源，升级后还会正常显示</p><p>打开终端(Terminal.app)<br>执行<code>sudo spctl --master-disable</code></p><p>“任何来源”恢复~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？&lt;/p&gt;
&lt;p&gt;最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚&lt;/p&gt;
&lt;p&gt;不过在使用 Cocoapods 的时候还是遇到了问题：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>伙计们，Go 并没有那么简单</title>
    <link href="https://blog.yuhanle.com/2017/12/04/go-is-not-very-simple-folks/"/>
    <id>https://blog.yuhanle.com/2017/12/04/go-is-not-very-simple-folks/</id>
    <published>2017-12-04T01:00:00.000Z</published>
    <updated>2018-07-05T01:14:17.624Z</updated>
    
    <content type="html"><![CDATA[<p>已发布：<a href="https://studygolang.com/articles/12330" target="_blank" rel="noopener">https://studygolang.com/articles/12330</a></p><h1 id="伙计们，Go-并没有那么简单"><a href="#伙计们，Go-并没有那么简单" class="headerlink" title="伙计们，Go 并没有那么简单"></a>伙计们，Go 并没有那么简单</h1><p>出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。</p><p>到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。</p><a id="more"></a><p>社区实际上并不那么令人愉快，特别是那些因为它的简单性而主张使用 Go 的人。似乎简单已经成为 Go 社区中的一个流行语，许多人反复重复提到这点，却没有给出太多实际的想法。</p><p>这对我来说似乎很不幸，因为在我看来，Go 是一个“极其简单的语言”：</p><ol><li>不应该作为考虑使用 Go 的主要原因</li><li>从他们的关注点中找到其他更有利的推荐理由</li><li>甚至不是真的（不是真的简单）</li></ol><p>在这篇文章中，我想围绕 Go 来分析一些简单观点。</p><p><em>在深入之前，我想强调一件事情</em>：这篇文章并不是对 Go 的批评，而是一种对 Go 的宣传和倡导的方式。有时候，我可能会批评这个语言的某个方面，但这不是我们关注的重点，我只会试图用一种非正式的、事实的，每种语言都会涉及的方式来讲述。</p><h2 id="我来自哪里"><a href="#我来自哪里" class="headerlink" title="我来自哪里"></a>我来自哪里</h2><p>出于工作和业余爱好，我同时使用多种编程语言。我不赞成有“最喜欢的语言”的概念。过去我曾经有过一些最喜欢的语言，但这种认识往往是一时的情感，随着时间推移，会发生变化。</p><p>在我的工作中，我使用 <code>C++</code> 和 <code>Python</code> 写大型服务的后端代码。过去我曾经在一个你可能知道的操作系统上工作，而且我也做了嵌入式工作。在业余项目中，我做了其他各种事情。</p><p>我并不是夸耀什么（我不是一个专家），我只是想表明，我在编程的许多领域至少有一些见解，而且我一直努力保持开放的心态。</p><p>所以，不要着急，让我们开始讨论正题，看看几个观点。</p><h3 id="1-“与主流语言相比，Go-的关键字非常少”"><a href="#1-“与主流语言相比，Go-的关键字非常少”" class="headerlink" title="1. “与主流语言相比，Go 的关键字非常少”"></a>1. “与主流语言相比，Go 的关键字非常少”</h3><p>我从一个最常见的例子开始。当推广 Go 时，这会是大家的口头禅。</p><p>首先，即使它是真实的，我不知道为什么关键字数量会是判断一个语言的学习曲线或复杂性的重要依据。当然，如果有成千上万的关键字，这可能是一个问题。但是大多数语言最多只有几十个关键字，这种规模下，关键字的多少是无关紧要的。</p><p>我还没有听到有人因为关键字的数量而抱怨某门语言</p><p>其次，Go 所谓的“很少”的关键字实际上只不过是一个聪明律师的伎俩（也许，我甚至会认为这是 Go 的虚假广告）。<a href="https://golang.org/ref/spec#Keywords" target="_blank" rel="noopener">Go 规范</a> 列出了 25 个关键字，这的确比大多数语言要少些。但在我看来，Go 并没有比其他语言关键字表示更少的概念，Go 虽然没有这些关键字，但相应的概念依然是语言的一部分（即实际的复杂性保持不变）。</p><p>为了说明我的意思，请考虑一个 <code>while</code> 循环。 Go 没有这个关键字，这是真的，但它仍然有一个 while 循环，<a href="https://tour.golang.org/flowcontrol/3" target="_blank" rel="noopener">文档</a>甚至是这样说的，它的目的只是重用其他关键字。</p><p>另一个这样的例子是 <code>private</code> 和 <code>public</code>。 Go 没有这些关键字，但它仍然有 <code>private</code> 和 <code>public</code>，它只是使用字母大小写而不是关键字。</p><p>用来删减关键字的另一个技巧叫 <a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">预定义标识符（Predeclared identifiers）</a>，在技术上它不是关键字，但是在实践中仍然需要它们，创建一个和它同名的变量仍然不是一个好主意，因此，最后看来…它们基本上是关键字。此外，其中一些预定义标识符是其他语言的关键字，因此仅将它们与 Go 的关键字列表进行比较是非常不公平的。就像苹果和桔子。</p><h3 id="2-接收者参数"><a href="#2-接收者参数" class="headerlink" title="2. 接收者参数"></a>2. 接收者参数</h3><p><a href="https://tour.golang.org/methods/1" target="_blank" rel="noopener">接受者参数</a>对我来说有些古怪。看起来 Go 似乎并不建议使用 <code>this</code> 和 <code>self</code>，但是仍然需要方法，所以就存在 “接收者参数”，除了方法签名看上去很奇怪之外，它们基本上是一样的。</p><p>接收者参数有一个问题，当访问一个方法时，我需要知道接收者参数（这是任意的）的名称，以明确这个方法的作用。因为缺少关键字（译注：如 this），语法高亮成为一个问题。（看吧？这是如何减少关键字实际上使事情变得更加复杂的例子。）这有点像 <code>C++</code> 中的隐式 <code>this</code>。</p><p>这里有一个新人容易混淆的<a href="https://stackoverflow.com/questions/17932722/go-difference-between-parameter-and-receiver" target="_blank" rel="noopener">例子</a>。</p><p>恕我直言，最简单、最直接的方式来表达一个接收器是 <a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank" rel="noopener">UFCS</a>，而不是 C++ 或 Go 的方式。但就像我说的，我不是在抱怨 Go，我真的不介意接受者参数的观点（如果我忍受不了 C++ 的怪异，我可以忍受 Go 的）。</p><h3 id="3-函数返回值"><a href="#3-函数返回值" class="headerlink" title="3. 函数返回值"></a>3. 函数返回值</h3><p>如果接收参数不够，函数甚至能够通过各种形式的返回值来声明。通常语言允许你通过 <code>return</code> 语句返回函数中的一个值。而在 Go 语言中，你可以返回多个值（我认为可以用更优雅的方式通过元组来解决，但是就这样吧）。除此之外，还有<a href="https://tour.golang.org/basics/7" target="_blank" rel="noopener">命名返回值</a>。在我看来，并不是一个好主意，因为它允许我们在那些很难找到返回值的地方写上晕头转向的代码。结合接收方参数，您可以创建这样的函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foobar)</span> <span class="title">Something</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> <span class="params">(foo <span class="keyword">int</span>, bar <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是有效的 Go 代码。如您所见，有三个参数。我真的不希望任何人试图选择这个“简单”，因为这个语法除了简单，什么也不是。</p><h3 id="4-“没有继承”"><a href="#4-“没有继承”" class="headerlink" title="4. “没有继承”"></a>4. “没有继承”</h3><p>Go（或许只是社区）似乎很反对“传统的 OOP”（不管这是指哪个，可能是 Java 或者 C++），我记得有人说 Go 没有继承是一件好事。</p><p>除此之外，Go 有一个功能叫做<a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">嵌入</a>，这个文档以及一些博客文章声称 Go 没有继承。我试着用各种方式使用它，我没法认为 Go 反对继承。上面链接的文档说：</p><blockquote><p>还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法，但当它们被调用时，该方法的接收者是内部类型，而非外部的。</p></blockquote><p>有差别吗？继承通常以相同的方式工作，继承的方法也对内部类型起作用。</p><p>在我看来，在 Go 中，真正唯一不同的是，多态性从结构中解耦。你需要使用接口来使用多态性。但一旦你做了，做的事情和传统的 OOP 非常相似，包括方法覆盖 - <a href="https://play.golang.org/p/DRozP3HCAk" target="_blank" rel="noopener">这里是个演示</a>。</p><p>关于 Go，有件事令我很惊讶 —— 这门所谓简单的语言 —— 你甚至可以实现多重继承。<strong>确实很糟糕。</strong> <a href="https://groups.google.com/forum/#!topic/golang-nuts/fRfkPNlA7Pk" target="_blank" rel="noopener">golang-nut 的邮件列表</a>中，有人提到，Go 并不能很好的处理继承的歧义。我已经调整了其中提及的代码，以便它展示了著名的“可怕的钻石问题”（Dreaded diamond problem）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">T2</span><br><span class="line">T3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">T4</span><br><span class="line">foo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">struct</span> &#123;</span><br><span class="line">T4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T4 <span class="keyword">struct</span> &#123;</span><br><span class="line">foo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t2 := T2&#123; T4&#123; <span class="number">9000</span> &#125;, <span class="number">2</span> &#125;</span><br><span class="line">t3 := T3&#123; T4&#123; <span class="number">3</span> &#125; &#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t2.foo)</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t3.foo)</span><br><span class="line">t1 := T1&#123;</span><br><span class="line">t2,</span><br><span class="line">t3,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t1.foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://play.golang.org/p/cSCLyGHssR" target="_blank" rel="noopener">在线运行以上代码</a></p><p>上面的代码没有任何编译时警告或者错误。<a href="https://ideone.com/gfKYqR" target="_blank" rel="noopener">这是 C++ 的类似的代码</a>，你可以看到，它编译不通过，因为存在歧义。</p><p>结果会如何？首先，我认为具有多重继承功能，几乎不能在描述该编程语言时使用“简单”一词。<strong>在我看到上面的代码后，没有人能说服我，Go 是最简单的语言之一，甚至连简单语言都不算。</strong>甚至没有其他一些你可以用嵌入来做的事情，比如通过指针嵌入或者通过指针嵌入接口。 （我甚至不确定这些功能的真正含义。）</p><p>其次，我想做一个简短、对 Go 语言本身的批评。不处理这样的歧义似乎是一个设计或者实现错误。甚至连 C++ 都没有如此疯狂，让这种代码编译通过。这足以告诉你一些事情。</p><h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><p>各种错误处理通常会导致一个巨大的口水战。我不想谈那件事。我曾经在不同的语言中使用过所有常见的错误处理风格（我认为），我也不喜欢所有这些语言。我认为，错误处理无论什么一直是一个 <code>PITA</code>（译注：应该是国外的一种比喻）。把一种风格换成另一种风格，你只需把一套问题换成另一套。没有好的方法。</p><p>回到简单的话题：Go 让我选择不使用异常，这使事情更简单了。多个返回值的特征不能使事情变得简单，这意味着不能返回一个错误或成功的结果，你可以返回所有值或者都不返回（<code>CS</code> 术语，你可以说这个问题是一个产品类型而不是总和式的用法）。事实上，我看过的许多对于新人的代码审查。</p><p>如果 Go 不允许多个返回值，而有一些合适的或者喜欢的类型，在我看来，这会使事情变得更简单。出于同样的原因，在 Go 中忽略错误或者不向向调用者或其他适当目的地报告错误是相当容易的。</p><p>另一不简单的是 panic。不要误解我的意思，我理解它在 Go 中存在的原因以及它的用处，事实上，其他语言也有类似的处理。我只是提出来作为反对简单性的一个论据。恕我直言，对于一个新人，很可能会混淆 error 和 panic 之间的区别，以及什么时候适合用什么。</p><h3 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6. 泛型"></a>6. 泛型</h3><p>这个主题和错误处理比起来，可能是一个更大的蠕虫。</p><p>和 errors 一样，我只想考虑一下这里的复杂性或者简单性。Go 社区的许多人似乎认为，泛型的本质上是复杂的（=坏，嗯嗯嗯咳），有这样或那样的巨大开销。这在某种程度上是事实，但我不认为它像有些人描述的那么糟糕。似乎那些人已经经历了 <code>C++</code> 模板的痛苦，从那以后，无论何时提及泛型，都会遭受 PTSD（创伤后应激障碍） 的攻击。</p><p>看到这里的人，<strong>泛型不是一个怪物</strong>。它们当然绝对不应该像 <code>C++</code> 那样复杂（或者其他一些奇怪的语言）。我的意思是，甚至前端的人都用泛型工作了一段时间（TypeScript, Flow, …），如果他们不害怕泛型，其他程序员应该是没有理由害怕：）（对不起，前端开发者，只是开个玩笑。）</p><p>人们还没有意识到，如果正确地使用泛型，它可以使许多类型和函数的使用更加简单。例如，考虑 Go 中的<a href="https://golang.org/pkg/container/heap/" target="_blank" rel="noopener">堆接口</a>。这就是从一个堆中声明这个接口的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popped := heap.Pop(&amp;someheap)</span><br><span class="line">myfoo := popped.(*Foo)       <span class="comment">// ZOMG what just happened here?</span></span><br></pre></td></tr></table></figure><p>对新人解释这些，包括 panic 的问题。也许可以考虑一下，如果他们没有真正把整个 <code>interface{}</code> 搞对，那么会发生什么。相比之下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfoo := heap.Pop(&amp;someheap) <span class="comment">// myfoo has the correct type</span></span><br></pre></td></tr></table></figure><p>这更容易阅读、更容易解释（你解释它，就像你将解释 <code>map</code> 类型已经存在于 Go！）。而且在编写代码时也更难弄乱。</p><p>缺乏泛型是造成额外复杂性的原因，它在 Go 的其他部分也会造成相当多的复杂性，主要是需要存在各种“神奇”的函数/类型。<code>map</code>，<code>slice</code> 和 <code>channel</code> 类型的魔法，以及伴随的 <code>make()</code> 功能，这是它们三个的构造函数。<code>slice</code> 类型既可以作为数组的引用，也可以作为动态数组。（不管发生什么事，“做一件事，并做好它”？）</p><p>（只是为了提醒大家，我并不介意这些，只是为了不简单的争论而提及它。）</p><h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h3><p>我想我已经把主要的简单违反者排除在外了。我的单子上只剩下几个简单的：</p><ol><li><code>&lt;-</code> 和 <code>-&gt;</code> 操作符。这些可能只是 <code>channel</code> 类型的方法。</li><li><code>iota</code> - 基本一样，但奇怪的枚举。</li><li>内置的复数。</li><li><a href="https://tour.golang.org/flowcontrol/6" target="_blank" rel="noopener">if 支持短语句</a>（有时可能有用，但 <code>if</code> 语法比其他语言中更复杂）</li></ol><p>我想就是这样。可能忘记了什么，但我想已经足够了。</p><p>那么，我觉得如果不是简单的话，Go 实际上会带来什么呢？</p><h2 id="任务-“goroutines”"><a href="#任务-“goroutines”" class="headerlink" title="任务 - “goroutines”"></a>任务 - “goroutines”</h2><p>这可能看起来有点显而易见，因为 <code>goroutines</code> 是一个经常被提及的特性，就像“简单”一样，所以我觉得需要区分下：我认为这不是通常意义上的并发性，它不能认为是 Go 的优势。不要误解我的意思，Go 的并发性是没问题的。只是说这没有什么特别的。你有 channel，这肯定是好的，但基本上，它们只是像我在别处常用的并发队列。然后你有常规的并发原语，像 mutex，读写锁，条件变量等。你可以同步你的代码，你可能会遇到像许多其他语言一样的竞争条件和死锁。</p><p>我喜欢 <code>goroutines</code>（除了明显的事实，它们是轻量级的用户空间线程）是它们可以使用 I/O 的方式 - 调度连接到主机操作系统的低级 I/O API 的方式（如 epoll、kqueue、IOCP…）。这对于程序员来说通常很难做出令人愉快和有用的东西，特别是在编译本地语言的时候。我仍然在这里了解细节，但在我看来，这是一个很好的做法，也是为什么我认为 Go 是未来工程的一个亮点。</p><p>正如已经暗示的，我也喜欢 Go 这种编译为本地代码的语言。看到新的语言使用垃圾收集来保持这种不可思议的效果真是太好了。（或其他形式的自动内存管理 - <code>Swift</code> 中有提及）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以，读者们，为什么所有这些都离开了你呢？是 Go 复杂还是其他什么原因？</p><p>当然不是，绝对不像 <code>C++</code> 或 <code>Haskell</code> 那样复杂。相比之下，Go 的确很简单。另一方面，比较 Go 和其他常见语言（如<code>Java</code> ，<code>JavaScript</code> ，<code>Python</code> 等）的复杂性时，情况就不太清楚了，正如我希望的那样。 （此外，这是一个很难，没有明确定义的任务。）</p><p>我可以提供类似的例子。在某些方面，Go 可能比这些语言更简单，有些则不是…大致上我会说它和其他常用语言的平均差不多。我也不认为简单，无论是感觉上还是实际使用中，最终的体验很重要。</p><p>最后，这篇文章从哪里来，作者是谁？我不肯定。我还不知道 Go 是否会在我的日常工作中被选为一个（子）项目，或者我是否可能将它用于兴趣爱好项目。我想避免像本文提到的那种教条的社区推广的一份子。有没有意识形态导向的地方呢？ 大家可以随意就此提出建议。</p><p>我和 <code>Rust</code> 社区有同样的问题，请不要介意，我也知道离开那些更狂热的支持者会更好。 （Q：“你能否在 <code>Rust</code> 重写你的项目？”A：“迷失了”）也许这就是这些新语言的性质，以及他们为激励人们如此激励阳光的争斗。</p><hr><p>via: <a href="https://medium.com/@bob.clark_34506/go-is-not-very-simple-folks-3e84220e73c7" target="_blank" rel="noopener">https://medium.com/@bob.clark_34506/go-is-not-very-simple-folks-3e84220e73c7</a></p><p>作者：<a href="https://medium.com/@bob.clark_34506" target="_blank" rel="noopener">The Other Bob</a><br>译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已发布：&lt;a href=&quot;https://studygolang.com/articles/12330&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://studygolang.com/articles/12330&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;伙计们，Go-并没有那么简单&quot;&gt;&lt;a href=&quot;#伙计们，Go-并没有那么简单&quot; class=&quot;headerlink&quot; title=&quot;伙计们，Go 并没有那么简单&quot;&gt;&lt;/a&gt;伙计们，Go 并没有那么简单&lt;/h1&gt;&lt;p&gt;出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。&lt;/p&gt;
&lt;p&gt;到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Beego 入门指南（一）如何新建项目</title>
    <link href="https://blog.yuhanle.com/2017/06/24/beego-study-newproject/"/>
    <id>https://blog.yuhanle.com/2017/06/24/beego-study-newproject/</id>
    <published>2017-06-24T09:00:00.000Z</published>
    <updated>2018-07-05T01:15:35.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何新建项目"><a href="#如何新建项目" class="headerlink" title="如何新建项目"></a>如何新建项目</h1><p>你对beego一无所知？没关系，这篇文档会很好的详细介绍beego的各个方面，看这个文档之前首先确认你已经安装了beego，如果你没有安装的话，请看这篇<a href="https://github.com/astaxie/beego/blob/master/docs/zh/Install.md" target="_blank" rel="noopener">安装指南</a></p><p>beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架，主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架。</p><a id="more"></a><blockquote><p>以下内容需要掌握 golang 的语法基础</p></blockquote><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>首先我们可以看一下入门必学课程，编写一个Hello world 的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/astaxie/beego&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MainController struct &#123;</span><br><span class="line">    beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MainController) Get() &#123;</span><br><span class="line">    this.Ctx.WriteString(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    beego.Router(&quot;/&quot;, &amp;MainController&#123;&#125;)</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的代码保存为hello.go，然后通过命令行进行编译并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build hello.go</span><br><span class="line">$ ./hello</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/545755-436febc86fad703e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170507-084105@2x.png"></p><p>这个时候你可以打开你的浏览器，通过这个地址浏览<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080</a>返回“hello world”</p><p>那么上面的代码到底做了些什么呢？</p><p>1、首先我们引入了包github.com/astaxie/beego,我们知道Go语言里面引入包会深度优先的去执行引入包的初始化(变量和init函数，<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/ebook/02.3.md#maininit" target="_blank" rel="noopener">更多</a>)，beego包中会初始化一个BeeAPP的应用，初始化一些参数。</p><p>2、定义Controller，这里我们定义了一个struct为MainController，充分利用了Go语言的组合的概念，匿名包含了beego.Controller，这样我们的MainController就拥有了beego.Controller的所有方法。</p><p>3、定义RESTFul方法，通过匿名组合之后，其实目前的MainController已经拥有了Get、Post、Delete、Put等方法，这些方法是分别用来对应用户请求的Method函数，如果用户发起的是POST请求，那么就执行Post函数。所以这里我们定义了MainController的Get方法用来重写继承的Get函数，这样当用户GET请求的时候就会执行该函数。</p><p>4、定义main函数，所有的Go应用程序和C语言一样都是Main函数作为入口，所以我们这里定义了我们应用的入口。</p><p>5、Router注册路由，路由就是告诉beego，当用户来请求的时候，该如何去调用相应的Controller，这里我们注册了请求/的时候，请求到MainController。这里我们需要知道，Router函数的两个参数函数，第一个是路径，第二个是Controller的指针。</p><p>6、Run应用，最后一步就是把在1中初始化的BeeApp开启起来，其实就是内部监听了8080端口:Go默认情况会监听你本机所有的IP上面的8080端口</p><p>停止服务的话，请按ctrl+c</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>首先进入goPath目录，通过如下命令创建beego项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src</span><br><span class="line">$ bee new hello</span><br><span class="line"></span><br><span class="line">// bee command</span><br><span class="line">// 默认创建带 view 的工程</span><br><span class="line">// bee new [appname] </span><br><span class="line">// 当然也可以直接快速创建 api 工程</span><br><span class="line">// bee api [appserver]</span><br></pre></td></tr></table></figure><p>这样就建立了一个项目hello，目录结构如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">quickstart</span><br><span class="line">|-- conf</span><br><span class="line">|   `-- app.conf</span><br><span class="line">|-- controllers</span><br><span class="line">|   `-- default.go</span><br><span class="line">|-- main.go</span><br><span class="line">|-- models</span><br><span class="line">|-- routers</span><br><span class="line">|   `-- router.go</span><br><span class="line">|-- static</span><br><span class="line">|   |-- css</span><br><span class="line">|   |-- img</span><br><span class="line">|   `-- js</span><br><span class="line">|-- tests</span><br><span class="line">|   `-- default_test.go</span><br><span class="line">`-- views</span><br><span class="line">    `-- index.tpl</span><br></pre></td></tr></table></figure><p>从目录结构中我们也可以看出来这是一个典型的 MVC 架构的应用，main.go 是入口文件。</p><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>通过bee创建的项目，beego默认情况下是开发模式。<br>我们可以打开app.conf 文件，通过如下的方式改变我们的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beego.RunMode = &quot;pro&quot;</span><br></pre></td></tr></table></figure><p>或者我们在conf/app.conf下面设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runmode = pro</span><br></pre></td></tr></table></figure><p>以上两种效果一样。</p><p>开发模式中</p><ul><li>开发模式下，如果你的目录不存在views目录，那么会出现类似下面的错误提示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017/05/07 9:36:17 [W] [stat views: no such file or directory]</span><br></pre></td></tr></table></figure><ul><li><p>模板会自动重新加载不缓存。</p></li><li><p>如果服务端出错，那么就会在浏览器端显示如下类似的截图：</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/545755-cce31499ceaeda1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170507-090203@2x.png"></p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>首先进入到hello 的根目录，执行以下命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yuhanledeMacBook-Pro:goProject yuhanle$ cd src/hello/</span><br><span class="line">yuhanledeMacBook-Pro:hello yuhanle$ bee run</span><br><span class="line">______</span><br><span class="line">| ___ \</span><br><span class="line">| |_/ /  ___   ___</span><br><span class="line">| ___ \ / _ \ / _ \</span><br><span class="line">| |_/ /|  __/|  __/</span><br><span class="line">\____/  \___| \___| v1.8.3</span><br><span class="line">2017/05/07 08:54:08 INFO     ▶ 0001 Using &apos;hello&apos; as &apos;appname&apos;</span><br><span class="line">2017/05/07 08:54:08 INFO     ▶ 0002 Initializing watcher...</span><br><span class="line">hello/controllers</span><br><span class="line">hello/routers</span><br><span class="line">hello</span><br><span class="line">2017/05/07 08:54:10 SUCCESS  ▶ 0003 Built Successfully!</span><br><span class="line">2017/05/07 08:54:10 INFO     ▶ 0004 Restarting &apos;hello&apos;...</span><br><span class="line">2017/05/07 08:54:10 SUCCESS  ▶ 0005 &apos;./hello&apos; is running...</span><br><span class="line">2017/05/07 08:54:10 [I] [asm_amd64.s:2197] http server Running on http://:8080</span><br></pre></td></tr></table></figure><p>这样我们的应用已经在 8080 端口(beego 的默认端口)跑起来了.你是不是觉得很神奇，为什么没有 nginx 和 apache 居然可以自己干这个事情？是的，Go 其实已经做了网络层的东西，beego 只是封装了一下，所以可以做到不需要 nginx 和 apache。</p><p>然后就可以在浏览器中打开 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 预览我们创建的第一个项目。</p><p><img src="http://upload-images.jianshu.io/upload_images/545755-8f52376c9d2c1e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170507-090245@2x.png"></p><p>下一节：路由设置（预计周末）</p><p>更多内容请参考：<strong><a href="https://github.com/yuhanle/BeegoStudyNotes" target="_blank" rel="noopener">BeegoStudyNotes</a></strong></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://beego.me/docs/quickstart/" target="_blank" rel="noopener">beego 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何新建项目&quot;&gt;&lt;a href=&quot;#如何新建项目&quot; class=&quot;headerlink&quot; title=&quot;如何新建项目&quot;&gt;&lt;/a&gt;如何新建项目&lt;/h1&gt;&lt;p&gt;你对beego一无所知？没关系，这篇文档会很好的详细介绍beego的各个方面，看这个文档之前首先确认你已经安装了beego，如果你没有安装的话，请看这篇&lt;a href=&quot;https://github.com/astaxie/beego/blob/master/docs/zh/Install.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架，主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Beego" scheme="https://blog.yuhanle.com/categories/Beego/"/>
    
    
      <category term="Beego" scheme="https://blog.yuhanle.com/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>GCD 同步异步以及串并行详解</title>
    <link href="https://blog.yuhanle.com/2017/05/02/gcd-sync-parallel/"/>
    <id>https://blog.yuhanle.com/2017/05/02/gcd-sync-parallel/</id>
    <published>2017-05-02T00:00:00.000Z</published>
    <updated>2018-07-05T01:17:36.614Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/gcd/wind-surfing-67627_1920.jpg" alt="浪起来"></p><p>GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语<br><a id="more"></a></p><p>描述多个任务之间同一时刻的运行关系：</p><ul><li>serial（串行） 某一时刻，只执行一个任务</li><li>concurrent（并行） 可以同时执行多个任务</li></ul><p>侧重描述一个函数的执行完成，对其他任务的影响 (既 是否任务在等待某个函数完成，然后才可以运行)：</p><ul><li>synchronous（同步） 任务执行完成后reture，（阻塞）</li><li>asynchronous（异步） 不等待任务执行完成，立即reture，（不阻塞当前）</li></ul><p>在GCD中，我们用串行并行描述队列。这就是在描述，该队列里面的所有任务，相互之间在同一时刻，是怎样的运行关系。是指队列内本身的任务运行顺序。 </p><p>我们还用同步异步，描述某一个任务。比如说任务A是同步执行的。这就是在说，A任务，会阻塞当前任务，直到A结束。这是指不同任务之间的关系，与队列无关，可以是不同队列，也可以是相同队列。</p><p>接下来，我们先来看下，GCD里面的不同队列。</p><h2 id="Serial-Queues"><a href="#Serial-Queues" class="headerlink" title="Serial Queues"></a>Serial Queues</h2><p>在串行队列里，同一时间只能执行一个任务。任务按照被添加进入队列的顺序依次执行。每一个任务只有在前面的任务完成后，才可以开始执行。</p><p>系统为我们提供的串行队列</p><ul><li>main queue ( dispatch_get_main_queue )</li></ul><p>main queue是一个串行队列，有串行队列的一切特性。比较特殊的一点是加入这个队列的任务，都是在主线程执行的。</p><h2 id="Concurrent-Queues"><a href="#Concurrent-Queues" class="headerlink" title="Concurrent Queues"></a>Concurrent Queues</h2><p>加入并行队列的任务，执行的顺序也是按照任务被加入队列的顺序执行，这是我们唯一可以保证的。每个任务都不用等待之前的任务完成，同一时刻可以多个任务同时执行。</p><p>系统同样有一个全局的并发队列</p><ul><li>global dispatch queue ( dispatch_get_global_queue )</li></ul><p>这是另一个我们熟悉的并发队列，很多时候我们直接使用这个队列，可以简单处理一些我们需要并发执行的任务。</p><h2 id="Custom-Queue"><a href="#Custom-Queue" class="headerlink" title="Custom Queue"></a>Custom Queue</h2><p>除了系统提供的全局队列之外，我们还可以自定义串行或者并行的队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>上面是几种我们用GCD时，需要使用到的队列。</p><p>另外，使用GCD，除了选择正确的队列外，还要关注：我们要执行的任务是同步还是异步执行。</p><h2 id="dispatch-async-异步执行"><a href="#dispatch-async-异步执行" class="headerlink" title="dispatch_async 异步执行"></a>dispatch_async 异步执行</h2><p>dispatch_async 用来用异步的方式执行串行或者并行队列里面的任务，我们来看一下使用 dispatch_async 的几种常见情况：</p><ul><li>custom Serial Queue：当我们需要执行几个应该串行执行的任务，又不阻塞当前的时候。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// task1 task2 顺序依次执行，同时不阻塞others</span><br><span class="line"></span><br><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">dispatch_async(mySerialQueue, ^&#123;</span><br><span class="line">   ...task1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(mySerialQueue, ^&#123;</span><br><span class="line">  ...task2</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...others</span><br></pre></td></tr></table></figure><ul><li><p>main Queue：当我们执行并完成了一段异步的任务，需要回到主线程更新UI的时候，很常见的选择就是使用GCD的 main queue。</p></li><li><p>custom or global concurrent Queue：这个是我们执行非UI任务的常见选择。要注意的是，加入队列的多个任务之间并发执行，我们无法知道那个任务先完成。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">  ...task1    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          Update UI </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dispatch-sync-同步执行"><a href="#dispatch-sync-同步执行" class="headerlink" title="dispatch_sync 同步执行"></a>dispatch_sync 同步执行</h2><p>大部分时候我们执行dispatch_sync操作，都要格外小心些。</p><ul><li>custom or main Serial Queue： 同步执行串行队列时，要注意防止发生死锁，比如下面的代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/串行队列中，task2 等待 task1完成，所以不会开始。而task1又完成不了，因为task2还没有执行完(甚至都没有开始)。死锁。</span><br><span class="line">  </span><br><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">dispatch_sync(mySerialQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    ...task1</span><br><span class="line">    dispatch_sync(mySerialQueue, ^&#123;</span><br><span class="line">       </span><br><span class="line">       ...task2            </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>concurrent Queue：合理使用可以解决一些并发读写问题。例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//task1 执行结束后，task2才会开始执行。</span><br><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_sync(myConcurrentQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">  ...task1 读</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">  ...task2 写</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>异步延迟操作。实际上 dispatch_after 就像一个延迟执行的 dispatch_async。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double delayInSeconds = 1.0;</span><br><span class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line"> dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xqhcq.com1.z0.glb.clouddn.com/gcd/wind-surfing-67627_1920.jpg&quot; alt=&quot;浪起来&quot;&gt;&lt;/p&gt;
&lt;p&gt;GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="GCD" scheme="https://blog.yuhanle.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>GCD 同步操作之 Resource Competition</title>
    <link href="https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/"/>
    <id>https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/</id>
    <published>2017-04-28T00:00:00.000Z</published>
    <updated>2018-07-05T01:17:30.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/gcd/surfer-2212948_1920.jpg" alt="更快更高更强"></p><p>在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。<br><a id="more"></a></p><h2 id="dispatch-barriers"><a href="#dispatch-barriers" class="headerlink" title="dispatch barriers"></a>dispatch barriers</h2><p>在使用 Concurrent Queue 的时候，有时候我们希望队列中的某项任务，能够被串行执行，来避免资源竞争等多线程问题。比如遇到读写问题，这时候我们就需要使用 dispatch barriers。来保证即使在并行队列中，对某个对象的读和写操作，在同一时刻，只有一个可以被执行。这时候就可以用到 dispatch barriers了。下面我们来讨论一下，不同的队列中barriers的使用：</p><ul><li><p>Custom Serial Queue: 在串行队列中，队列都是顺序串行执行，使用barriers没有任何好处。一般来讲我们不需要这么做。</p></li><li><p>Global Concurrent Queue: 这里虽然是并行队列，但这个队列是全局的，我们不能保证别人没有使用这个队列。对这个队列加barriers，可能会影响到其他模块的功能。所以不建议在这个队列中使用。</p></li><li><p>Custom Concurrent Queue: 在自定义的并行队列中使用barriers，是比较合适的方式。</p></li></ul><p>所以当我们要做的并行操作，可能存在线程安全问题的时候。我们最好考虑新建自定义并行队列，而不是简单地使用系统提供的 Global Queue。</p><p>举一个例子，假设某一个类要管理MyClass这个类型的读写，下面列举这个类的一些相关方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//初始化自定义并发队列</span><br><span class="line">  - (instancetype)init&#123;</span><br><span class="line">      </span><br><span class="line">      if(self = [super init])&#123;</span><br><span class="line">          customConcurrentQueue = dispatch_queue_create(&quot;com.customConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //写方法</span><br><span class="line">  - (void)write:(MyClass *)myClass &#123;</span><br><span class="line">  </span><br><span class="line">      if( myClass )&#123;</span><br><span class="line">          </span><br><span class="line">          //使用barrier，保证写方法，可以串行执行</span><br><span class="line">            dispatch_barrier_async(self.customConcurrentQueue, ^&#123; </span><br><span class="line">              </span><br><span class="line">              //写操作</span><br><span class="line">              ...</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //读方法</span><br><span class="line">  - (MyClass *)read&#123;</span><br><span class="line">      </span><br><span class="line">      //要保证，读和写方法不能同时执行，</span><br><span class="line">      //首先，他们要在同一个队列中 ：self.customConcurrentQueue</span><br><span class="line">      //其次，读方法要等待读出数据后返回，所以应该是同步操作 ：dispatch_sync</span><br><span class="line">      </span><br><span class="line">      __block MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">      </span><br><span class="line">      dispatch_sync(self.customConcurrentQueue, ^&#123;</span><br><span class="line">      </span><br><span class="line">          //读操作</span><br><span class="line">          myClass = ...</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      return myClass;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="dispatch-groups"><a href="#dispatch-groups" class="headerlink" title="dispatch groups"></a>dispatch groups</h2><p>有时候，我们需要在多个并行任务全部完成后，做一些操作，这时候就需要用到 group来管理了。</p><p>举一个简单的例子。我有4个任务要使用并发处理，任务4要等待，任务1、2、3完成后执行。同时，任务4不阻塞当前的线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroup&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.test.testConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  //异步操作</span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务1</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务2</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务3</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //dispatch_group_notify 中的block执行的是我们最后要做的任务。同时，这里是异步操作，不会阻塞后面其他代码的执行。</span><br><span class="line">  dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      </span><br><span class="line">      //前面3个任务，都执行完成后，执行里面的block</span><br><span class="line">      任务4</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看另一个需求，还是之前的4个任务。唯一的区别是，任务4除了要等待其他任务完成，还要阻塞当前线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroup&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  //异步操作</span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务1</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务2</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务3</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  //dispatch_group_wait 等待上面任务全部完成，阻塞当前线程，直到超过设置的时间</span><br><span class="line">  //使用时，要注意避免阻塞主线程等问题</span><br><span class="line">  dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">  </span><br><span class="line">  任务4</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，除了使用<code>dispatch_group_async</code>管理要做的任务。还可以使用<code>dispatch_group_enter</code>、 <code>dispatch_group_leave</code> 组合的方式，手动通知任务完成。如果使用手动管理的话，我们要注意：<code>enter</code>和<code>leave</code>方法，应该是成对出现的。</p><p>dispatch_group_enter(customGroup) : 手动告知customGroup，表示一个任务已经开始执行。</p><p>dispatch_group_leave(customGroup) : 手动告知<code>customGroup</code>，表示一个任务已经完成。当所有<code>enter</code>对应的<code>leave</code>方法都执行过后。我们的<code>dispatch_group_notify()</code>或者<code>dispatch_group_wait()</code>，就可以接到任务完成的通知。</p><h2 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch semaphore 信号量"></a>dispatch semaphore 信号量</h2><p>当有多个消费者，访问有限的资源的时候，<a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="noopener">信号量</a>) 可以让我们更好的控制。简单来说，我们通过对信号个数的控制，来达到线程间的同步操作。当信号个数为0的时候，当前线程被阻塞，等待信号量增加，当信号量个数大于0的时候，则线程继续执行。</p><p>注意，同步的操作都要小心使用，避免死锁等问题。</p><p>另外，根据dispatch_semaphore_wait的返回值，可以用于判断某任务是否超时操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)testSemaphore&#123;</span><br><span class="line"></span><br><span class="line">  //创建 信号量 参数代表初始个数</span><br><span class="line">  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">      sleep(2);</span><br><span class="line">  </span><br><span class="line">      //发送一个信号，信号量个数 +1   </span><br><span class="line">      dispatch_semaphore_signal(semaphore);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">      dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);</span><br><span class="line">  </span><br><span class="line">      //线程等待，当信号量大于0时 任务继续执行，信号量 -1</span><br><span class="line">      //线程等待，超过预定的超时时间 任务继续执行 信号量不变</span><br><span class="line">      //关于返回值：当返回值 不为0 的时候，说明超时</span><br><span class="line">      if( dispatch_semaphore_wait(semaphore, timeoutTime) )&#123;</span><br><span class="line">          NSLog(@&quot;time out&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xqhcq.com1.z0.glb.clouddn.com/gcd/surfer-2212948_1920.jpg&quot; alt=&quot;更快更高更强&quot;&gt;&lt;/p&gt;
&lt;p&gt;在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="GCD" scheme="https://blog.yuhanle.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>离开象牙塔以后</title>
    <link href="https://blog.yuhanle.com/2017/04/18/say-hello-work/"/>
    <id>https://blog.yuhanle.com/2017/04/18/say-hello-work/</id>
    <published>2017-04-18T00:00:00.000Z</published>
    <updated>2018-07-05T01:20:17.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xqhcq.com1.z0.glb.clouddn.com/nenshuocijun/architecture-768432_1920.jpg" alt="离开象牙塔以后"></p><p>学校出来有很多区别，其中有一点是最无聊的。</p><a id="more"></a><p>由过去的三点一线，转变成两点一线，没了教室，没了食堂，变成了公司和宿舍。</p><p>没有认真数过，平均每天，在同一条路上来回，将近三年，磨平了几双鞋子，擦碰过多少次路边的槐树。</p><p>出了地铁站，有一个红绿灯路口，八点半钟是高峰期，人正多，很多人迫不及待，趁着车来车往，迅速的窜到对面，急匆匆地消失在视线里。</p><p>习惯过了马路，穿过停车场，因为路边的小路很窄，如果对面同时走过来一个人，就需要相互侧身，就像那篇雨巷，也经常的不小心踩到石坑，污泥溅到另一双鞋子。</p><p>停车场里走着，很危险，可能正在玩手机，我没注意。有一次，有位女士，低着头走着走着，穿过停车杆，没想到停车杆当时正在下落，我能听到敲击头部的声音，很脆，接着就是歇斯底里的嗷叫。</p><p>路边有个快客，我一直以为他是假的快客，在我印象中，这个名字不应该是感冒药吗？很少去光顾这家便利店，因为东西少，不合口味，还特别的贵，除了早餐，还有午饭，零食，如果时间来得及，我会去那家罗森买杯永和豆浆，虽然喝起来没有大豆的味道，但还蛮合口味，特别是冬天，路上顺便暖暖手。</p><p>办公楼里的电梯，工作日上班时间，我没有乘过。就在五楼，闭着眼我都摸上去了，平日里吹嘘着锻炼身体，要减肥，这也是唯一能够坚持下去，锻炼的方式了。</p><p>很想念，两年前每天来回骑行20公里的日子，身体是好了些，腿越来越粗，越有力，凌晨两点的路上，迎着风，骑在快车道上，肚子饿的话就在路边吃点路边摊。摊主们出来的很晚，以至于我的很多朋友都说没见过路边摊，也许是上海整治的很严格吧！</p><p>不管这一天，如何如何，也不会影响新的一天。</p><p>或许，只有清华北大才能称之为象牙塔吧？</p><hr><p>题图：aobahorse 不要求署名</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xqhcq.com1.z0.glb.clouddn.com/nenshuocijun/architecture-768432_1920.jpg&quot; alt=&quot;离开象牙塔以后&quot;&gt;&lt;/p&gt;
&lt;p&gt;学校出来有很多区别，其中有一点是最无聊的。&lt;/p&gt;
    
    </summary>
    
      <category term="suibi" scheme="https://blog.yuhanle.com/categories/suibi/"/>
    
    
      <category term="motion" scheme="https://blog.yuhanle.com/tags/motion/"/>
    
  </entry>
  
</feed>
